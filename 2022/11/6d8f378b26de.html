<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: 读书笔记 | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="深入理解 cpp 对象模型读书笔记(这本书原文有非常非常非常多的错误, 建议看侯捷译文)">
<meta property="og:type" content="article">
<meta property="og:title" content="insidecpp">
<meta property="og:url" content="https://sinos_wei.gitee.io/2022/11/6d8f378b26de.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:description" content="深入理解 cpp 对象模型读书笔记(这本书原文有非常非常非常多的错误, 建议看侯捷译文)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/IMG_2408.jpg">
<meta property="article:published_time" content="2022-11-08T06:49:47.000Z">
<meta property="article:modified_time" content="2023-08-01T08:07:38.298Z">
<meta property="article:author" content="Sinos">
<meta property="article:tag" content="class">
<meta property="article:tag" content="virtual">
<meta property="article:tag" content="vtable">
<meta property="article:tag" content="offset">
<meta property="article:tag" content="member">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/IMG_2408.jpg"><link rel="shortcut icon" href="/img/cover/IMG_2242.jpg"><link rel="canonical" href="https://sinos_wei.gitee.io/2022/11/6d8f378b26de.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: 读书笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-01 16:07:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cover/IMG_2242.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/IMG_2408.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Sinos_wei's blog"><span class="site-name">Sinos_wei's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">insidecpp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-08T06:49:47.000Z" title="Created 2022-11-08 14:49:47">2022-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-01T08:07:38.298Z" title="Updated 2023-08-01 16:07:38">2023-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="insidecpp"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>深入理解 cpp 对象模型读书笔记(这本书原文有非常非常非常多的错误, 建议看侯捷译文)</p>
</blockquote>
<span id="more"></span>
<h1 id="chapter-1.-object-lessons">Chapter 1. Object Lessons</h1>
<h2 id="layout-costs-for-adding-encapsulation">Layout Costs for Adding Encapsulation</h2>
<p>主要的 overhead 来自于 virtual 机制</p>
<h2 id="the-c-object-model">1.1 The C++ Object Model</h2>
<p>slot 模型</p>
<p>table 模型</p>
<p><strong>c++ 模型:</strong></p>
<ul>
<li>nonstatic member 在 object 内</li>
<li>static member, nonstatic 和 static function 在 object 外</li>
<li>每个类有一个 vtb(?)</li>
<li>每个 object 中有 vptr 指向 vtb(多继承不止一个, 继承自几个父类就有几个 vtb)</li>
<li>type_info 存储在 vtb 中用来支持 runtime 类型检查(RTTI)</li>
<li>base class member 直接存储在 derived object 中</li>
<li>虚基类: The original model of virtual base class support <strong>added a pointer into the class object for each associated virtual base class.</strong> Alternative models have evolved that either introduce <strong>a virtual base class table or augment the existing virtual table to maintain the location of each virtual base class</strong></li>
</ul>
<h2 id="a-keyword-distinction">1.2. A Keyword Distinction</h2>
<p>关于 struct 和 class</p>
<p>The data members within a single access section are guaranteed within C++ to be laid out in the order of their declaration.</p>
<p><strong>c++中多个 access setion 的 data layout 不确定</strong></p>
<p><strong>同样, base class 和 derived class 的成员 layout 顺序也不确定</strong></p>
<p><strong>virtual机制也会影响 layout</strong></p>
<p>The layout of data contained in multiple access sections, however, is left undefined. In the following declaration, for example, the C trick may or may not work, depending on whether the protected data members are placed before or after those declared private:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stumble</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// operations ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// protected stuff</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">/* private stuff */</span></span><br><span class="line">   <span class="type">char</span> pc[ <span class="number">1</span> ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为 layout 可能产生的变化, 在 c++中使用 c 风格的最好方法是包含而不是继承</p>
<h2 id="an-object-distinction">1.3. An Object Distinction</h2>
<p>In the OO paradigm, the programmer manipulates an unknown instance of a bounded but infinite set of types.</p>
<p>The actual type of the object addressed is not resolved in principle until <strong>runtime</strong> at each particular point of execution.</p>
<p>In C++, this is achieved only through the manipulation of objects through <strong>pointers and references</strong>.</p>
<p>In contrast, in the ADT paradigm the programmer manipulates <strong>an instance of a fixed, singular type that is completely defined at the point of compilation</strong>.</p>
<p>一个指针可能指向他和他的子类中的任一种实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   X datum,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> X *pointer,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> X &amp;reference )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// cannot determine until run-time</span></span><br><span class="line">   <span class="comment">// actual instance of rotate() invoked</span></span><br><span class="line">   (*pointer).<span class="built_in">rotate</span>();</span><br><span class="line">   reference.<span class="built_in">rotate</span>();</span><br><span class="line">   <span class="comment">// always invokes X::rotate()</span></span><br><span class="line">   datum.<span class="built_in">rotate</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>() &#123;</span><br><span class="line">   Z z; <span class="comment">// a subtype of X</span></span><br><span class="line">   <span class="built_in">rotate</span>( z, &amp;z, z );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>内存对 object 的要求: nonstatic memeber 大小, padding, vitual 机制</p>
<p><strong>不同类型的指针区别在于</strong>: That is, the type of a pointer instructs the compiler as to how to interpret the memory found at a particular address and also just how much memory that interpretation should span</p>
<p>eg:</p>
<ul>
<li>An integer pointer addressing memory location 1000 on a 32-bit machine spans the address space 1000—1003.</li>
<li>The ZooAnimal pointer, if we presume a conventional 8-byte String (a 4-byte character pointer and an integer to hold the string length), spans the address space 1000—1015.(还有其他成员)</li>
<li>ust out of curiosity, what address space does a <strong>void</strong>* pointer that holds memory location 1000 span? That's right, we don't know. That's why a pointer of type void* can only hold an address and not actually operate on the object it addresses.</li>
</ul>
<h3 id="static_cast">static_cast</h3>
<p><code>static_cast</code> is used for cases where you basically want to reverse an implicit conversion, with a few restrictions and additions. <code>static_cast</code> performs no runtime checks. This should be used if you know that you refer to an object of a specific type, and thus a check would be unnecessary. Example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span> *data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Conversion from MyClass* -&gt; void* is implicit</span></span><br><span class="line">MyClass *c = <span class="built_in">static_cast</span>&lt;MyClass*&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyClass c;</span><br><span class="line"><span class="built_in">start_thread</span>(&amp;func, &amp;c)  <span class="comment">// func(&amp;c) will be called</span></span><br><span class="line">.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this example, you know that you passed a <code>MyClass</code> object, and thus there isn't any need for a runtime check to ensure this.</p>
<h3 id="dynamic_cast">dynamic_cast</h3>
<p><code>dynamic_cast</code> is useful when you don't know what the dynamic type of the object is. <strong>It returns a null pointer if the object referred to doesn't contain the type casted to as a base class</strong> (when you cast to a reference, a <code>bad_cast</code> exception is thrown in that case).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (JumpStm *j = <span class="built_in">dynamic_cast</span>&lt;JumpStm*&gt;(&amp;stm)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExprStm *e = <span class="built_in">dynamic_cast</span>&lt;ExprStm*&gt;(&amp;stm)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can <strong>not</strong> use <code>dynamic_cast</code> for downcast (casting to a derived class) if the argument type is not polymorphic. For example, the following code is not valid, because <code>Base</code> <strong>doesn't contain any virtual function:</strong></p>
<p>(如果有 virtual 可以转换)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Derived d; Base *b = &amp;d;</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="comment">// Invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>An "up-cast" (cast to the base class) is always valid with both <code>static_cast</code> and <code>dynamic_cast</code>, and also without any cast, as an "up-cast" is an implicit conversion (assuming the base class is accessible, i.e. it's a <code>public</code> inheritance).</p>
<p>see also</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">L</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="type">int</span> m;</span><br><span class="line"> <span class="comment">//virtual void f()&#123;&#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> L &#123;<span class="keyword">public</span>:  <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : L &#123;<span class="keyword">public</span>:  <span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A , B &#123;<span class="keyword">public</span>:  <span class="type">int</span> c; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> C c;</span><br><span class="line"> C* pc = &amp;c;</span><br><span class="line"> A* pa = (A*)pc;</span><br><span class="line"></span><br><span class="line"> C* pcc = <span class="built_in">static_cast</span>&lt;C*&gt;(pa);</span><br><span class="line"> <span class="comment">//如果有 virtual 用 dynamic_cast 和 static_cast 都行</span></span><br><span class="line"> <span class="comment">//没有 virtual 就只能 static_cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="regular-cast">Regular Cast</h3>
<p>These casts are also called C-style cast. A C-style cast is basically identical to trying out a range of sequences of C++ casts, and taking the first C++ cast that works, without ever considering <code>dynamic_cast</code>. Needless to say, this is much more powerful as it combines all of <code>const_cast</code>, <code>static_cast</code> and <code>reinterpret_cast</code>, but it's also unsafe, because it does not use <code>dynamic_cast</code>.</p>
<p>In addition, C-style casts not only allow you to do this, but they also allow you to safely cast to a private base-class, while the "equivalent" <code>static_cast</code> sequence would give you a compile-time error for that.</p>
<p>Some people prefer C-style casts because of their brevity. I use them for numeric casts only, and use the appropriate C++ casts when user defined types are involved, as they provide stricter checking.</p>
<p>base = derived</p>
<p><strong>When a base class object is directly initialized or assigned with a derived class object,</strong> the derived object is <strong>sliced</strong> to fit into the available memory resources of the base type. There is nothing of the derived type remaining. Polymorphism is not present, and an observant compiler can resolve an invocation of a virtual function through the object at compile time, thus by-passing the virtual mechanism. This can be a significant performance win if the virtual function is defined as inline.</p>
<h1 id="chapter-2.-the-semantics-of-constructors">Chapter 2. The Semantics of Constructors</h1>
<p><strong>Global objects</strong> are guaranteed to have <strong>their associated memory "zeroed out" at program start-up.</strong></p>
<p>Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.</p>
<blockquote>
<p>大原则: 用户定义了构造函数就 compiler 就不生成隐含默认构造函数</p>
</blockquote>
<h2 id="default-constructor-construction">2.1. Default Constructor Construction</h2>
<p>compiler 只做 implement 需要的事情, 只有当 implementation 需要的时候才会生成 default constructor</p>
<p>例如 int, 指针等不会被implicit默认构造函数初始化(值为随机值)</p>
<p>以上这种默认构造属于 trivial</p>
<p>一下几种情况默认构造函数是 nontrivial</p>
<h3 id="含有有默认构造函数的成员">含有有默认构造函数的成员</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  <span class="comment">//public:</span></span><br><span class="line">  <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;?&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    C c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">  <span class="comment">//ERROR: call to implicitly-deleted default constructor of &#x27;Base&#x27;</span></span><br><span class="line">  <span class="comment">//但是书上说会生成隐含默认构造函数, 这个函数会初始化 C 但是不会初始化 int 指针等类型的成员. 有点矛盾?</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题解决: C 的构造函数要是 public 就不会报错, 和书上一致</span></span><br></pre></td></tr></table></figure>
<p>The language requires that the (member) constructors be invoked in the order of member declaration within the class.(before user code)</p>
<h4 id="关于初始化顺序">关于初始化顺序</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">C1</span>() &#123; cout &lt;&lt; <span class="string">&quot;C1&quot;</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">C2</span>() &#123; cout &lt;&lt; <span class="string">&quot;C2&quot;</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        C2 c2;</span><br><span class="line">        C1 c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>() : <span class="built_in">c2</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base&quot;</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derive</span> : Base &#123;</span><br><span class="line">        C1 c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derive</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derive&quot;</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Derive d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C2C1BaseC1Derive</span></span><br><span class="line"><span class="comment">//可见, 隐含成员构造和构造列表的顺序都取决于成员声明的顺序</span></span><br><span class="line"><span class="comment">//同时, 基类初始化在成员初始化之前</span></span><br></pre></td></tr></table></figure>
<h3 id="基类有默认构造函数">基类有默认构造函数</h3>
<h3 id="类中有虚函数">类中有虚函数</h3>
<ol type="1">
<li>类里声明或者继承了一个虚函数</li>
<li>基类链里有虚函数</li>
</ol>
<p>这种情况需要对 vptr 进行初始化</p>
<h3 id="有虚基类">有虚基类</h3>
<p>Virtual base class implementations vary widely across compilers. However, what is common to each implementation is the need to make the virtual base class location within each derived class object available at runtime.**</p>
<p>例如在 cfront 中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X   &#123; <span class="keyword">public</span>: <span class="type">int</span> j; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X   &#123; <span class="keyword">public</span>: <span class="type">double</span> d; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; <span class="keyword">public</span>: <span class="type">int</span> k; &#125;;</span><br><span class="line"><span class="comment">// cannot resolve location of pa-&gt;X::i at compile-time</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">( <span class="type">const</span> A* pa )</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"><span class="built_in">main</span>() &#123;</span><br><span class="line">   <span class="built_in">foo</span>( <span class="keyword">new</span> A );</span><br><span class="line">   <span class="built_in">foo</span>( <span class="keyword">new</span> C );</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// possible compiler transformation</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">( <span class="type">const</span> A* pa )</span> </span>&#123; pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="copy-constructor-construction">2.2. Copy Constructor Construction</h2>
<p>三种情况:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; ... &#125;;</span><br><span class="line">   X x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// explicit initialization of one class object with another</span></span><br><span class="line">X xx = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//as argument</span></span><br><span class="line"><span class="built_in">foo</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//as return </span></span><br><span class="line"><span class="function">X <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="default-memberwise-initialization">default memberwise initialization</h3>
<p>Default memberwise initialization <strong>copies the value of each built-in or derived data member</strong> (such as a pointer or an array) from the one class object to another. A <strong>member class object, however, is not copied; rather, memberwise initialization is recursively applied</strong>.</p>
<h3 id="bitwise-copy-semantics">bitwise copy semantics</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Word</span>( <span class="type">const</span> <span class="type">char</span>* );</span><br><span class="line">   ~<span class="built_in">Word</span>() &#123; <span class="keyword">delete</span> [] str; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span>   cnt;</span><br><span class="line">	 <span class="type">char</span> *str; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不需要生成 copy 构造函数, 不涉及函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Word</span>( <span class="type">const</span> String&amp; );</span><br><span class="line">   ~<span class="built_in">Word</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span>    cnt;</span><br><span class="line">   String str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生成 copy 构造函数来调用 string 的拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>一下四种情况的 class 不存在 bitwise copy semantics</p>
<ol type="1">
<li>含有成员, 他有拷贝构造函数(无论是自定义的还是编译器组装的)</li>
<li>继承自有拷贝构造函数的类(自定义的或编译器的)</li>
<li>声明了虚函数</li>
<li>继承链里有虚基类</li>
</ol>
<h3 id="有虚函数的重置-vptr">有虚函数的重置 vptr</h3>
<p>只要引入了 vptr 就不存在逐位拷贝语义, 需要拷贝构造函数来初始化 vptr</p>
<p>如果是 derived = base, vptr 不能直接复制, 必须要正确初始化 vptr</p>
<h3 id="关于虚基类-subobject">关于虚基类 subobject</h3>
<p>构造函数需要: 初始化 vptr, 定位 基类 subobject</p>
<p>还是 derived = base</p>
<h2 id="program-transformation-semantics">2.3. Program Transformation Semantics</h2>
<p>参数传入 和 结果返回 copy 构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">( X x0 )</span></span>;</span><br><span class="line"><span class="comment">// Pseudo C++ code compiler generated temporary</span></span><br><span class="line">X __temp0;</span><br><span class="line"><span class="comment">// compiler invocation of copy constructor</span></span><br><span class="line">__temp0.X::<span class="built_in">X</span> ( xx );</span><br><span class="line"><span class="comment">// rewrite function call to take temporary</span></span><br><span class="line"><span class="built_in">foo</span>( __temp0 );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">( X&amp; __result )</span></span>&#123;</span><br><span class="line">	 X xx;</span><br><span class="line">   <span class="comment">// compiler generated invocation of default constructor</span></span><br><span class="line">   xx.X::<span class="built_in">X</span>();</span><br><span class="line">   <span class="comment">// compiler generated invocation</span></span><br><span class="line">   <span class="comment">// of copy constructor</span></span><br><span class="line">   __result.X::<span class="built_in">X</span>( xx );</span><br><span class="line">   <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pseudo C++ Code 不再调用 copy 构造函数, NRV</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">( X &amp;__result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   __result.X::<span class="built_in">X</span>( y, z );</span><br><span class="line">   <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;std::cout&lt;&lt;<span class="string">&quot;default&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b) &#123; std::cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">fun</span><span class="params">(B b)</span> </span>&#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    B b;</span><br><span class="line">    B b_copy = <span class="built_in">fun</span>(b);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">fun</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">default</span></span><br><span class="line"><span class="comment">copy</span></span><br><span class="line"><span class="comment">copy</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">copy</span></span><br><span class="line"><span class="comment">copy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="member-initialization-list">2.4. Member Initialization List</h2>
<p>必须使用初始化列表:</p>
<p>reference, const, invoke base or member 带参构造函数</p>
<p>在函数体内的用赋值初始化会导致</p>
<ul>
<li>先调用默认构造函数</li>
<li>再调用赋值</li>
<li>摧毁临时对象</li>
</ul>
<p>The compiler iterates over the initialization list, <strong>inserting the initializations in the proper order within the constructor prior to any explicit user code.</strong>其顺序是根据声明顺序而不是 list 的顺序</p>
<p>最好不要在 list 里调用成员函数, 因为不清楚这个成员函数是否依赖其他成员</p>
<p><strong>问: this 指针何时初始化?</strong></p>
<h1 id="chapter-3.-the-semantics-of-data">Chapter 3. The Semantics of Data</h1>
<p>空类对象; sizeof == 1</p>
<h2 id="the-binding-of-a-data-member">3.1. The Binding of a Data Member</h2>
<p><strong>the analysis of the member function's body is delayed until the entire class declaration is seen.</strong></p>
<p>This is not true of the argument list of the member function, however. <strong>Names within the argument list are still resolved in place at the point they are first encountered.</strong></p>
<p>Nonintuitive bindings between extern and nested type names, therefore, can still occur. In the following code fragment, for example, the type of length in both member function signatures resolves to that of the global typedef—that is, to int. When the subsequent declaration of the nested typedef of length is encountered, the Standard requires that the earlier bindings be flagged as illegal:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> length;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// oops: length resolves to global</span></span><br><span class="line">   <span class="comment">// ok: _val resolves to Point3d::_val</span></span><br><span class="line">   <span class="built_in">mumble</span>( length val ) &#123; _val = val; &#125;</span><br><span class="line">   <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">// length must be seen before its first</span></span><br><span class="line">   <span class="comment">// reference within the class.  This</span></span><br><span class="line">   <span class="comment">// declaration makes the prior reference illegal.</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="type">float</span> length;</span><br><span class="line">   length _val;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="data-member-layout">3.2. Data Member Layout</h2>
<p>The Standard requires <strong>within an access section</strong> (the private, public, or protected section of a class declaration) only that <strong>the members be set down such that "later members have higher addresses within a class object"</strong> . That is, the members are not required to be set down contiguously. What might intervene between the declared members? Alignment constraints on the type of a succeeding member may require padding. This is true both of C and C++, and in this case, the member layout of the two languages is in current practice the same.</p>
<p>The Standard also allows the <strong>compiler the freedom to order the data members within multiple access sections</strong> within a class in whatever order it sees fit.</p>
<p>即一个 access session 里是根据生命顺序 layout, 不同 session 之间是取决于编译器的</p>
<p>多个 session 不占用额外空间</p>
<h2 id="access-of-a-data-member">3.3. Access of a Data Member</h2>
<h3 id="static-member">static member</h3>
<p>实例和指针访问效率相同</p>
<h3 id="nonstatic-member">nonstatic member</h3>
<p>Access of a nonstatic data member requires <strong>the addition of the beginning address of the class object with the offset location of the data member.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.m_y;</span><br><span class="line">--&gt;</span><br><span class="line">&amp;c + (&amp;C::m_y - <span class="number">1</span>) ;</span><br><span class="line">???</span><br><span class="line"><span class="comment">//注意里面的 -1 是为了让编译系统区分</span></span><br><span class="line"><span class="comment">//a pointer to data member that is addressing the first member of a class and no member.</span></span><br></pre></td></tr></table></figure>
<p>nonstatic member 的 offset 在编译时就知道, 访问时间与 c 无异</p>
<p>当有虚基类的时候, 访问会慢</p>
<h2 id="inheritance-and-the-data-member">3.4. Inheritance and the Data Member</h2>
<blockquote>
<p>(原文有较大问题请看侯捷译文)</p>
</blockquote>
<p>继承可能会导致 padding, 这些 padding 如果被优化会导致 base = derived 无法实现</p>
<p>多重继承时, derived 和第二及后续 base 的关系是不自然的</p>
<p>Base* bp = &amp;derived_object; 起始地址是一样的</p>
<p>Seconde_base* bsp = &amp;derived_object; 起始地址不一样需要调整</p>
<p>但是除了直接offset调整, 还需要增加是否为空的判断, 否则可能得到一个 sizeof 值</p>
<h3 id="虚继承的菱形继承问题">虚继承的菱形继承问题</h3>
<p>A class containing one or more virtual base class subobjects, such as istream, is divided into two regions: <strong>an invariant region and a shared region</strong>. <strong>Data within the invariant region remains at a fixed offset from the start of the object regardless of subsequent derivations</strong>. So members within the invariant region can be accessed directly. <strong>The shared region represents the virtual base class subobjects. The location of data within the shared region fluctuates with each derivation.</strong> <strong>So members within the shared region need to be accessed indirectly.</strong> What has varied among implementations is the method of indirect access.</p>
<p>即独立区域是直接访问, 共享区域是间接访问</p>
<p>a pointer to each virtual base class is inserted within each derived class object.</p>
<p>一种方法是 is to place not the address but the offset of the virtual base class within the virtual function table.</p>
<p>把到共享区的 offset 存在各个基类的 vptr[-1]里</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h81e4fo2zpj316y0u00vt.jpg" alt="IMG_4316F8EDE31A-1" /><figcaption aria-hidden="true">IMG_4316F8EDE31A-1</figcaption>
</figure>
<h2 id="object-member-efficiency">3.5. Object Member Efficiency</h2>
<p>几个表格</p>
<h2 id="pointer-to-data-members">3.6. Pointer to Data Members</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string Student::*p = &amp;Student::m_name;</span><br><span class="line">Student s;</span><br><span class="line">s.*p;</span><br><span class="line">成员指针的值是 object 中成员的 offset + <span class="number">1</span></span><br><span class="line">+<span class="number">1</span> 是为了区分一个指针指向的是 没有 member 还是 第一个 member</span><br><span class="line">但是实际编译器里并没有体现+<span class="number">1</span>, 这条可以忽略</span><br><span class="line"><span class="function">both the <span class="title">compiler</span> <span class="params">(<span class="keyword">and</span> the user)</span> must remember to subtract 1 before</span></span><br><span class="line"><span class="function">actually <span class="keyword">using</span> the value to address a member.</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>一些表格</p>
<h1 id="chapter-4.-the-semantics-of-function">Chapter 4. The Semantics of Function</h1>
<h2 id="varieties-of-member-invocation">4.1. Varieties of Member Invocation</h2>
<p>member function 会被编译器内化为nonmember函数的形式</p>
<p>虚函数可以被声明为 inline, 当通过 object 直接调用时不会触发多态, 会使用 inline</p>
<h2 id="virtual-member-functions">4.2. Virtual Member Functions</h2>
<p>(纯虚函数如果没有被实现是不会分配虚函数 index 的)</p>
<p>虚函数在 runtime 期间的调用</p>
<ul>
<li>我不知道 ptr 所指的真正类型, 但是我知道 ptr指向一个 vtb</li>
<li>我不知道哪个func()是哪个函数, 但我知道所有的 func()在 vtb 中都有一个相同的 index</li>
</ul>
<h3 id="多重继承下的-virtual">多重继承下的 virtual</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//编译时会改写为</span></span><br><span class="line">Derived *tmp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *pbase2 = tmp? tmp+<span class="built_in">sizeof</span>(Base1):<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>多重继承下 一个 derived class 内含有 n-1 个额外的vtb, n 表示 base 个数, 所以单一继承不会有多余的 vtb 产生</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h824194s4kj30w20sm0ww.jpg" alt="截屏2022-11-12 09.57.52" /><figcaption aria-hidden="true">截屏2022-11-12 09.57.52</figcaption>
</figure>
<p>多重继承影响虚拟机制的情况有以下三种</p>
<ol type="1">
<li><p>用 base2 指针调用 derived virtual function</p></li>
<li><p>用 derived 指针调用 base2 virtual function</p></li>
<li><p>```cpp Base2 <em>pb2_1 = new Derived; Base2 </em>pb2_2 = pb2_1-&gt;clone(); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 4.3. Function Efficiency  </span><br><span class="line"></span><br><span class="line">inline 为程序优化提供更多可能</span><br><span class="line"></span><br><span class="line">表格</span><br><span class="line"></span><br><span class="line">## 4.4. Pointer-to-Member Functions </span><br><span class="line"></span><br><span class="line">不涉及虚拟的成员函数指针</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">double(Point::*pmf)() = &amp;Point::x;</span><br><span class="line">(origin.*pmf)();</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>虚拟成员函数指针</p>
<p>它的值只是索引而不是真实地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*ptr-&gt;vptr[(<span class="type">int</span>)pmf])(ptr);</span><br></pre></td></tr></table></figure>
<h2 id="inline-functions">4.5. Inline Functions</h2>
<p>处理一个 inline 函数两个各个阶段</p>
<ol type="1">
<li>分析函数定义(分析其复杂度, 判断是否能成为 inline)</li>
<li>判断在调用处是否可以扩展</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">min</span><span class="params">( <span class="type">int</span> i, <span class="type">int</span> j )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> minval;</span><br><span class="line">   <span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line">   <span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line"><span class="comment">/*(1)*/</span>minval = <span class="built_in">min</span>( val1, val2 );</span><br><span class="line"><span class="comment">/*(2)*/</span>minval = <span class="built_in">min</span>( <span class="number">1024</span>, <span class="number">2048</span> );</span><br><span class="line"><span class="comment">/*(3)*/</span>minval = <span class="built_in">min</span>( <span class="built_in">foo</span>(), <span class="built_in">bar</span>()+<span class="number">1</span> );</span><br><span class="line">   <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) simple argument substitution</span><br><span class="line">minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">(<span class="number">2</span>) constant folding following substitution</span><br><span class="line">minval = <span class="number">1024</span>;</span><br><span class="line">(<span class="number">3</span>) side-<span class="function">effects <span class="keyword">and</span> introduction of <span class="title">temporary</span><span class="params">(避免表达式重复求值)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> t1</span>;</span><br><span class="line"><span class="type">int</span> t2;</span><br><span class="line">minval =</span><br><span class="line">   ( t1 = <span class="built_in">foo</span>() ), ( t2 = <span class="built_in">bar</span>() + <span class="number">1</span> ),</span><br><span class="line">   t1 &lt; t2 ? t1 : t2;</span><br></pre></td></tr></table></figure>
<p>inline 函数可能会导致大量的扩展码(局部变量)</p>
<h1 id="chapter-5.-semantics-of-construction-destruction-and-copy.">Chapter 5. Semantics of Construction, Destruction, and Copy.</h1>
<p>Presence of a Pure Virtual destructor</p>
<p>Presence of a Virtual Specification</p>
<p>Presence of const within a Virtual Specification</p>
<h2 id="object-construction-without-inheritance">5.1. Object Construction without Inheritance</h2>
<h2 id="object-construction-under-inheritance">5.2. Object Construction under Inheritance</h2>
<p>编译器扩充构造函数:</p>
<ol type="1">
<li>virtual base 构造函数</li>
<li>所有的 base 构造函数(按照声明顺序)</li>
<li>vptr</li>
<li>成员初始化列表, 未出现在初始化列表的 member 默认构造函数</li>
</ol>
<p>在自我拷贝时要注意判断筛选(释放资源前)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p>虚拟多继承中对于virtual base class 的构造函数调用(会被调用多次?) 可以被安排到 most_derived 的构造函数中</p>
<p>vptr 初始化位置在 base 构造函数之后, 初始化列表之前</p>
<p>在 class 的 constructor 的 member initialization list 中调用该 class 的一个虚拟函数，安全吗？就实际而言，将该函数运行于其 class's data member 的初始化行动中，总是安全的。vptr保证能够在 member initialization list 被扩展之前，由编译器正确设定好．但是在语意上这可能是不安全的，因为函数本身可能还得依 赖未被设立初值的 members.</p>
<h2 id="object-copy-semantics">5.3. Object Copy Semantics</h2>
<blockquote>
<p>关于几种拷贝</p>
<p><strong>Member-wise Copy</strong></p>
<p>Is when you visit each member and explicitly copy it, i<strong>nvoking its copy constructor</strong>. It is the proper way of copying things. If done right, it is tantamount to a deep-copy, because each member whose copy constructor you invoke will (or should) in turn perform member-wise copy of its own members, and so on. The opposite is bit-wise copy, which is a hack, see below.</p>
<p><strong>Bit-wise Copy</strong></p>
<p>Is a specific form of shallow copy. It is when you <strong>simply copy the bits of the source class to the target class, using <code>memcpy()</code></strong> or something similar. <strong>Constructors are not invoked</strong>, so you tend to get a class which <em>appears</em> to be all right but things start breaking in horrible ways as soon as you start using it. This is the opposite of member-wise copy, and is a quick and dirty hack that can sometimes be used when we know that there are no constructors to be invoked and no internal structures to be duplicated. For a discussion of what may go wrong with this, see this Q&amp;A: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15123516/c-bitwise-vs-memberwise-copying">C++ bitwise vs memberwise copying?</a></p>
<p><strong>Shallow Copy</strong></p>
<p><strong>Refers to copying just the immediate members of an object,</strong> without duplicating whatever structures are pointed by them. It is what you get when you do a bit-wise copy.</p>
<p>(Note that there is no such thing as "shadow copy". I mean, there is such a thing, in file systems, but that's probably <em>not</em> what you had in mind.)</p>
<p><strong>Deep Copy</strong></p>
<p>Refers to not only copying the immediate members of an object, but also duplicating whatever structures are pointed by them. It is what you normally get when you do member-wise copy.</p>
<p><strong>To summarize:</strong></p>
<p>There are two categories:</p>
<ul>
<li>Shallow Copy</li>
<li>Deep Copy</li>
</ul>
<p>Then, there are two widely used techniques:</p>
<ul>
<li>Bit-wise Copy (a form of Shallow Copy)</li>
<li>Member-wise Copy (a form of Deep Copy, if done right.)</li>
</ul>
<p>As for the hear-say about someone who said something and someone who said something else: bit-wise copy is definitely always shallow copy. Member-wise copy is usually deep copy, but you may of course foul it up, so you may be thinking that you are making a deep copy while in fact you are not. Proper member-wise copy relies on having proper copy constructors.</p>
<p>Finally:</p>
<p><strong>The default copy constructor will do a bit-wise copy if the object is known to be trivially copyable, or a member-wise copy if not.</strong> However, the compiler does not always have enough information to perform a proper copy of each member. For example, a pointer is copied by making a copy of the pointer, not by making a copy of the pointed object. That's why you should generally not rely on the compiler providing you with a default copy constructor when your object is not trivially copyable.</p>
<p>A user-supplied constructor may do whatever type of copy the user likes. Hopefully, the user will choose wisely and do a member-wise copy.</p>
</blockquote>
<p>只有当默认行为导致语义不安全是才需要设计一个拷贝运算符</p>
<p>默认拷贝运算符 在以下情况下不会表现出 bitwise copy 语义</p>
<ol type="1">
<li>member 有拷贝运算符</li>
<li>base 有拷贝运算符</li>
<li>有 虚函数</li>
<li>继承自 virtual base</li>
</ol>
<p>注意虚拟继承的拷贝运算符</p>
<h2 id="object-efficiency.">5.4. Object Efficiency.</h2>
<p>一些表格</p>
<h2 id="semantics-of-destruction">5.5. Semantics of Destruction</h2>
<p>如果 class 没有定义 destructor，那么只有在 class 内带的 member object （或 是 class 自己的 base class）拥有 destructor 的情况下，编译器才会自动合成出一 个来．否则，destructor 会被视为不需要，也就不需被合成（当然更不需要被调用）．</p>
<p>析构函数扩展顺序:(存疑)</p>
<ol type="1">
<li>析构函数体</li>
<li>member 析构函数, 声明逆序</li>
<li>有 vptr, 重设相关的 vtb</li>
<li>nonvirtual base, 声明逆序</li>
<li>virtual base</li>
</ol>
<h1 id="chapter-6.-runtime-semantics">Chapter 6. Runtime Semantics</h1>
<h2 id="object-construction-and-destruction">6.1. Object Construction and Destruction</h2>
<h3 id="global">global</h3>
<p>C++ 保证，一定会在 main 函数中第一次用到 identity 之前，把 identity 构造 出来，而在 main 函数结束之前把 identity 摧毁掉。像 identity 这样的所谓 global object 如果有 constructor 和 destructor 的话，我们说它需要静态的初始化 操作和内存释放操作。</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h82pmhob14j30pg0buab2.jpg" alt="截屏2022-11-12 22.24.49" /><figcaption aria-hidden="true">截屏2022-11-12 22.24.49</figcaption>
</figure>
<h3 id="local-static">local static</h3>
<p>编译器的策略之一就是，无条件地在程序起始（startup）时构造出对象来． 然而这会导致所有的 local static class obiects 都在程序起始时被初始化，即使它们 所在的那个函数从不曾被调用过。因此，只在 identity 被调用时才把 matidentity 构造起来，是比较好的做法（现在的 C++ Standard 已经强制要求这 一点）。</p>
<h3 id="array-of-object">array of object</h3>
<p>如果定义了构造函数, 会依次调用</p>
<p>析构函数同上</p>
<h2 id="operators-new-and-delete">6.2. Operators new and delete</h2>
<p>new 步骤</p>
<ol type="1">
<li>分配内存</li>
<li>设立初值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi;</span><br><span class="line"><span class="keyword">if</span>(pi = __new(<span class="built_in">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">	*pi = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>delete 步骤</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pi!=<span class="number">0</span>)</span><br><span class="line">  __delete(pi);</span><br><span class="line"><span class="comment">//此时 pi 不会被清零</span></span><br></pre></td></tr></table></figure>
<h2 id="temporary-objects">6.3. Temporary Objects</h2>
<p>临时性对象的被摧毁，应该是对完整表达式（full-expression）求值过程中的 最后一个步骤．该完整表达式造成临时对象的产生(Section 12.2).</p>
<p>⋯凡含有表达式执行结果的临时性对象，应该存留到 object 的初始化操作 完成为止。</p>
<p>如果一个临时性对象被绑定于一个 reference，对象将残留，直到被初始化之 reference 的生命结束，或直到临时对象的生命范時（scope)结束——视哪一种情 先到达而定.</p>
<h1 id="chapter-7.-on-the-cusp-of-the-object-model">Chapter 7. On the Cusp of the Object Model</h1>
<h2 id="templates">7.1. Templates</h2>
<p>?</p>
<h2 id="exception-handling">7.2. Exception Handling</h2>
<h2 id="runtime-type-identification">7.3. Runtime Type Identification</h2>
<h2 id="efficient-but-inflexible">7.4. Efficient, but Inflexible?</h2>
<h1 id="关于作用域">关于作用域</h1>
<h1 id="多继承">多继承</h1>
<h2 id="多个基类">多个基类</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员函数</span></span><br><span class="line">C* pc;</span><br><span class="line">pc-&gt;<span class="built_in">bf</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//需要变换 this 指针</span></span><br><span class="line"><span class="built_in">bf_F1B</span>( (B*) ( (<span class="type">char</span>*) pc + <span class="built_in">delta</span>(B) ), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同理类型转换</span></span><br><span class="line">C* pc;</span><br><span class="line">B* pb;</span><br><span class="line">pb = (B*)pc;</span><br><span class="line"><span class="comment">//变换</span></span><br><span class="line">pb = (B*) ( (<span class="type">char</span>*) pc + <span class="built_in">delta</span>(B));</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免 0 指针</span></span><br><span class="line">C* pc = <span class="number">0</span>;</span><br><span class="line">B* pb = <span class="number">0</span>;</span><br><span class="line">pb = pc;</span><br><span class="line">pb = (pc==<span class="number">0</span>)? <span class="number">0</span> : (B*) ( (<span class="type">char</span>*) pc + <span class="built_in">delta</span>(B));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//涉及到歧义时</span></span><br><span class="line">pc-&gt;A::<span class="built_in">f</span>();</span><br><span class="line">pc-&gt;B::<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure>
<h2 id="虚函数">虚函数</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vtbl_entry</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*fct)();</span><br><span class="line">	  <span class="type">int</span> delta;</span><br><span class="line">&#125;;</span><br><span class="line">-----------------</span><br><span class="line">|                | vtbl:</span><br><span class="line">| vptr ..........&gt;--------------------- </span><br><span class="line">| A part         | |C::f| <span class="number">0</span>           |</span><br><span class="line">|                | --------------------</span><br><span class="line">-----------------</span><br><span class="line">|                | vtbl:</span><br><span class="line">| vptr ..........&gt;--------------------- </span><br><span class="line">| B part         | |C::f| -<span class="built_in">delta</span>(B)   |</span><br><span class="line">|                | |B::g| <span class="number">0</span>           | </span><br><span class="line">----------------- --------------------- </span><br><span class="line">|                |</span><br><span class="line">| C part         | </span><br><span class="line">|                |</span><br><span class="line">-----------------</span><br><span class="line">  </span><br><span class="line">pb-&gt;<span class="built_in">f</span>();    </span><br><span class="line"><span class="comment">// call of C::f:</span></span><br><span class="line"><span class="comment">// register vtbl_entry* vt = &amp;pb-&gt;vtbl[index(f)];</span></span><br><span class="line"><span class="comment">// (*vt-&gt;fct) ( (B*) ( (char*)pb + vt-&gt;delta) )</span></span><br><span class="line"><span class="comment">// 这意味着每个基类都需要一个 vptr</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="multiple-inclusion">multiple inclusion</h2>
<p>下面这段代码是编译通过的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">L</span> &#123;<span class="keyword">public</span>: <span class="type">int</span> m; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> L &#123;<span class="keyword">public</span>:  <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : L &#123;<span class="keyword">public</span>:  <span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : A , B &#123;<span class="keyword">public</span>:  <span class="type">int</span> c; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    C* pc = &amp;c;</span><br><span class="line">    L* pl = (L*)(A*)pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚基类">虚基类</h2>
<p>In other words, there must be a way of specifying that a base class must give rise to <strong>only one object in the final derived class even if it is mentioned as a base class several times</strong>. To distinguish this usage from independent multiple inheritance such base classes are specified to be virtual:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">L</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>: <span class="type">int</span> m;</span><br><span class="line">    <span class="comment">//virtual void f()&#123;&#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> L &#123;<span class="keyword">public</span>:  <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : L &#123;<span class="keyword">public</span>:  <span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A , B &#123;<span class="keyword">public</span>:  <span class="type">int</span> c; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    C* pc = &amp;c;</span><br><span class="line">    A* pa = (A*)pc;</span><br><span class="line">    </span><br><span class="line">    C* pcc = <span class="built_in">static_cast</span>&lt;C*&gt;(pa);</span><br><span class="line">    <span class="comment">//如果有 virtual 用 dynamic_cast 和 static_cast 都行</span></span><br><span class="line">    <span class="comment">//没有 virtual 就只能 static_cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">.........  |</span><br><span class="line">. | AW part| g</span><br><span class="line">v |        |</span><br><span class="line">. ----------------- </span><br><span class="line">.........  |</span><br><span class="line">. | BW part| f</span><br><span class="line">v |        |</span><br><span class="line">. -----------------</span><br><span class="line">. |        |</span><br><span class="line">. | CW part| h</span><br><span class="line">v |        |        vtbl:</span><br><span class="line">. ----------------- ------------------------------</span><br><span class="line">.&gt;| vptr .........&gt; |BW::f | <span class="built_in">delta</span>(BW)-<span class="built_in">delta</span>(W) | </span><br><span class="line">  |        |        |AW::g | -<span class="built_in">delta</span>(W)          |</span><br><span class="line">  | W part | fghk   |CW::h | -<span class="built_in">delta</span>(W)          |</span><br><span class="line">  |        |        | W::k | <span class="number">0</span>                  |</span><br><span class="line">  ----------------- ------------------------------</span><br><span class="line"><span class="comment">//the delta stored with a function pointer in a vtbl is the delta of the class defining the function minus the delta of the class for which the vtbl is constructed.</span></span><br><span class="line">这个表似乎有点问题, delta 和 vptr 没弄明白</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">W</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AW</span> : <span class="keyword">virtual</span> W &#123; <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BW</span> : <span class="keyword">virtual</span> W &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CW</span> : AW , BW &#123; <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>; ... &#125;;</span><br><span class="line">CW* pcw = <span class="keyword">new</span> CW;</span><br><span class="line">pcw-&gt;<span class="built_in">f</span>();        <span class="comment">// BW::f()</span></span><br><span class="line">pcw-&gt;<span class="built_in">g</span>();        <span class="comment">// AW::g()</span></span><br><span class="line">pcw-&gt;<span class="built_in">h</span>();        <span class="comment">// CW::h()</span></span><br><span class="line">((AW*)pcw)-&gt;<span class="built_in">f</span>(); <span class="comment">// BW::f();</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数与析构函数">构造函数与析构函数</h2>
<p>Constructors are executed in the order they appear in the list of bases <strong>except that a virtual base is always constructed before classes derived from it.</strong> A virtual base is always constructed (once only) by its "most derived" class. For example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">V</span> &#123; <span class="built_in">V</span>(); <span class="built_in">V</span>(<span class="type">int</span>); ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">virtual</span> V &#123; <span class="built_in">A</span>(); <span class="built_in">A</span>(<span class="type">int</span>); ... &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> V &#123; <span class="built_in">B</span>(); <span class="built_in">B</span>(<span class="type">int</span>), ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : A, B     &#123; <span class="built_in">C</span>(); <span class="built_in">C</span>(<span class="type">int</span>), ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">v</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="function">B <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="function">C <span class="title">c</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="overhead">overhead</h2>
<p>The overhead in using this scheme is:</p>
<ol type="1">
<li><p>One subtraction of a constant for each use of a member in a base class that is included as the second</p>
<p>or subsequent base.</p></li>
<li><p>One word per function in each vtbl (to hold the delta).</p></li>
<li><p>One memory reference and one subtraction for each call of a virtual function.</p></li>
<li><p>One memory reference and one subtraction for access of a base class member of a virtual base class.</p></li>
</ol>
<p>Note that overheads [1] and [4] are only incurred where multiple inheritance is actually used, but overheads [2] and [3] are incurred for each class with virtual functions and for each virtual function call even when multiple inheritance is not used. Overheads [1] and [4] are only incurred when members of a second or subsequent base are accessed ‘‘from the outside’’; a member function of a virtual base class does not incur special overheads when accessing members of its class.</p>
<p>This implies that except for [2] and [3] you pay only for what you actually use; [2] and [3] impose a minor overhead on the virtual function mechanism even where only single inheritance is used. This latter overhead could be avoided by using an alternative implementation of multiple inheritance, but I don’t know of such an implementation that is also faster in the multiple inheritance case and as portable as the scheme described here.</p>
<p>Fortunately, these overheads are not significant. The time, space, and complexity overheads imposed on the compiler to implement multiple inheritance are not noticeable to the user.</p>
<h1 id="memory-layout">memory layout</h1>
<p>http://www.vishalchovatiya.com/memory-layout-of-cpp-object/</p>
<h2 id="object">object</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span>     x;</span><br><span class="line">    <span class="type">float</span>   xx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInt</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printFloat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      |------------------------| &lt;------ X class object memory layout</span><br><span class="line">      |        int X::x        |</span><br><span class="line">      |------------------------|  stack segment</span><br><span class="line">      |       float X::xx      |       |   </span><br><span class="line">      |------------------------|       |</span><br><span class="line">      |                        |      \|/</span><br><span class="line">      |                        |    </span><br><span class="line">      |                        |</span><br><span class="line">------|------------------------|----------------</span><br><span class="line">      |         X::X()         | </span><br><span class="line">      |------------------------|       |   </span><br><span class="line">      |        X::~X()         |       |</span><br><span class="line">      |------------------------|      \|/</span><br><span class="line">      |      X::printInt()     |  text segment</span><br><span class="line">      |------------------------|</span><br><span class="line">      |     X::printFloat()    |</span><br><span class="line">      |------------------------|</span><br><span class="line">      |                        |            </span><br></pre></td></tr></table></figure>
<h2 id="virtual-func-static-member">+virtual func + static member</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span>         x;</span><br><span class="line">    <span class="type">float</span>       xx;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>  count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInt</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printFloat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printCount</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      |------------------------| &lt;--- X class object memory layout</span><br><span class="line">      |        int X::x        |</span><br><span class="line">stack |------------------------|</span><br><span class="line">  |   |       float X::xx      |                      </span><br><span class="line">  |   |------------------------|      |---|--------------------------|</span><br><span class="line">  |   |         X::_vptr       |------|   |       type_info X        |</span><br><span class="line"> \|/  |------------------------|          |--------------------------|</span><br><span class="line">      |           o            |          |    address of X::~X()    |</span><br><span class="line">      |           o            |          |--------------------------|</span><br><span class="line">      |           o            |          | address of X::printAll() |</span><br><span class="line">      |                        |          |--------------------------|</span><br><span class="line">      |                        |</span><br><span class="line">------|------------------------|------------</span><br><span class="line">      |  static int X::count   |      /|\</span><br><span class="line">      |------------------------|       |</span><br><span class="line">      |           o            |  data segment           </span><br><span class="line">      |           o            |       |</span><br><span class="line">      |                        |      \|/</span><br><span class="line">------|------------------------|------------</span><br><span class="line">      |        X::X()          | </span><br><span class="line">      |------------------------|       |   </span><br><span class="line">      |        X::~X()         |       |</span><br><span class="line">      |------------------------|       | </span><br><span class="line">      |      X::printAll()     |      \|/ </span><br><span class="line">      |------------------------|  text segment</span><br><span class="line">      |      X::printInt()     |</span><br><span class="line">      |------------------------|</span><br><span class="line">      |     X::printFloat()    |</span><br><span class="line">      |------------------------|</span><br><span class="line">      | static X::printCount() |</span><br><span class="line">      |------------------------|</span><br><span class="line">      |                        |</span><br></pre></td></tr></table></figure>
<h2 id="inheritance">+inheritance</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span>     x;</span><br><span class="line">    string str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> : <span class="keyword">public</span> X &#123;</span><br><span class="line">    <span class="type">int</span>     y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Y</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Y</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      |------------------------------| &lt;---- Y class object memory layout</span><br><span class="line">      |          int X::x            |</span><br><span class="line">stack |------------------------------|</span><br><span class="line">  |   |              int string::len |</span><br><span class="line">  |   |string X::str ----------------|</span><br><span class="line">  |   |            char* string::str |         </span><br><span class="line"> \|/  |------------------------------|      |--|--------------------------|</span><br><span class="line">      |           X::_vptr           |------|  |       type_info Y        |</span><br><span class="line">      |------------------------------|         |--------------------------|</span><br><span class="line">      |          int Y::y            |         |    address of Y::~Y()    |</span><br><span class="line">      |------------------------------|         |--------------------------|</span><br><span class="line">      |               o              |         | address of Y::printAll() |</span><br><span class="line">      |               o              |         |--------------------------|</span><br><span class="line">      |               o              |              </span><br><span class="line">------|------------------------------|--------</span><br><span class="line">      |           X::X()             | </span><br><span class="line">      |------------------------------|       |   </span><br><span class="line">      |           X::~X()            |       |</span><br><span class="line">      |------------------------------|       | </span><br><span class="line">      |         X::printAll()        |      \|/ </span><br><span class="line">      |------------------------------|  text segment</span><br><span class="line">      |           Y::Y()             |</span><br><span class="line">      |------------------------------|</span><br><span class="line">      |           Y::~Y()            |</span><br><span class="line">      |------------------------------|</span><br><span class="line">      |         Y::printAll()        |</span><br><span class="line">      |------------------------------|</span><br><span class="line">      |      string::string()        |</span><br><span class="line">      |------------------------------|</span><br><span class="line">      |      string::~string()       |</span><br><span class="line">      |------------------------------|</span><br><span class="line">      |      string::length()        |</span><br><span class="line">      |------------------------------|</span><br><span class="line">      |                              |</span><br></pre></td></tr></table></figure>
<h2 id="multiple-inheritance">+ multiple inheritance</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>     x;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>     y;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Y</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printY</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> : <span class="keyword">public</span> X, <span class="keyword">public</span> Y &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>     z;</span><br><span class="line">    ~<span class="built_in">Z</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printY</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printZ</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      |------------------------------| &lt;----- Z class object memory layout</span><br><span class="line">stack |          int X::x            |         </span><br><span class="line">  |   |------------------------------|           |--------------------------|      </span><br><span class="line">  |   |          X:: _vptr           |----------&gt;|       type_info Z        |</span><br><span class="line">  |   |------------------------------|           |--------------------------|</span><br><span class="line"> \|/  |          int Y::y            |           |    address of Z::~Z()    |</span><br><span class="line">      |------------------------------|           |--------------------------|</span><br><span class="line">      |          Y:: _vptr           |------|    |   address of Z::printX() |</span><br><span class="line">      |------------------------------|      |    |--------------------------|</span><br><span class="line">      |          int Z::z            |      |    |--------GUARD_AREA--------|    </span><br><span class="line">      |------------------------------|      |    |--------------------------|</span><br><span class="line">      |              o               |      |---&gt;|       type_info Z        |</span><br><span class="line">      |              o               |           |--------------------------|</span><br><span class="line">      |              o               |           |    address of Z::~Z()    |</span><br><span class="line">      |                              |           |--------------------------|</span><br><span class="line">------|------------------------------|---------  |   address of Z::printY() |</span><br><span class="line">      |           X::~X()            |       |   |--------------------------|  </span><br><span class="line">      |------------------------------|       |          </span><br><span class="line">      |          X::printX()         |       |        </span><br><span class="line">      |------------------------------|       |         </span><br><span class="line">      |           Y::~Y()            |      \|/        </span><br><span class="line">      |------------------------------|  text segment</span><br><span class="line">      |          Y::printY()         |                </span><br><span class="line">      |------------------------------|                </span><br><span class="line">      |           Z::~Z()            |                </span><br><span class="line">      |------------------------------|                </span><br><span class="line">      |          Z::printX()         |                </span><br><span class="line">      |------------------------------|                </span><br><span class="line">      |          Z::printY()         |                </span><br><span class="line">      |------------------------------|                </span><br><span class="line">      |          Z::printZ()         |                </span><br><span class="line">      |------------------------------|                </span><br><span class="line">      |                              |                           </span><br></pre></td></tr></table></figure>
<h2 id="virtual-inheritance">+ virtual inheritance</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; <span class="type">int</span> y; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; <span class="type">int</span> z; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123; <span class="type">int</span> a; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  |                |          </span><br><span class="line"> Y class  ------&gt; |----------------| &lt;--- A class object memory layout</span><br><span class="line">sub-object        |   Y::y         |          </span><br><span class="line">                  |----------------|       |--------------------------| </span><br><span class="line">                  |   Y::_vptr_Y   |--|    |    offset of X           | </span><br><span class="line"> Z class  ------&gt; |----------------|  |--&gt; |--------------------------|     </span><br><span class="line">sub-object        |   Z::z         |       |//offset(20) starts from Y|     </span><br><span class="line">                  |----------------|       |--------------------------|  </span><br><span class="line">                  |   Z::_vptr_Z   |--|       </span><br><span class="line">                  |----------------|  |        </span><br><span class="line"> A sub-object --&gt; |   A::a         |  |    |--------------------------| </span><br><span class="line">                  |----------------|  |    |    offset of X           | </span><br><span class="line"> X class -------&gt; |   X::x         |  |--&gt; |--------------------------|          </span><br><span class="line"> shared           |----------------|       |//offset(12) starts from Z|           </span><br><span class="line"> sub-object       |                |       |--------------------------|           </span><br></pre></td></tr></table></figure>
<h1 id="gcc-virtual-table">GCC virtual table</h1>
<h2 id="vtable-notes-on-multiple-inheritance-in-gcc-c-compiler-v4.0.1">VTable Notes on Multiple Inheritance in GCC C++ Compiler v4.0.1</h2>
<p>[http://www.cse.wustl.edu/~mdeters/seminar/fall2005/mi.html#basics] The Basics: Single Inheritance</p>
<h2 id="simple-multiple-inheritance">Simple Multiple Inheritance</h2>
<p>Now consider multiple inheritance:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">  int a;</span><br><span class="line">  virtual void v();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">  int b;</span><br><span class="line">  virtual void w();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A, public B &#123;</span><br><span class="line">public:</span><br><span class="line">  int c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>In this case, objects of type C are laid out like this:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           +-----------------------+</span><br><span class="line">                           |     0 (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">c --&gt; +----------+         | ptr to typeinfo for C |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+         |    -8 (top_offset)    |</span><br><span class="line">      |  vtable  |---+     +-----------------------+</span><br><span class="line">      +----------+   |     | ptr to typeinfo for C |</span><br><span class="line">      |     b    |   +---&gt; +-----------------------+</span><br><span class="line">      +----------+         |         B::w()        |</span><br><span class="line">      |     c    |         +-----------------------+</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p><em>...but why?</em> Why two vtables in one? Well, think about typesubstitution. If I have a pointer-to-C, I can pass it to a functionthat expects a pointer-to-A or to a function that expects apointer-to-B. If a function expects a pointer-to-A and I want to passit the value of my variable <code>c</code> (of type pointer-to-C), I'malready set. Calls to <code>A::v()</code> can be made through the(first) vtable, and the called function can access the member<code>a</code> through the pointer I pass in the same way as it canthrough <em>any</em> pointer-to-A.</p>
<p>However, if I pass the value of my pointer variable <code>c</code> to a function that expects a pointer-to-B, we <em>also</em> need asubobject of type B in our C to refer it to. This is why we have thesecond vtable pointer. We can pass the pointer value<code>(c + 8 bytes)</code> to the function that expectsa pointer-to-B, and it's all set: it can make calls to<code>B::w()</code> through the (second) vtable pointer, and accessthe member <code>b</code> through the pointer we pass in the same wayas it can through any pointer-to-B.</p>
<p>Note that this "pointer-correction" needs to occur for called methodstoo. Class C inherits <code>B::w()</code> in this case. When<code>w()</code> is called on through a pointer-to-C, the pointer(which becomes the <strong>this</strong> pointer inside of <code>w()</code> needsto be adjusted. This is often called <em>this pointer adjustment</em>.</p>
<p>In some cases, the compiler will generate a <em>thunk</em> to fix up theaddress. Consider the same code as above but this time C overrides B'smember function <code>w()</code>:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">  int a;</span><br><span class="line">  virtual void v();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">  int b;</span><br><span class="line">  virtual void w();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A, public B &#123;</span><br><span class="line">public:</span><br><span class="line">  int c;</span><br><span class="line">  void w();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>C's object layout and vtable now look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           +-----------------------+</span><br><span class="line">                           |     0 (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">c --&gt; +----------+         | ptr to typeinfo for C |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+         |         C::w()        |</span><br><span class="line">      |  vtable  |---+     +-----------------------+</span><br><span class="line">      +----------+   |     |    -8 (top_offset)    |</span><br><span class="line">      |     b    |   |     +-----------------------+</span><br><span class="line">      +----------+   |     | ptr to typeinfo for C |</span><br><span class="line">      |     c    |   +---&gt; +-----------------------+</span><br><span class="line">      +----------+         |    thunk to C::w()    |</span><br><span class="line">                           +-----------------------+</span><br></pre></td></tr></table></figure>
<p>Now, when <code>w()</code> is called on an instance of C through apointer-to-B, the thunk is called. What does the thunk do? Let'sdisassemble it (here, with gdb):</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0804860c &lt;_ZThn8_N1C1wEv+0&gt;:  addl   $0xfffffff8,0x4(%esp)</span><br><span class="line">0x08048611 &lt;_ZThn8_N1C1wEv+5&gt;:  jmp    0x804853c &lt;_ZN1C1wEv&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>So it merely adjusts the <strong>this</strong> pointer and jumps to<code>C::w()</code>. All is well.</p>
<p>But doesn't the above mean that B's vtable always points to this<code>C::w()</code> thunk? I mean, if we have a pointer-to-B that is legitimately a B (not a C), we don't want to invoke the thunk, right?</p>
<h2 id="attention"><strong>attention!!!!</strong></h2>
<p><u><strong>Right. The above embedded vtable for B in C is special to the B-in-C case.B's regular vtable is normal and points to <code>B::w()</code> directly.</strong></u></p>
<p>The Diamond: Multiple Copies of Base Classes (non-virtual inheritance)</p>
<p>Okay. Now to tackle the really hard stuff. Recall the usual problem ofmultiple copies of base classes when forming an inheritance diamond:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">  int a;</span><br><span class="line">  virtual void v();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public A &#123;</span><br><span class="line">public:</span><br><span class="line">  int b;</span><br><span class="line">  virtual void w();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A &#123;</span><br><span class="line">public:</span><br><span class="line">  int c;</span><br><span class="line">  virtual void x();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D : public B, public C &#123;</span><br><span class="line">public:</span><br><span class="line">  int d;</span><br><span class="line">  virtual void y();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Note that D inherits from both B and C, and B and C both inherit from A.This means that D has <em>two</em> copies of A in it. The object layoutand vtable embedding is what we would expect from the previous sections:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           +-----------------------+</span><br><span class="line">                           |     0 (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">d --&gt; +----------+         | ptr to typeinfo for D |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+         |         B::w()        |</span><br><span class="line">      |     b    |         +-----------------------+</span><br><span class="line">      +----------+         |         D::y()        |</span><br><span class="line">      |  vtable  |---+     +-----------------------+</span><br><span class="line">      +----------+   |     |   -12 (top_offset)    |</span><br><span class="line">      |     a    |   |     +-----------------------+</span><br><span class="line">      +----------+   |     | ptr to typeinfo for D |</span><br><span class="line">      |     c    |   +---&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     d    |         +-----------------------+</span><br><span class="line">      +----------+         |         C::x()        |</span><br><span class="line">                           +-----------------------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Of course, we expect A's data (the member <code>a</code>) to exist twicein D's object layout (and it is), and we expect A's virtual member functionsto be represented twice in the vtable (and <code>A::v()</code> is indeedthere). Okay, nothing new here.</p>
<p>The Diamond: Single Copies of Virtual Bases</p>
<p>But what if we apply <em>virtual</em> inheritance? C++ virtual inheritanceallows us to specify a diamond hierarchy but be guaranteed only one copyof virtually inherited bases. So let's write our code this way:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">  int a;</span><br><span class="line">  virtual void v();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public virtual A &#123;</span><br><span class="line">public:</span><br><span class="line">  int b;</span><br><span class="line">  virtual void w();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public virtual A &#123;</span><br><span class="line">public:</span><br><span class="line">  int c;</span><br><span class="line">  virtual void x();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D : public B, public C &#123;</span><br><span class="line">public:</span><br><span class="line">  int d;</span><br><span class="line">  virtual void y();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>All of a sudde 1000 n things get a <em>lot</em> more complicated. If we can onlyhave <em>one</em> copy of A in our representation of D, then we can nolonger get away with our "trick" of embedding a C in a D (and embeddinga vtable for the C part of D in D's vtable). But how can we handle theusual type substitution if we can't do this?</p>
<p>Let's try to diagram the layout:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |   20 (vbase_offset)   |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |     0 (top_offset)    |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   | ptr to typeinfo for D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">d --&gt; +----------+    |            |         B::w()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+                 |         D::y()        |</span><br><span class="line">      |     b    |                 +-----------------------+</span><br><span class="line">      +----------+                 |   12 (vbase_offset)   |</span><br><span class="line">      |  vtable  |---------+       +-----------------------+</span><br><span class="line">      +----------+         |       |    -8 (top_offset)    |</span><br><span class="line">      |     c    |         |       +-----------------------+</span><br><span class="line">      +----------+         |       | ptr to typeinfo for D |</span><br><span class="line">      |     d    |         +-----&gt; +-----------------------+</span><br><span class="line">      +----------+                 |         C::x()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+    |            |    0 (vbase_offset)   |</span><br><span class="line">      |     a    |    |            +-----------------------+</span><br><span class="line">      +----------+    |            |   -20 (top_offset)    |</span><br><span class="line">                      |            +-----------------------+</span><br><span class="line">                      |            | ptr to typeinfo for D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">                                   |         A::v()        |</span><br><span class="line">                                   +-----------------------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Okay. So you see that A is now embedded in D in essentially thesame way that other bases are. But it's embedded in D rather than inits directly-derived classes.</p>
<p>Construction/Destruction in the Presence of Multiple Inheritance</p>
<p>How is the above object constructed in memory when the object itself isconstructed? And how do we ensure that a partially-constructed object(and its vtable) are safe for constructors to operate on?</p>
<p>Fortunately, it's all handled very carefully for us. Say we're constructinga new object of type D (through, for example, <code>new D</code>).First, the memory for the object is allocated in the heap and a pointerreturned. D's constructor is invoked, but before doing any D-specificconstruction it call's A's constructor on the object (after adjusting the<strong>this</strong> pointer, of course!). A's constructor fills in the A partof the D object as if it were an instance of A.</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d --&gt; +----------+</span><br><span class="line">      |          |</span><br><span class="line">      +----------+</span><br><span class="line">      |          |</span><br><span class="line">      +----------+</span><br><span class="line">      |          |</span><br><span class="line">      +----------+</span><br><span class="line">      |          |       +-----------------------+</span><br><span class="line">      +----------+       |     0 (top_offset)    |</span><br><span class="line">      |          |       +-----------------------+</span><br><span class="line">      +----------+       | ptr to typeinfo for A |</span><br><span class="line">      |  vtable  |-----&gt; +-----------------------+</span><br><span class="line">      +----------+       |         A::v()        |</span><br><span class="line">      |    a     |       +-----------------------+</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Control is returned to D's constructor, which invokes B's constructor.(Pointer adjustment isn't needed here.) When B's constructor is done,the object looks like this:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                             B-in-D</span><br><span class="line">                          +-----------------------+</span><br><span class="line">              </span><br><span class="line">1000</span><br><span class="line">            |   20 (vbase_offset)   |</span><br><span class="line">                          +-----------------------+</span><br><span class="line">                          |     0 (top_offset)    |</span><br><span class="line">                          +-----------------------+</span><br><span class="line">d --&gt; +----------+        | ptr to typeinfo for B |</span><br><span class="line">      |  vtable  |------&gt; +-----------------------+</span><br><span class="line">      +----------+        |         B::w()        |</span><br><span class="line">      |    b     |        +-----------------------+</span><br><span class="line">      +----------+        |    0 (vbase_offset)   |</span><br><span class="line">      |          |        +-----------------------+</span><br><span class="line">      +----------+        |   -20 (top_offset)    |</span><br><span class="line">      |          |        +-----------------------+</span><br><span class="line">      +----------+        | ptr to typeinfo for B |</span><br><span class="line">      |          |   +--&gt; +-----------------------+</span><br><span class="line">      +----------+   |    |         A::v()        |</span><br><span class="line">      |  vtable  |---+    +-----------------------+</span><br><span class="line">      +----------+</span><br><span class="line">      |    a     |</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p><em>But wait... B's constructor modified the A part of the object by changingit's vtable pointer!</em> How did it know to distinguish this kind of B-in-Dfrom a B-in-something-else (or a standalone B for that matter)? Simple.The <em>virtual table table</em> told it to do this. This structure,abbreviated VTT, is a table of vtables used in construction. In our case,the VTT for D looks like this:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                                                  B-in-D</span><br><span class="line">                                               +-----------------------+</span><br><span class="line">                                               |   20 (vbase_offset)   |</span><br><span class="line">            VTT for D                          +-----------------------+</span><br><span class="line">+-------------------+                          |     0 (top_offset)    |</span><br><span class="line">|    vtable for D   |-------------+            +-----------------------+</span><br><span class="line">+-------------------+             |            | ptr to typeinfo for B |</span><br><span class="line">| vtable for B-in-D |-------------|----------&gt; +-----------------------+</span><br><span class="line">+-------------------+             |            |         B::w()        |</span><br><span class="line">| vtable for B-in-D |-------------|--------+   +-----------------------+</span><br><span class="line">+-------------------+             |        |   |    0 (vbase_offset)   |</span><br><span class="line">| vtable for C-in-D |-------------|-----+  |   +-----------------------+</span><br><span class="line">+-------------------+             |     |  |   |   -20 (top_offset)    |</span><br><span class="line">| vtable for C-in-D |-------------|--+  |  |   +-----------------------+</span><br><span class="line">+-------------------+             |  |  |  |   | ptr to typeinfo for B |</span><br><span class="line">|    vtable for D   |----------+  |  |  |  +-&gt; +-----------------------+</span><br><span class="line">+-------------------+          |  |  |  |      |         A::v()        |</span><br><span class="line">|    vtable for D   |-------+  |  |  |  |      +-----------------------+</span><br><span class="line">+-------------------+       |  |  |  |  |</span><br><span class="line">                            |  |  |  |  |                         C-in-D</span><br><span class="line">                            |  |  |  |  |      +-----------------------+</span><br><span class="line">                            |  |  |  |  |      |   12 (vbase_offset)   |</span><br><span class="line">                            |  |  |  |  |      +-----------------------+</span><br><span class="line">                            |  |  |  |  |      |     0 (top_offset)    |</span><br><span class="line">                            |  |  |  |  |      +-----------------------+</span><br><span class="line">                            |  |  |  |  |      | ptr to typeinfo for C |</span><br><span class="line">                            |  |  |  |  +----&gt; +-----------------------+</span><br><span class="line">                            |  |  |  |         |         C::x()        |</span><br><span class="line">                            |  |  |  |         +-----------------------+</span><br><span class="line">                            |  |  |  |         |    0 (vbase_offset)   |</span><br><span class="line">                            |  |  |  |         +-----------------------+</span><br><span class="line">                            |  |  |  |         |   -12 (top_offset)    |</span><br><span class="line">                            |  |  |  |         +-----------------------+</span><br><span class="line">                            |  |  |  |         | ptr to typeinfo for C |</span><br><span class="line">                            |  |  |  +--</span><br><span class="line">1000</span><br><span class="line">-----&gt; +-----------------------+</span><br><span class="line">                            |  |  |            |         A::v()        |</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |</span><br><span class="line">                            |  |  |                                    D</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |            |   20 (vbase_offset)   |</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |            |     0 (top_offset)    |</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |            | ptr to typeinfo for D |</span><br><span class="line">                            |  |  +----------&gt; +-----------------------+</span><br><span class="line">                            |  |               |         B::w()        |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               |         D::y()        |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               |   12 (vbase_offset)   |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               |    -8 (top_offset)    |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               | ptr to typeinfo for D |</span><br><span class="line">                            +----------------&gt; +-----------------------+</span><br><span class="line">                               |               |         C::x()        |</span><br><span class="line">                               |               +-----------------------+</span><br><span class="line">                               |               |    0 (vbase_offset)   |</span><br><span class="line">                               |               +-----------------------+</span><br><span class="line">                               |               |   -20 (top_offset)    |</span><br><span class="line">                               |               +-----------------------+</span><br><span class="line">                               |               | ptr to typeinfo for D |</span><br><span class="line">                               +-------------&gt; +-----------------------+</span><br><span class="line">                                               |         A::v()        |</span><br><span class="line">                                               +-----------------------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p>D's constructor passes a pointer into D's VTT to B's constructor (in thiscase, it passes in the address of the first B-in-D entry). And, indeed,the vtable that was used for the object layout above is a special vtableused just for the construction of B-in-D.</p>
<p>Control is returned to the D constructor, and it calls the C constructor(with a VTT address parameter pointing to the "C-in-D+12" entry). WhenC's constructor is done with the object it looks like this:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                                                           B-in-D</span><br><span class="line">                                                        +-----------------------+</span><br><span class="line">                                                        |   20 (vbase_offset)   |</span><br><span class="line">                                                        +-----------------------+</span><br><span class="line">                                                        |     0 (top_offset)    |</span><br><span class="line">                                                        +-----------------------+</span><br><span class="line">                                                        | ptr to typeinfo for B |</span><br><span class="line">                    +---------------------------------&gt; +-----------------------+</span><br><span class="line">                    |                                   |         B::w()        |</span><br><span class="line">                    |                                   +-----------------------+</span><br><span class="line">                    |                          C-in-D   |    0 (vbase_offset)   |</span><br><span class="line">                    |       +-----------------------+   +-----------------------+</span><br><span class="line">d --&gt; +----------+  |       |   12 (vbase_offset)   |   |   -20 (top_offset)    |</span><br><span class="line">      |  vtable  |</span><br><span class="line">1000</span><br><span class="line">--+       +-----------------------+   +-----------------------+</span><br><span class="line">      +----------+          |     0 (top_offset)    |   | ptr to typeinfo for B |</span><br><span class="line">      |    b     |          +-----------------------+   +-----------------------+</span><br><span class="line">      +----------+          | ptr to typeinfo for C |   |         A::v()        |</span><br><span class="line">      |  vtable  |--------&gt; +-----------------------+   +-----------------------+</span><br><span class="line">      +----------+          |         C::x()        |</span><br><span class="line">      |    c     |          +-----------------------+</span><br><span class="line">      +----------+          |    0 (vbase_offset)   |</span><br><span class="line">      |          |          +-----------------------+</span><br><span class="line">      +----------+          |   -12 (top_offset)    |</span><br><span class="line">      |  vtable  |--+       +-----------------------+</span><br><span class="line">      +----------+  |       | ptr to typeinfo for C |</span><br><span class="line">      |    a     |  +-----&gt; +-----------------------+</span><br><span class="line">      +----------+          |         A::v()        |</span><br><span class="line">                            +-----------------------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p>As you see, C's constructor again modified the embedded A's vtable pointer.The embedded C and A objects are now using the special construction C-in-Dvtable, and the embedded B object is using the special construction B-in-Dvtable. Finally, D's constructor finishes the job and we end up with thesame diagram as before:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |   20 (vbase_offset)   |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |     0 (top_offset)    |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   | ptr to typeinfo for D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">d --&gt; +----------+    |            |         B::w()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+                 |         D::y()        |</span><br><span class="line">      |     b    |                 +-----------------------+</span><br><span class="line">      +----------+                 |   12 (vbase_offset)   |</span><br><span class="line">      |  vtable  |---------+       +-----------------------+</span><br><span class="line">      +----------+         |       |    -8 (top_offset)    |</span><br><span class="line">      |     c    |         |       +-----------------------+</span><br><span class="line">      +----------+         |       | ptr to typeinfo for D |</span><br><span class="line">      |     d    |         +-----&gt; +-----------------------+</span><br><span class="line">      +----------+                 |         C::x()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+    |            |    0 (vbase_offset)   |</span><br><span class="line">      |     a    |    |            +-----------------------+</span><br><span class="line">      +----------+    |            |   -20 (top_offset)    |</span><br><span class="line">                      |            +-----------------------+</span><br><span class="line">                      |            | ptr to typeinfo for D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">                                   |         A::v()        |</span><br><span class="line">                                   +-----------------------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Destruction occurs in the same fashion but in reverse. D's destructoris invoked. After the user's destruction code runs, the destructorcalls C's destructor and directs it to use the relevant portion of D'sVTT. C's destructor manipulates the vtable pointers in the same wayit did during construction; that is, the relevant vtable pointers nowpoint into the C-in-D construction vtable. Then it runs the user'sdestruction code for C and returns control to D's destructor, whichnext invokes B's destructor with a reference into D's VTT. B'sdestructor sets up the relevant portions of the object to refer intothe B-in-D construction vtable. It runs the user's destruction codefor B and returns control to D's destructor, which finally invokes A'sdestructor. A's destructor changes the vtable for the A portion ofthe object to refer into the vtable for A. Finally, control returnsto D's destructor and d 1000 estruction of the object is complete. Thememory once used by the object is returned to the system.</p>
<p>Now, in fact, the story is somewhat more complicated. Have you everseen those "in-charge" and "not-in-charge" constructor and destructorspecifications in GCC-produced warning and error messages or inGCC-produced binaries? Well, the fact is that there can be twoconstructor implementations and up to three destructor implementations.</p>
<p>An "in-charge" (or <em>complete object</em>) constructor is one thatconstructs virtual bases, and a "not-in-charge" (or <em>baseobject</em>) constructor is one that does not. Consider our aboveexample. If a B is constructed, its constructor needs to call A'sconstructor to construct it. Similarly, C's constructor needs toconstruct A. However, if B and C are constructed as part of aconstruction of a D, their constructors <em>should not</em> constructA, because A is a virtual base and D's constructor will take care ofconstructing it exactly once for the instance of D. Consider thecases:</p>
<ul>
<li>If you do a <code>new A</code>, A's "in-charge" constructor isinvoked to construct A.</li>
<li>When you do a <code>new B</code>, B's "in-charge" constructor isinvoked. It will call the "not-in-charge" constructor for A.</li>
<li><code>new C</code> is similar to <code>new B</code>.</li>
<li>A <code>new D</code> invokes D's "in-charge" constructor. Wewalked through this example. D's "in-charge" constructor calls the"not-in-charge" versions of A's, B's, and C's constructors (in thatorder).</li>
</ul>
<p>An "in-charge" destructor is the analogue of an "in-charge"constructor---it takes charge of destructing virtual bases. Similarly,a "not-in-charge" destructor is generated. But there's a third one aswell. An "in-charge deleting" destructor is one that <em>deallocates</em>the storage as well as destructing the object. So when is one called in preferenceto the other?</p>
<p>Well, there are two kinds of objects that can be destructed---those allocated on thestack, and those allocated in the heap. Consider this code (given our diamond hierarchywith virtual-inheritance from before):</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D d;            // allocates a D on the stack and constructs it</span><br><span class="line">D *pd = new D;  // allocates a D in the heap and constructs it</span><br><span class="line">/* ... */</span><br><span class="line">delete pd;      // calls &quot;in-charge deleting&quot; destructor for D</span><br><span class="line">return;         // calls &quot;in-charge&quot; destructor for stack-allocated D</span><br></pre></td></tr></table></figure>
</blockquote>
<p>We see that the actual delete operator isn't invoked by the code doingthe delete, but rather by the in-charge deleting destructor for theobject being deleted. Why do it this way? Why not have the callercall the in-charge destructor, then delete the object? Then you'd haveonly two copies of destructor implementations instead of three...</p>
<p>Well, the compiler <em>could</em> do such a thing, but it would be morecomplicated for other reasons. Consider this code (assuming a virtual destructor,which you always use, right?...<em>right?!?</em>):</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D *pd = new D;  // allocates a D in the heap and constructs it</span><br><span class="line">C *pc = d;      // we have a pointer-to-C that points to our heap-allocated D</span><br><span class="line">/* ... */</span><br><span class="line">delete pc;      // call destructor thunk through vtable, but what about delete?</span><br></pre></td></tr></table></figure>
</blockquote>
<p>If you didn't have an "in-charge deleting" variety of D's destructor, thenthe delete operation would need to adjust the pointer just like the destructorthunk does. Remember, the C object is embedded in a D, and so ourpointer-to-C above is adjusted to point into the middle of our D object.We can't just delete this pointer, since it isn't the pointer that wasreturned by <code>malloc()</code> when we constructed it.</p>
<p>So, if we didn't have an in-charge deleting destructor, we'd have to havethunks to the delete operator (and represent them in our vtables), or somethingelse similar.</p>
<p>Thunks, Virtual and Non-Virtual</p>
<p>This section not written yet.</p>
<p>Multiple Inheritance with Virtua 1000 l Methods on One Side</p>
<p>Okay. One last exercise. What if we have a diamond inheritance hierarchywith virtual inheritance, as before, but only have virtual methods along oneside of it? So:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">  int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public virtual A &#123;</span><br><span class="line">public:</span><br><span class="line">  int b;</span><br><span class="line">  virtual void w();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public virtual A &#123;</span><br><span class="line">public:</span><br><span class="line">  int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D : public B, public C &#123;</span><br><span class="line">public:</span><br><span class="line">  int d;</span><br><span class="line">  virtual void y();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>In this case the object layout is the following:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |   20 (vbase_offset)   |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |     0 (top_offset)    |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   | ptr to typeinfo for D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">d --&gt; +----------+    |            |         B::w()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+                 |         D::y()        |</span><br><span class="line">      |     b    |                 +-----------------------+</span><br><span class="line">      +----------+                 |   12 (vbase_offset)   |</span><br><span class="line">      |  vtable  |---------+       +-----------------------+</span><br><span class="line">      +----------+         |       |    -8 (top_offset)    |</span><br><span class="line">      |     c    |         |       +-----------------------+</span><br><span class="line">      +----------+         |       | ptr to typeinfo for D |</span><br><span class="line">      |     d    |         +-----&gt; +-----------------------+</span><br><span class="line">      +----------+</span><br><span class="line">      |     a    |</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2022/11/6d8f378b26de.html">https://sinos_wei.gitee.io/2022/11/6d8f378b26de.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/class/">class</a><a class="post-meta__tags" href="/tags/virtual/">virtual</a><a class="post-meta__tags" href="/tags/vtable/">vtable</a><a class="post-meta__tags" href="/tags/offset/">offset</a><a class="post-meta__tags" href="/tags/member/">member</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/IMG_2408.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/a58f730a2a3b.html" title="headfirst面向对象读书笔记"><img class="cover" src="/img/cover/IMG_6287.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">headfirst面向对象读书笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/c6d69f846995.html" title="mysql必知必会读书笔记"><img class="cover" src="/img/cover/IMG_2363.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">mysql必知必会读书笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/02/5e52a7d197f6.html" title="游戏编程模式读书笔记"><img class="cover" src="/img/cover/IMG_6287.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">游戏编程模式读书笔记</div></div></a></div><div><a href="/2020/01/c283701d8e64.html" title="java"><img class="cover" src="/img/cover/IMG_3033.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-25</div><div class="title">java</div></div></a></div><div><a href="/2022/09/84cc1427d0ce.html" title="effective_cpp读书笔记"><img class="cover" src="/img/cover/IMG_1404.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-24</div><div class="title">effective_cpp读书笔记</div></div></a></div><div><a href="/2022/11/c7cdc8607a22.html" title="设计模式读书笔记"><img class="cover" src="/img/cover/IMG_2232.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-19</div><div class="title">设计模式读书笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cover/IMG_2242.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://8.130.42.149:5230" target="_blank" title="memo"><i class="fab fa-heart"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-1.-object-lessons"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1. Object Lessons</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#layout-costs-for-adding-encapsulation"><span class="toc-number">1.1.</span> <span class="toc-text">Layout Costs for Adding Encapsulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-c-object-model"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 The C++ Object Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-keyword-distinction"><span class="toc-number">1.3.</span> <span class="toc-text">1.2. A Keyword Distinction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#an-object-distinction"><span class="toc-number">1.4.</span> <span class="toc-text">1.3. An Object Distinction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static_cast"><span class="toc-number">1.4.1.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic_cast"><span class="toc-number">1.4.2.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#regular-cast"><span class="toc-number">1.4.3.</span> <span class="toc-text">Regular Cast</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-2.-the-semantics-of-constructors"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2. The Semantics of Constructors</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#default-constructor-construction"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. Default Constructor Construction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">2.1.1.</span> <span class="toc-text">含有有默认构造函数的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">关于初始化顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">基类有默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">类中有虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">2.1.4.</span> <span class="toc-text">有虚基类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-constructor-construction"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. Copy Constructor Construction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#default-memberwise-initialization"><span class="toc-number">2.2.1.</span> <span class="toc-text">default memberwise initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitwise-copy-semantics"><span class="toc-number">2.2.2.</span> <span class="toc-text">bitwise copy semantics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E7%BD%AE-vptr"><span class="toc-number">2.2.3.</span> <span class="toc-text">有虚函数的重置 vptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%9F%BA%E7%B1%BB-subobject"><span class="toc-number">2.2.4.</span> <span class="toc-text">关于虚基类 subobject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#program-transformation-semantics"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. Program Transformation Semantics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#member-initialization-list"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. Member Initialization List</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-3.-the-semantics-of-data"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3. The Semantics of Data</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#the-binding-of-a-data-member"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. The Binding of a Data Member</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data-member-layout"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. Data Member Layout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#access-of-a-data-member"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. Access of a Data Member</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-member"><span class="toc-number">3.3.1.</span> <span class="toc-text">static member</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nonstatic-member"><span class="toc-number">3.3.2.</span> <span class="toc-text">nonstatic member</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inheritance-and-the-data-member"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. Inheritance and the Data Member</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.1.</span> <span class="toc-text">虚继承的菱形继承问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-member-efficiency"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. Object Member Efficiency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pointer-to-data-members"><span class="toc-number">3.6.</span> <span class="toc-text">3.6. Pointer to Data Members</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-4.-the-semantics-of-function"><span class="toc-number">4.</span> <span class="toc-text">Chapter 4. The Semantics of Function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#varieties-of-member-invocation"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. Varieties of Member Invocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual-member-functions"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. Virtual Member Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84-virtual"><span class="toc-number">4.2.1.</span> <span class="toc-text">多重继承下的 virtual</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-functions"><span class="toc-number">4.3.</span> <span class="toc-text">4.5. Inline Functions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-5.-semantics-of-construction-destruction-and-copy."><span class="toc-number">5.</span> <span class="toc-text">Chapter 5. Semantics of Construction, Destruction, and Copy.</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#object-construction-without-inheritance"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. Object Construction without Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-construction-under-inheritance"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. Object Construction under Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-copy-semantics"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. Object Copy Semantics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-efficiency."><span class="toc-number">5.4.</span> <span class="toc-text">5.4. Object Efficiency.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semantics-of-destruction"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. Semantics of Destruction</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-6.-runtime-semantics"><span class="toc-number">6.</span> <span class="toc-text">Chapter 6. Runtime Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#object-construction-and-destruction"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. Object Construction and Destruction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#global"><span class="toc-number">6.1.1.</span> <span class="toc-text">global</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#local-static"><span class="toc-number">6.1.2.</span> <span class="toc-text">local static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-of-object"><span class="toc-number">6.1.3.</span> <span class="toc-text">array of object</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#operators-new-and-delete"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. Operators new and delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#temporary-objects"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. Temporary Objects</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-7.-on-the-cusp-of-the-object-model"><span class="toc-number">7.</span> <span class="toc-text">Chapter 7. On the Cusp of the Object Model</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#templates"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. Templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exception-handling"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. Exception Handling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime-type-identification"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. Runtime Type Identification</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#efficient-but-inflexible"><span class="toc-number">7.4.</span> <span class="toc-text">7.4. Efficient, but Inflexible?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.</span> <span class="toc-text">关于作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">9.</span> <span class="toc-text">多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%9F%BA%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">多个基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiple-inclusion"><span class="toc-number">9.3.</span> <span class="toc-text">multiple inclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">9.4.</span> <span class="toc-text">虚基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">构造函数与析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overhead"><span class="toc-number">9.6.</span> <span class="toc-text">overhead</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#memory-layout"><span class="toc-number">10.</span> <span class="toc-text">memory layout</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">10.1.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual-func-static-member"><span class="toc-number">10.2.</span> <span class="toc-text">+virtual func + static member</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inheritance"><span class="toc-number">10.3.</span> <span class="toc-text">+inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiple-inheritance"><span class="toc-number">10.4.</span> <span class="toc-text">+ multiple inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual-inheritance"><span class="toc-number">10.5.</span> <span class="toc-text">+ virtual inheritance</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gcc-virtual-table"><span class="toc-number">11.</span> <span class="toc-text">GCC virtual table</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vtable-notes-on-multiple-inheritance-in-gcc-c-compiler-v4.0.1"><span class="toc-number">11.1.</span> <span class="toc-text">VTable Notes on Multiple Inheritance in GCC C++ Compiler v4.0.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#simple-multiple-inheritance"><span class="toc-number">11.2.</span> <span class="toc-text">Simple Multiple Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attention"><span class="toc-number">11.3.</span> <span class="toc-text">attention!!!!</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/09/4df836237f4a.html" title="计算机网络总结"><img src="/img/cover/IMG_3302.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络总结"/></a><div class="content"><a class="title" href="/2020/09/4df836237f4a.html" title="计算机网络总结">计算机网络总结</a><time datetime="2023-08-07T14:31:50.026Z" title="Updated 2023-08-07 22:31:50">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/a6f2ba33bf73.html" title="ts js html"><img src="/img/cover/IMG_2229.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts js html"/></a><div class="content"><a class="title" href="/2023/07/a6f2ba33bf73.html" title="ts js html">ts js html</a><time datetime="2023-08-04T14:34:39.305Z" title="Updated 2023-08-04 22:34:39">2023-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/b615e50b2d89.html" title="clean-code"><img src="/img/cover/IMG_1282.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="clean-code"/></a><div class="content"><a class="title" href="/2023/08/b615e50b2d89.html" title="clean-code">clean-code</a><time datetime="2023-08-03T03:54:00.470Z" title="Updated 2023-08-03 11:54:00">2023-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/329021a6ce35.html" title="develop-exercise"><img src="/img/cover/IMG_3540.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="develop-exercise"/></a><div class="content"><a class="title" href="/2023/08/329021a6ce35.html" title="develop-exercise">develop-exercise</a><time datetime="2023-08-03T03:54:00.470Z" title="Updated 2023-08-03 11:54:00">2023-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/c7cdc8607a22.html" title="设计模式读书笔记"><img src="/img/cover/IMG_2232.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式读书笔记"/></a><div class="content"><a class="title" href="/2022/11/c7cdc8607a22.html" title="设计模式读书笔记">设计模式读书笔记</a><time datetime="2023-08-01T08:07:38.319Z" title="Updated 2023-08-01 16:07:38">2023-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>