<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: 读书笔记 | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="OS3pieces读书笔记">
<meta property="og:url" content="https://sinos_wei.gitee.io/2022/06/b17e0aa0b323.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/IMG_3541.jpg">
<meta property="article:published_time" content="2022-06-04T08:47:16.000Z">
<meta property="article:modified_time" content="2023-08-01T08:07:38.301Z">
<meta property="article:author" content="Sinos">
<meta property="article:tag" content="int">
<meta property="article:tag" content="mutex">
<meta property="article:tag" content="sem">
<meta property="article:tag" content="lock">
<meta property="article:tag" content="key">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/IMG_3541.jpg"><link rel="shortcut icon" href="/img/cover/IMG_2242.jpg"><link rel="canonical" href="https://sinos_wei.gitee.io/2022/06/b17e0aa0b323.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: 读书笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-01 16:07:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cover/IMG_2242.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/IMG_3541.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Sinos_wei's blog"><span class="site-name">Sinos_wei's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS3pieces读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-06-04T08:47:16.000Z" title="Created 2022-06-04 16:47:16">2022-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-01T08:07:38.301Z" title="Updated 2023-08-01 16:07:38">2023-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS3pieces读书笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>

</blockquote>
<span id="more"></span>
<h1 id="virtualize">virtualize</h1>
<h2 id="process">process</h2>
<h3 id="process-a-running-program">process: a running program</h3>
<ul>
<li>APIs
<ul>
<li>create: load-&gt;stack-&gt;heap-&gt;relate IO-&gt;start main</li>
<li>fork: copy parent process returns parent? pid_of_children : 0</li>
<li>wait parent wait for children</li>
<li>exec execution</li>
</ul></li>
<li>status: running ready wait</li>
<li>data structures: process list, struct proc</li>
</ul>
<p>machine state: memory, registers</p>
<h3 id="limited-direct-execution">limited direct execution</h3>
<ul>
<li>user mode, kernel mode, system call, trap(system call contains a trap instruction)</li>
<li>switch
<ul>
<li>wait for system calls</li>
<li>a timer</li>
</ul></li>
</ul>
<h3 id="schedule">schedule</h3>
<p>T<sub>turnaround</sub> = T<sub>completion</sub> - T<sub>arrival</sub></p>
<p>T<sub>response</sub> = T<sub>firstrun</sub> - T<sub>arrival</sub></p>
<ul>
<li>FIFO/FCFS convoy effect bad</li>
<li>SJF 当任务不是同时发生时 bad</li>
<li>STCF/PSJF preempt</li>
<li>RR time-slicing</li>
<li>MLFQ 多级反馈队列
<ul>
<li>Rule 1: If Priority(A) &gt; Priority(B), A runs (B doesn’t).</li>
<li>Rule 2: If Priority(A) = Priority(B), A &amp; B run in RR.</li>
<li>Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).</li>
<li>Rule 4: Once a job uses up its time allotment at a given level (regardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).</li>
<li>Rule 5: After some time period S, move all the jobs in the system to the topmost queue.</li>
</ul></li>
<li>lottery: counter and ticket</li>
<li>stride: take a stride and increase pass value</li>
</ul>
<h2 id="memory">memory</h2>
<blockquote>
<p>every address generated by a user program is a virtual address</p>
<p>eg. 打印出来的都是虚拟地址<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3211p9vj7j20ps07kdgi.jpg" alt="截屏2022-06-09 15.32.54" /></p>
<p>location of code : 0x1095afe50 location of heap : 0x1096008c0 location of stack : 0x7fff691aea64</p>
</blockquote>
<p>address space: code, stack, heap, other(statically-initialized var)</p>
<ul>
<li>memory API
<ul>
<li>malloc: 参数 size_t, 表示分配的字节数 注意 strlen(s)+1</li>
<li>free: 参数必须是 malloc 返回的指针</li>
<li>常见错误</li>
</ul></li>
</ul>
<p>address translation: from va to pa</p>
<ul>
<li>dynamic relocation(by hardware): runtime
<ul>
<li>base and bound in MMU(memory management unit) base: calculate pa bouds: protection, saves size <em>or</em> pa of end</li>
</ul></li>
<li>static relocation(by software, before dynamic relocation): loader
<ul>
<li>rewrite addresses, no protection</li>
</ul></li>
</ul>
<h3 id="segementation-分段">segementation 分段</h3>
<p>different sections can have different base and bound</p>
<ul>
<li>va translation: va-&gt; segment + offset</li>
<li>stack grow backwards: add a <strong>bit</strong> to identify grow positive or not</li>
<li>protection: add permission bits</li>
<li>空间浪费
<ul>
<li>internal fragment: segment 内部</li>
<li>external fragment: segment 之间, 主要原因是段的大小不一样 选用合适的 free-list 算法 free-space need coalescing(合并) allocator add <strong>header block</strong> before a allocated region, which contains the size (explain why free() dont need size arg)
<ul>
<li>fit 算法:
<ul>
<li>best fit</li>
<li>worst fit</li>
<li>first fit</li>
<li>next fit</li>
<li>segregated lists</li>
<li>buddy allocation 2<sup>N</sup> easy to coalescing</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="paging-fixed-sized-segment-分页">paging: fixed-sized segment 分页</h3>
<p>page for virtual, page frame for physical</p>
<ul>
<li><p>page table: per-process data structure, stored in memory va-&gt; virtual page number + offset vpn--virtual page table--&gt; page frame number pa -&gt; pfn + offset</p>
<p>indexed by vpn <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h35ihvn8stj20qi03mjrj.jpg" alt="page table entry (PTE)" /></p></li>
</ul>
<p>translation lookaside buffer TLB: in mmu, just a cache</p>
<ul>
<li>先更新 tlb, 再查询 tlb</li>
<li>结构: vpn pfn flag_bits asid(pid)</li>
</ul>
<p>too much tables!</p>
<ul>
<li><p>bigger pages: internal fragment, mostly page size is 4KB</p></li>
<li><p>paging and segment: table for segment, 不需要再记录 invalid entry, 从而减少page tables大小</p></li>
<li><p>多级分页表 <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h35ixabi99j20t40i0gnm.jpg" alt="截屏2022-06-12 16.08.08" /></p>
<p>va tanslation <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h35iy18xscj20kq04umx9.jpg" alt="截屏2022-06-12 16.08.53" /></p></li>
</ul>
<h3 id="page-fault">page fault</h3>
<p>OS(sfotware!): page fault handler</p>
<p>TLB -&gt; not hit -&gt; page table register -&gt; page table -(swap space)-&gt; PTE -&gt; PFN -&gt; PA</p>
<p>swap darmon: high watermark, low watermark</p>
<h3 id="page-out">page out</h3>
<p>average memory access time(AMAT)</p>
<ul>
<li><p>FIFO: simple</p></li>
<li><p>random: simple</p></li>
<li><p>LRU(least recently used): not good when big loop</p>
<ul>
<li><p>approximating LRU</p>
<p>当一个 page 被使用时, use bit = 1 clock hand: 当page out 时, 查看当前指向的 page, 如果 use bit == 1, set page bit = 0, move on 如果 use bit == 0, page out</p></li>
</ul></li>
</ul>
<p>dirty bit: 应该优先 page out clean page 而不是 dirty page</p>
<p>clustering grouping</p>
<p>page0 is invalid, explain null pointer</p>
<p>COW(copy on write): when copy, read: address, write: copy</p>
<h3 id="lru">LRU</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">cap</span>(capacity) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(key) == map.<span class="built_in">end</span>()) 	</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> key_value = *map[key];</span><br><span class="line">        cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        cache.<span class="built_in">push_front</span>(key_value);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> key_value.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(key) == map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.<span class="built_in">size</span>() == cap) &#123;</span><br><span class="line">              map.<span class="built_in">erase</span>(cache.<span class="built_in">back</span>().first);</span><br><span class="line">              cache.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lfu">LFU</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt, time, key, value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _cnt, <span class="type">int</span> _time, <span class="type">int</span> _key, <span class="type">int</span> _value): <span class="built_in">cnt</span>(_cnt), <span class="built_in">time</span>(_time), <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt == rhs.cnt ? time &lt; rhs.time : cnt &lt; rhs.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存容量，时间戳</span></span><br><span class="line">    <span class="type">int</span> capacity, time;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node&gt; key_table;</span><br><span class="line">    set&lt;Node&gt; S;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="type">int</span> _capacity) &#123;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">        S.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node cache = it -&gt; second;</span><br><span class="line">        S.<span class="built_in">erase</span>(cache);</span><br><span class="line"></span><br><span class="line">        cache.cnt += <span class="number">1</span>;</span><br><span class="line">        cache.time = ++time;</span><br><span class="line"></span><br><span class="line">        S.<span class="built_in">insert</span>(cache);</span><br><span class="line">        it -&gt; second = cache;</span><br><span class="line">        <span class="keyword">return</span> cache.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity) &#123;</span><br><span class="line">                key_table.<span class="built_in">erase</span>(S.<span class="built_in">begin</span>() -&gt; key);</span><br><span class="line">                S.<span class="built_in">erase</span>(S.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node cache = <span class="built_in">Node</span>(<span class="number">1</span>, ++time, key, value);</span><br><span class="line">            key_table.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, cache));</span><br><span class="line">            S.<span class="built_in">insert</span>(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node cache = it -&gt; second;</span><br><span class="line">            S.<span class="built_in">erase</span>(cache);</span><br><span class="line">            cache.cnt += <span class="number">1</span>;</span><br><span class="line">            cache.time = ++time;</span><br><span class="line">            cache.value = value;</span><br><span class="line">            S.<span class="built_in">insert</span>(cache);</span><br><span class="line">            it -&gt; second = cache;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="concurrency">concurrency</h1>
<h2 id="thread">thread</h2>
<p>thread: share same address space own PC, registers, stack</p>
<p>API</p>
<ul>
<li>```c int pthread_create( pthread_t * thread, const pthread_attr_t * attr,//null void * (<em>start_routine)(void</em>), void * arg); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int pthread_join(</span><br><span class="line">  pthread_t thread, </span><br><span class="line">  void **value_ptr);//return value</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="lock">lock</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">assert(rc==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Pthread_mutex_lock(<span class="type">pthread_mutex_t</span> *mutex)&#123;</span><br><span class="line">  <span class="type">int</span> rc = pthread_mutex_lock(mutex);</span><br><span class="line">  assert(rc==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controlling-interrupts">controlling interrupts</h3>
<p>禁止中断, 适合单处理器系统</p>
<h3 id="test-and-set-atomatic-instruction">test and set atomatic instruction</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> new)</span>&#123;</span><br><span class="line">  <span class="type">int</span> old = *ptr;</span><br><span class="line">  *ptr = new;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//testandset 为原子指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span>&#123;</span><span class="type">int</span> flag;&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">  lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">//spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">  lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="compare-and-swap">compare and swap</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expect, <span class="type">int</span> new)</span>&#123;</span><br><span class="line">  <span class="type">int</span> actual = *ptr;</span><br><span class="line">  <span class="keyword">if</span>(actual == expected)</span><br><span class="line">    *ptr = new;</span><br><span class="line">  <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">//spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="load-linked-and-store-conditional-llsc">load-linked and store-conditional (LL/SC)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LoadLinked</span><span class="params">(<span class="type">int</span> *ptr)</span>&#123;<span class="keyword">return</span> *ptr&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StoreConditional</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(no one has updated *ptr since the LoadLinked to this address)&#123;</span><br><span class="line">    *ptr = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(LoadLinked(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">      ;<span class="comment">//spin</span></span><br><span class="line">    <span class="keyword">if</span>(StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fetch-and-addticket-and-turn">fetch and add(ticket and turn)</h3>
<p>保证公平性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span>&#123;</span><br><span class="line">  <span class="type">int</span> old = *ptr;</span><br><span class="line">  *ptr = old+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> ticket;</span><br><span class="line">  <span class="type">int</span> turn;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">  <span class="type">int</span> mytyrn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">  <span class="keyword">while</span>(lock-&gt;turn != myturn)</span><br><span class="line">    ;<span class="comment">//spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">  FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="yield持续-spinn-导致效率为-1n">yield(持续 spinn 导致效率为 1/N)</h3>
<p><code>yield()</code>放弃 cpu</p>
<h3 id="队列">队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="type">int</span> guard;</span><br><span class="line">    <span class="type">queue_t</span> *q;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span>&#123;</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TesAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">//spin</span></span><br><span class="line">    <span class="keyword">if</span>(m-&gt;flag == <span class="number">0</span>)&#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>;</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">     	  setpark();<span class="comment">//put thread to sleep</span></span><br><span class="line">      	<span class="comment">//If another thread calls unpark before park is actually called, the subsequent park returns immediately instead of sleeping</span></span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TesAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">//spin</span></span><br><span class="line">    <span class="keyword">if</span>(queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q));</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="two-phase-locks">two-phase locks</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span><span class="params">(<span class="type">int</span> *mutex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">if</span>(atomic_bit_test_and_set(mutex, <span class="number">31</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    atomic_increment(mutex);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(atomic_bit_test_and_set(mutex, <span class="number">31</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            atomic_decrement(mutex);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        v = *mutex;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        futex_wait(mutex, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span> <span class="params">(<span class="type">int</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="comment">/* Adding 0x80000000 to the counter results</span></span><br><span class="line"><span class="comment">    there are not other interested threads */</span> </span><br><span class="line">    <span class="keyword">if</span> (atomic_add_zero (mutex, <span class="number">0x80000000</span>))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* There are other threads waiting for this wake one of them up. */</span></span><br><span class="line">    futex_wake (mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lock-based-data-structure">lock based data structure</h2>
<p>thread safe</p>
<h3 id="counter">counter</h3>
<p>sloppy counter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> global;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> glock;</span><br><span class="line">    <span class="type">int</span> local[NUMCPUS];</span><br><span class="line">    <span class="type">pthread_mutex_t</span> llock[NUMCPUS];</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">&#125; <span class="type">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">counter_t</span> *c, <span class="type">int</span> threshold)</span>&#123;</span><br><span class="line">    c-&gt;threshold = threshold;</span><br><span class="line">    c-&gt;global = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUMCPUS; i++)&#123;</span><br><span class="line">        c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">counter_t</span> *c, <span class="type">int</span> threadID, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">//amt amount</span></span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">    c-&gt;local[threadID] += amt;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;local[threadID] &gt;= c-&gt;threshold)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">        pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">counter_t</span> *c)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="type">int</span> val = c-&gt;global;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键在于 threshold 值</p>
<p>s=1 即为无 sloppy lock</p>
<h3 id="linked-list">linked list</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">node_t</span> *head;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">&#125;<span class="type">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Init</span><span class="params">(<span class="type">list_t</span> *l)</span>&#123;</span><br><span class="line">    l-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_init(&amp;l-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Insert</span><span class="params">(<span class="type">list_t</span> *l, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(new==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;l-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new-&gt;key = key;</span><br><span class="line">  	</span><br><span class="line">  	pthread_mutex_lock(&amp;l-&gt;lock);</span><br><span class="line">    new-&gt;next = l-&gt;head;</span><br><span class="line">    l-&gt;head = new;</span><br><span class="line">    pthread_mutex_unlock(&amp;l-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Lookup</span><span class="params">(<span class="type">list_t</span> *l, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">  	<span class="type">int</span> rv = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;l-&gt;lock);</span><br><span class="line">    <span class="type">node_t</span> *curr = l-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;key == key)&#123;</span><br><span class="line">            rv=<span class="number">0</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;l-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="queue">queue</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">queue_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">node_t</span> *head;</span><br><span class="line">    <span class="type">node_t</span> *tail;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> head_lock;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> tail_lock;</span><br><span class="line">&#125;<span class="type">queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Init</span><span class="params">(<span class="type">queue_t</span> *q)</span>&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;head = q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;head_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;tail_lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Enqueue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(tmp!=<span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tail_lock);</span><br><span class="line">    q-&gt;tail-&gt;next = tmp;</span><br><span class="line">    q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tail_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Queue_Dequeue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> *value)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="type">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="type">node_t</span> *new_head = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(new_head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *value = new_head-&gt;value;</span><br><span class="line">    q-&gt;head = new_head;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hash-table">hash table</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUCKETS 101</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125;<span class="type">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_init</span><span class="params">(<span class="type">hash_t</span> *h)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;BUCKETS; i++)</span><br><span class="line">        List_Init(&amp;h-&gt;lists[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash_insert</span><span class="params">(<span class="type">hash_t</span> *h, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> bucket = key%BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Insert(&amp;h-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash_lookup</span><span class="params">(<span class="type">hash_t</span> *h, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> bucket = key%BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Lookup(&amp;h-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="condition-variables">condition variables</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;c);</span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    thr_exit();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(done == <span class="number">0</span>)</span><br><span class="line">        pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent beigin\n&quot;</span>);</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    thr_join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pthread_cond_wait: put sleep, release lock, when return acquire lock</p>
<h3 id="生产者消费者模型">生产者消费者模型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="type">int</span> buffer[MAX];</span><br><span class="line"><span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> use = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill] = value;</span><br><span class="line">    fill = (fill+<span class="number">1</span>)%MAX;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = buffer[use];</span><br><span class="line">    use = (use+<span class="number">1</span>)%MAX;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">cond_t</span> empty, fill;</span><br><span class="line"><span class="type">mutux_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;loops; i++)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        <span class="keyword">while</span>(count == MAX)</span><br><span class="line">            pthread_cond_wait(&amp;empty, &amp;m);</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;fill);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;loops; i++)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        <span class="keyword">while</span>(count==<span class="number">0</span>)</span><br><span class="line">            pthread_cond_wait(&amp;fill, &amp;m);</span><br><span class="line">        <span class="type">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;empty);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="semaphores-信号量">semaphores 信号量</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//arg1 semaphore, arg2 flags usually null, arg3 initial value</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> s)</span>&#123;</span><br><span class="line">  <span class="comment">//decrement</span></span><br><span class="line">  <span class="comment">//sem &gt;= 0 return</span></span><br><span class="line">  <span class="comment">//else wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> s)</span>&#123;</span><br><span class="line">  <span class="comment">//increment</span></span><br><span class="line">  <span class="comment">//wake sleep threads</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="binary-semaphores-lock">binary semaphores: lock</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">sem_wait(&amp;s);</span><br><span class="line"><span class="comment">//critical section</span></span><br><span class="line">sem_post(&amp;s);</span><br></pre></td></tr></table></figure>
<p>注意初始化为 1</p>
<h4 id="as-condition-variables">as condition variables</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent begin\n&quot;</span>);</span><br><span class="line">    <span class="type">pthread_t</span> c;</span><br><span class="line">    pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意初始化为 0</p>
<h4 id="生产者消费者">生产者消费者</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="type">int</span> buffer[MAX];</span><br><span class="line"><span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> use = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill] = value;</span><br><span class="line">    fill = (fill+<span class="number">1</span>)%MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = buffer[use];</span><br><span class="line">    use = (use+<span class="number">1</span>)%MAX;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty;<span class="comment">//MAX</span></span><br><span class="line"><span class="type">sem_t</span> full;<span class="comment">//0</span></span><br><span class="line"><span class="type">sem_t</span> mutex;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;loops; i++)&#123;</span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        put(i);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        tmp = get();</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, MAX);</span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读写锁">读写锁</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;</span><br><span class="line">    <span class="type">sem_t</span> writelock;</span><br><span class="line">    <span class="type">int</span> readers;</span><br><span class="line">&#125;<span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span>(rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span>(rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        sem_post(&amp;rw-&gt;writelock);</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dining-philosophers">dining philosophers</h4>
<h2 id="common-problems">common problems</h2>
<ul>
<li>非死锁
<ul>
<li>违反原子性</li>
<li>违反顺序性(状态量)</li>
</ul></li>
<li>死锁
<ul>
<li>mutual exclusion
<ul>
<li>atomic operation</li>
</ul></li>
<li>hold and wait
<ul>
<li>acquiring all locks at once, atomically</li>
</ul></li>
<li>no preemption
<ul>
<li>repeat trying</li>
</ul></li>
<li>circular wait
<ul>
<li>always acquiring l1 before l2</li>
</ul></li>
</ul></li>
</ul>
<h2 id="基于事件的并发">基于事件的并发</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(<span class="type">int</span> nfds, <span class="comment">//number of file descriptions</span></span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> errorfds,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    fd_set readFDs;</span><br><span class="line">    FD_ZERO(&amp;readFDs);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">for</span>(fd=minFD; fd&lt;maxFD; fd++)</span><br><span class="line">      FD_SET(fd, &amp;readFDs);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> rc = select(maxFD+<span class="number">1</span>, &amp;readFDs, null, null, null);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">for</span>(fd=minFD; fd&lt;maxFD; fd++)</span><br><span class="line">      <span class="keyword">if</span>(FD_ISSET(fd, &amp;readFDs))</span><br><span class="line">        processFD(fd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步-ioasynchronous-io">异步 io(asynchronous io)</h3>
<p>AIO control block</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span> </span><br><span class="line">  <span class="type">int</span> aio_fildes; <span class="comment">/* File descriptor */</span> </span><br><span class="line">  <span class="type">off_t</span> aio_offset; <span class="comment">/* File offset */</span> </span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">void</span> * aio_buf； <span class="comment">/* Location of buffer */</span> </span><br><span class="line">  <span class="type">size_t</span> aio_nbytes; <span class="comment">/* Length of transfer */</span> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="persistence">persistence</h1>
<p>##IO device</p>
<p>register: status, command, data</p>
<p>PIO: programmed io(main cpu is involved in data movement)</p>
<p>use interrupt to avoid spin(device fast: poll, device slow: interrupt)</p>
<h3 id="dmadirect-memory-access">DMA(direct memory access)</h3>
<h3 id="device-communication">device communication</h3>
<p>IO instruction</p>
<p>memory mapped io</p>
<h3 id="device-driver">device driver</h3>
<h2 id="hard-disk-drives">hard disk drives</h2>
<h3 id="interface">interface</h3>
<p>platter 硬盘的一个面</p>
<p>spindle 旋转中心RPM(rotations per minute 7200-15000)</p>
<p>track 一个圈</p>
<p>sector track 的一部分(扇形)512B</p>
<p>disk arm disk head 读写探针, one per surface</p>
<h3 id="how-to-io">how to io</h3>
<ol type="1">
<li>move to track (seek time)</li>
<li>move to sector(rotational delay)</li>
</ol>
<p>track buffer(cache)</p>
<h4 id="when-writing">when writing</h4>
<ul>
<li>write back caching</li>
<li>write through</li>
</ul>
<h3 id="disk-scheduling">disk scheduling</h3>
<ul>
<li>SSTF(shortest seek time first)</li>
<li>elevator(scan)
<ul>
<li>F-SCAN, freezed queue when doing a sweep</li>
<li>C-SCAN, circular scan, the algorithm sweeps from outer-to-inner, and then inner-to-outer, etc</li>
</ul></li>
<li>SPTF(shortest positioning time first, SATF, shortest access time first)</li>
</ul>
<h2 id="raidsredundant-arrays-of-inexpensive-disks">RAIDs(redundant arrays of inexpensive disks)</h2>
<p>指标: capacity, reliability, performance</p>
<h3 id="raids-0-striping">raids 0: striping</h3>
<p>无备份, 全平行</p>
<p>sequencial read NS</p>
<p>sequencial write NS</p>
<p>random read NR</p>
<p>random wirte NR</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6c7p2fje4j20qy070wf0.jpg" alt="截屏2022-09-19 20.59.36" /><figcaption aria-hidden="true">截屏2022-09-19 20.59.36</figcaption>
</figure>
<h3 id="raids-1-mirroring">raids 1: mirroring</h3>
<p>raid10 and raid01</p>
<p>sequencial read NS/2</p>
<p>sequencial write NS/2</p>
<p>random read NR</p>
<p>random wirte NR/2</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6c7reblzgj20ak0h8aau.jpg" alt="截屏2022-09-19 21.01.50" style="zoom:33%;" /></p>
<h2 id="raids4-奇偶校验">raids4 奇偶校验</h2>
<p>sequencial read S(N-1)</p>
<p>sequencial write S(N-1)</p>
<p>random read R(N-1)</p>
<p>random wirte R/2</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6c7yphl70j20ie06q3yo.jpg" alt="截屏2022-09-19 21.08.52" /><figcaption aria-hidden="true">截屏2022-09-19 21.08.52</figcaption>
</figure>
<h2 id="raid-5-循环奇偶校验">raid 5 循环奇偶校验</h2>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6c80ryadrj20jo07uglv.jpg" alt="截屏2022-09-19 21.10.54" /><figcaption aria-hidden="true">截屏2022-09-19 21.10.54</figcaption>
</figure>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6c813n1ogj20ya0dm408.jpg" alt="截屏2022-09-19 21.11.12" /><figcaption aria-hidden="true">截屏2022-09-19 21.11.12</figcaption>
</figure>
<h2 id="file-and-directories">file and directories</h2>
<p>inode number --&gt; low-level name</p>
<p>file descripter</p>
<p>standard input, output, error</p>
<h3 id="link">link</h3>
<h4 id="hard-link">hard link</h4>
<p>The way link works is that it simply creates another name in the directory you are creating the link to, and refers it to the same inode number</p>
<p>reference count</p>
<p>only file, cannot dir</p>
<p>only existed file</p>
<h4 id="symbolic-link">symbolic link</h4>
<p>hold path name</p>
<h2 id="file-system">file system</h2>
<p>block: 4K</p>
<p>inode(index node): 256B</p>
<p>free list</p>
<p>inode bitmap, data bitmap</p>
<p>indirect pointer</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2022/06/b17e0aa0b323.html">https://sinos_wei.gitee.io/2022/06/b17e0aa0b323.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/int/">int</a><a class="post-meta__tags" href="/tags/mutex/">mutex</a><a class="post-meta__tags" href="/tags/sem/">sem</a><a class="post-meta__tags" href="/tags/lock/">lock</a><a class="post-meta__tags" href="/tags/key/">key</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/IMG_3541.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/6f4efbde8095.html" title="ShellScript"><img class="cover" src="/img/cover/DESIGN17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">ShellScript</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/e9c1735229a9.html" title="操作系统历史"><img class="cover" src="/img/cover/IMG_2409.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">操作系统历史</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/05/724d57ab8c34.html" title="操作系统"><img class="cover" src="/img/cover/IMG_8779.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-15</div><div class="title">操作系统</div></div></a></div><div><a href="/2022/01/45f494d95337.html" title="cpp 从入门到汇编"><img class="cover" src="/img/cover/IMG_3300.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-12</div><div class="title">cpp 从入门到汇编</div></div></a></div><div><a href="/2022/01/87d43a06543c.html" title="leetcode"><img class="cover" src="/img/cover/Designgg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">leetcode</div></div></a></div><div><a href="/2023/05/f05961026253.html" title="数据结构"><img class="cover" src="/img/cover/IMG_2263.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-15</div><div class="title">数据结构</div></div></a></div><div><a href="/2022/09/84cc1427d0ce.html" title="effective_cpp读书笔记"><img class="cover" src="/img/cover/IMG_8779.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-24</div><div class="title">effective_cpp读书笔记</div></div></a></div><div><a href="/2021/12/fa447478d9bd.html" title="面经"><img class="cover" src="/img/cover/IMG_3300.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-06</div><div class="title">面经</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cover/IMG_2242.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://8.130.42.149:5230" target="_blank" title="memo"><i class="fab fa-heart"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#virtualize"><span class="toc-number">1.</span> <span class="toc-text">virtualize</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#process"><span class="toc-number">1.1.</span> <span class="toc-text">process</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-a-running-program"><span class="toc-number">1.1.1.</span> <span class="toc-text">process: a running program</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limited-direct-execution"><span class="toc-number">1.1.2.</span> <span class="toc-text">limited direct execution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule"><span class="toc-number">1.1.3.</span> <span class="toc-text">schedule</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memory"><span class="toc-number">1.2.</span> <span class="toc-text">memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#segementation-%E5%88%86%E6%AE%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">segementation 分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#paging-fixed-sized-segment-%E5%88%86%E9%A1%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">paging: fixed-sized segment 分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#page-fault"><span class="toc-number">1.2.3.</span> <span class="toc-text">page fault</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#page-out"><span class="toc-number">1.2.4.</span> <span class="toc-text">page out</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lru"><span class="toc-number">1.2.5.</span> <span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lfu"><span class="toc-number">1.2.6.</span> <span class="toc-text">LFU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#concurrency"><span class="toc-number">2.</span> <span class="toc-text">concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#thread"><span class="toc-number">2.1.</span> <span class="toc-text">thread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lock"><span class="toc-number">2.2.</span> <span class="toc-text">lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#controlling-interrupts"><span class="toc-number">2.2.1.</span> <span class="toc-text">controlling interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#test-and-set-atomatic-instruction"><span class="toc-number">2.2.2.</span> <span class="toc-text">test and set atomatic instruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compare-and-swap"><span class="toc-number">2.2.3.</span> <span class="toc-text">compare and swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-linked-and-store-conditional-llsc"><span class="toc-number">2.2.4.</span> <span class="toc-text">load-linked and store-conditional (LL&#x2F;SC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-and-addticket-and-turn"><span class="toc-number">2.2.5.</span> <span class="toc-text">fetch and add(ticket and turn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield%E6%8C%81%E7%BB%AD-spinn-%E5%AF%BC%E8%87%B4%E6%95%88%E7%8E%87%E4%B8%BA-1n"><span class="toc-number">2.2.6.</span> <span class="toc-text">yield(持续 spinn 导致效率为 1&#x2F;N)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.2.7.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#two-phase-locks"><span class="toc-number">2.2.8.</span> <span class="toc-text">two-phase locks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-based-data-structure"><span class="toc-number">2.3.</span> <span class="toc-text">lock based data structure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#counter"><span class="toc-number">2.3.1.</span> <span class="toc-text">counter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linked-list"><span class="toc-number">2.3.2.</span> <span class="toc-text">linked list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">2.3.3.</span> <span class="toc-text">queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-table"><span class="toc-number">2.3.4.</span> <span class="toc-text">hash table</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#condition-variables"><span class="toc-number">2.4.</span> <span class="toc-text">condition variables</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">生产者消费者模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphores-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.5.</span> <span class="toc-text">semaphores 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#binary-semaphores-lock"><span class="toc-number">2.5.0.1.</span> <span class="toc-text">binary semaphores: lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#as-condition-variables"><span class="toc-number">2.5.0.2.</span> <span class="toc-text">as condition variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.5.0.3.</span> <span class="toc-text">生产者消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">2.5.0.4.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dining-philosophers"><span class="toc-number">2.5.0.5.</span> <span class="toc-text">dining philosophers</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#common-problems"><span class="toc-number">2.6.</span> <span class="toc-text">common problems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="toc-number">2.7.</span> <span class="toc-text">基于事件的并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-ioasynchronous-io"><span class="toc-number">2.7.1.</span> <span class="toc-text">异步 io(asynchronous io)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#persistence"><span class="toc-number">3.</span> <span class="toc-text">persistence</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dmadirect-memory-access"><span class="toc-number">3.0.1.</span> <span class="toc-text">DMA(direct memory access)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#device-communication"><span class="toc-number">3.0.2.</span> <span class="toc-text">device communication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#device-driver"><span class="toc-number">3.0.3.</span> <span class="toc-text">device driver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hard-disk-drives"><span class="toc-number">3.1.</span> <span class="toc-text">hard disk drives</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#interface"><span class="toc-number">3.1.1.</span> <span class="toc-text">interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#how-to-io"><span class="toc-number">3.1.2.</span> <span class="toc-text">how to io</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#when-writing"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">when writing</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#disk-scheduling"><span class="toc-number">3.1.3.</span> <span class="toc-text">disk scheduling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raidsredundant-arrays-of-inexpensive-disks"><span class="toc-number">3.2.</span> <span class="toc-text">RAIDs(redundant arrays of inexpensive disks)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#raids-0-striping"><span class="toc-number">3.2.1.</span> <span class="toc-text">raids 0: striping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raids-1-mirroring"><span class="toc-number">3.2.2.</span> <span class="toc-text">raids 1: mirroring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raids4-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.3.</span> <span class="toc-text">raids4 奇偶校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raid-5-%E5%BE%AA%E7%8E%AF%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.4.</span> <span class="toc-text">raid 5 循环奇偶校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#file-and-directories"><span class="toc-number">3.5.</span> <span class="toc-text">file and directories</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#link"><span class="toc-number">3.5.1.</span> <span class="toc-text">link</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hard-link"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">hard link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symbolic-link"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">symbolic link</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#file-system"><span class="toc-number">3.6.</span> <span class="toc-text">file system</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/09/4df836237f4a.html" title="计算机网络总结"><img src="/img/cover/cbb97af3dbcf09d992878450cb6f529d494aff10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络总结"/></a><div class="content"><a class="title" href="/2020/09/4df836237f4a.html" title="计算机网络总结">计算机网络总结</a><time datetime="2023-08-07T14:31:50.026Z" title="Updated 2023-08-07 22:31:50">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/a6f2ba33bf73.html" title="ts js html"><img src="/img/cover/IMG_2406.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts js html"/></a><div class="content"><a class="title" href="/2023/07/a6f2ba33bf73.html" title="ts js html">ts js html</a><time datetime="2023-08-04T14:34:39.305Z" title="Updated 2023-08-04 22:34:39">2023-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/b615e50b2d89.html" title="clean-code"><img src="/img/cover/IMG_2945.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="clean-code"/></a><div class="content"><a class="title" href="/2023/08/b615e50b2d89.html" title="clean-code">clean-code</a><time datetime="2023-08-03T03:54:00.470Z" title="Updated 2023-08-03 11:54:00">2023-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/329021a6ce35.html" title="develop-exercise"><img src="/img/cover/IMG_3033.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="develop-exercise"/></a><div class="content"><a class="title" href="/2023/08/329021a6ce35.html" title="develop-exercise">develop-exercise</a><time datetime="2023-08-03T03:54:00.470Z" title="Updated 2023-08-03 11:54:00">2023-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/c7cdc8607a22.html" title="设计模式读书笔记"><img src="/img/cover/IMG_3037.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式读书笔记"/></a><div class="content"><a class="title" href="/2022/11/c7cdc8607a22.html" title="设计模式读书笔记">设计模式读书笔记</a><time datetime="2023-08-01T08:07:38.319Z" title="Updated 2023-08-01 16:07:38">2023-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>