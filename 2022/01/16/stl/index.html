<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>stl | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="stl">
<meta property="og:url" content="https://sinos_wei.gitee.io/2022/01/16/stl/index.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/IMG_0783.JPG">
<meta property="article:published_time" content="2022-01-16T10:55:11.000Z">
<meta property="article:modified_time" content="2022-09-23T10:34:29.804Z">
<meta property="article:author" content="Sinos">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="stl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/IMG_0783.JPG"><link rel="shortcut icon" href="/img/icon.JPG"><link rel="canonical" href="https://sinos_wei.gitee.io/2022/01/16/stl/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'stl',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-23 18:34:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/IMG_0783.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Sinos_wei's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">stl</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-01-16T10:55:11.000Z" title="Created 2022-01-16 18:55:11">2022-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-09-23T10:34:29.804Z" title="Updated 2022-09-23 18:34:29">2022-09-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/language/">language</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="stl"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
</blockquote>
<span id="more"></span>

<h1 id="global-function"><a href="#global-function" class="headerlink" title="global function"></a>global function</h1><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">remove</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*first == val)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result!=first)</span><br><span class="line">        *result = <span class="built_in">move</span>(*first);</span><br><span class="line">      ++result;</span><br><span class="line">    &#125;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transforms the range <code>[first,last)</code> into a range with all the elements that compare equal to val removed, and returns an iterator to the new end of that range.</p>
<p><strong>size 不变</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> i = std::<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;*i&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; i:v)</span><br><span class="line">      cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="move-forward"><a href="#move-forward" class="headerlink" title="move forward"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9671749/whats-the-difference-between-stdmove-and-stdforward">move forward</a></h2><p><code>std::move</code> takes an object and allows you to treat it as a temporary (an rvalue). Although it isn’t a semantic requirement, typically a function accepting a reference to an rvalue will invalidate it. When you see <code>std::move</code>, it indicates that the value of the object should not be used afterwards, but you can still assign a new value and continue using it.</p>
<p><code>std::forward</code> has a single use case: <strong>to cast a templated function parameter (inside the function) to the value category</strong> (lvalue or rvalue) the caller used to pass it. This allows rvalue arguments to be passed on as rvalues, and lvalues to be passed on as lvalues, a scheme called “perfect forwarding.”</p>
<p>To <a target="_blank" rel="noopener" href="http://ideone.com/z5li7">illustrate</a>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">overloaded</span><span class="params">( <span class="type">int</span> <span class="type">const</span> &amp;arg )</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;by lvalue\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">overloaded</span><span class="params">( <span class="type">int</span> &amp;&amp; arg )</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;by rvalue\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> t &gt;</span><br><span class="line"><span class="comment">/* &quot;t &amp;&amp;&quot; with &quot;t&quot; being template param is special, and  adjusts &quot;t&quot; to be (for example) &quot;int &amp;&quot; or non-ref &quot;int&quot; so std::forward knows what to do. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarding</span><span class="params">( t &amp;&amp; arg )</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;via std::forward: &quot;</span>;</span><br><span class="line">    <span class="built_in">overloaded</span>( std::forward&lt;t&gt;(arg) );</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;via std::move: &quot;</span>;</span><br><span class="line">    <span class="built_in">overloaded</span>( std::<span class="built_in">move</span>(arg) ); <span class="comment">// conceptually this would invalidate arg</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;by simple passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">overloaded</span>( arg );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initial caller passes rvalue:\n&quot;</span>;</span><br><span class="line">    forwarding( <span class="number">5</span> );</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initial caller passes lvalue:\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    forwarding( x );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">initial caller passes rvalue:</span></span><br><span class="line"><span class="comment">via std::forward: by rvalue</span></span><br><span class="line"><span class="comment">via std::move: by rvalue</span></span><br><span class="line"><span class="comment">by simple passing: by lvalue</span></span><br><span class="line"><span class="comment">initial caller passes lvalue:</span></span><br><span class="line"><span class="comment">via std::forward: by lvalue</span></span><br><span class="line"><span class="comment">via std::move: by rvalue</span></span><br><span class="line"><span class="comment">by simple passing: by lvalue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>As Howard mentions, there are also similarities as both these functions simply cast to reference type. But outside these specific use cases (which cover 99.9% of the usefulness of rvalue reference casts), you should use <code>static_cast</code> directly and write a good explanation of what you’re doing.</p>
<p>简而言之, move 将一切值变为右值, forward 进行完美转发, 不改变右值或者左值</p>
<p>In C++11, a <a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Move_Constructor">move constructor</a> of <code>std::vector&lt;T&gt;</code> that <strong>takes an rvalue reference to an <code>std::vector&lt;T&gt;</code> can copy the pointer to the internal C-style array out of the rvalue into the new <code>std::vector&lt;T&gt;</code></strong>, then set the pointer inside the rvalue to null. Since the temporary will never again be used, no code will try to access the null pointer, and because the pointer is null, its memory is not deleted when it goes out of scope. Hence, the operation not only forgoes the expense of a deep copy, but is safe and invisible.</p>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><blockquote>
<p>random-&gt;bidirectional-&gt;forward-&gt;input&#x2F;output</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyfngf8848j314i0rcdk2.jpg" alt="截屏2022-01-16 下午5.38.52"></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    cout&lt;&lt;i.<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">    ++i;</span><br><span class="line">    cout&lt;&lt;i.<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">    i = v.<span class="built_in">end</span>();</span><br><span class="line">    cout&lt;&lt;i.<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;v.<span class="built_in">end</span>()-v.<span class="built_in">begin</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">	0x600000141100</span></span><br><span class="line"><span class="comment">  0x600000141104</span></span><br><span class="line"><span class="comment">  0x600000141114</span></span><br><span class="line"><span class="comment">  5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>to get int from iterator</p>
<p><code>it - vec.begin()</code></p>
<h3 id="rbegin"><a href="#rbegin" class="headerlink" title="rbegin"></a>rbegin</h3><p>Returns a <em>reverse iterator</em> pointing to the <strong>last element</strong> in the <a target="_blank" rel="noopener" href="http://www.cplusplus.com/vector">vector</a></p>
<p><code>rbegin</code> points to the element right before the one that would be pointed to by member <a target="_blank" rel="noopener" href="http://www.cplusplus.com/vector::end">end</a>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myvector</span> <span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 5 default-constructed ints</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt;::reverse_iterator rit = myvector.<span class="built_in">rbegin</span>();</span><br><span class="line">  <span class="keyword">for</span> (; rit!= myvector.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><blockquote>
<p>common:</p>
<p>[first, last)</p>
<p>end return past-end</p>
<p>use &lt; to compare, strict weak ordering, a&#x3D;&#x3D;b equals !(a&lt;b) &amp;&amp; !(b&lt;a)</p>
<p>if not find return end()</p>
</blockquote>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>s.length() &#x3D;&#x3D; s.size()</p>
<p>+&#x3D; string, char</p>
<p>append str</p>
<p>push_back char</p>
<p>strrev</p>
<p>insert position str</p>
<p>end()<br>Returns an iterator pointing to the <em>past-the-end</em> character of the string.</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><blockquote>
<p>扩充容量: 2 倍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;&#125;;</span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;v.<span class="built_in">begin</span>().<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;v.<span class="built_in">end</span>().<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;v.<span class="built_in">begin</span>().<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;v.<span class="built_in">end</span>().<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x600000b48030</span></span><br><span class="line"><span class="comment">0x600000b48030</span></span><br><span class="line"><span class="comment">0x600000b48030</span></span><br><span class="line"><span class="comment">0x600000b48034</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//end() always return past end element</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li><p>v.back() 最后一个元素</p>
</li>
<li><p>二维 vector 初始化<br><code>vector&lt;vector&lt;int&gt;&gt;v (row, vector&lt;int&gt;(column, 0));</code></p>
</li>
</ul>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><table>
<thead>
<tr>
<th align="right">default (1)</th>
<th><code>explicit vector (const allocator_type&amp; alloc = allocator_type()); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">fill (2)</td>
<td><code>explicit vector (size_type n);        </code><br /><code>vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());</code></td>
</tr>
<tr>
<td align="right">range (3)</td>
<td><code>template &lt;class InputIterator&gt;  vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type()); </code></td>
</tr>
<tr>
<td align="right">copy (4)</td>
<td><code>vector (const vector&amp; x); </code><br /><code>vector (const vector&amp; x, const allocator_type&amp; alloc); </code></td>
</tr>
<tr>
<td align="right">move (5)</td>
<td><code>vector (vector&amp;&amp; x); </code><br /><code>vector (vector&amp;&amp; x, const allocator_type&amp; alloc); </code></td>
</tr>
<tr>
<td align="right">initializer list (6)</td>
<td><code>vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());</code></td>
</tr>
</tbody></table>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>元素清空, size &#x3D; 0</p>
<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>[first, last)</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><table>
<thead>
<tr>
<th align="right">range(1)</th>
<th><code>template &lt;class InputIterator&gt;  void assign (InputIterator first, InputIterator last); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">fill (2)</td>
<td><code>void assign (size_type n, const value_type&amp; val); </code></td>
</tr>
<tr>
<td align="right">initializer list (3)</td>
<td><code>void assign (initializer_list&lt;value_type&gt; il);</code></td>
</tr>
</tbody></table>
<p>size change</p>
<h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>The content of <em>val</em> is copied (or moved) to the new element.</p>
<h3 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>remove last element, –size</p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><table>
<thead>
<tr>
<th align="right">single element (1)</th>
<th><code>iterator insert (const_iterator position, const value_type&amp; val); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">fill (2)</td>
<td><code>iterator insert (const_iterator position, size_type n, const value_type&amp; val); </code></td>
</tr>
<tr>
<td align="right">range (3)</td>
<td><code>template &lt;class InputIterator&gt; </code><br /><code>iterator insert (const_iterator position, InputIterator first, InputIterator last); </code></td>
</tr>
<tr>
<td align="right">move (4)</td>
<td><code>iterator insert (const_iterator position, value_type&amp;&amp; val); </code></td>
</tr>
<tr>
<td align="right">initializer list (5)</td>
<td><code>iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il);</code></td>
</tr>
</tbody></table>
<p>The <a target="_blank" rel="noopener" href="https://www.cplusplus.com/vector">vector</a> is extended by inserting new elements <strong><u>before</u> the element at the specified <em>position</em></strong></p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(vector&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>After the call to this member function, the elements in this container are those which were in <em>x</em> before the call, and the elements of <em>x</em> are those which were in this. <strong>All iterators, references and pointers</strong> <strong>remain valid</strong> for the swapped objects. 即指针的内容 <code>*itrator</code> 不会改变</p>
<h3 id="emplace"><a href="#emplace" class="headerlink" title="emplace"></a>emplace</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>The container is extended by inserting a new element at <em>position</em>. This new element is <strong>constructed in place using <em>args</em></strong> as the arguments for its construction.</p>
<p>++size</p>
<h3 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>emplace at the end</p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><blockquote>
<p> <a target="_blank" rel="noopener" href="https://www.cplusplus.com/deque">deques</a> are not guaranteed to store all its elements in contiguous storage locations (do not use pointer) most method similar to vector</p>
</blockquote>
<h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><h3 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front"></a>pop_front</h3><h3 id="emplace-front"><a href="#emplace-front" class="headerlink" title="emplace_front"></a>emplace_front</h3><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><blockquote>
<p>only pointer to next node</p>
<p>special: </p>
<ul>
<li>before_begin iterator</li>
<li>push pop front only</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;&amp;*l.<span class="built_in">begin</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;*l.<span class="built_in">before_begin</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;*l.<span class="built_in">end</span>()&lt;&lt;endl;</span><br><span class="line">l.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;&amp;*l.<span class="built_in">begin</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;*l.<span class="built_in">before_begin</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;*l.<span class="built_in">end</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x8</span></span><br><span class="line"><span class="comment">0x7ff7b93b5900</span></span><br><span class="line"><span class="comment">0x8</span></span><br><span class="line"><span class="comment">0x600003bf4048</span></span><br><span class="line"><span class="comment">0x7ff7b93b5900</span></span><br><span class="line"><span class="comment">0x8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span> <span class="params">(size_type n, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If <em>n</em> is smaller than the current number of elements in the container, the content is trimmed to contain only its <strong>first <em>n</em> elements</strong>, removing those beyonf (and destroying them).</p>
<p>If <em>n</em> is greater than the current number of elements in the container, the content is expanded by inserting at the end as many elements as needed to reach a size of <em>n</em> elements. If <em>val</em> is specified, the new elements are initialized as copies of <em>val</em>, otherwise, they are <strong>value-initialized.</strong></p>
<h3 id="splice-after"><a href="#splice-after" class="headerlink" title="splice_after"></a>splice_after</h3><table>
<thead>
<tr>
<th align="right">entire list (1)</th>
<th><strong><code>void splice_after (const_iterator position, forward_list&amp; fwdlst); void splice_after (const_iterator position, forward_list&amp;&amp; fwdlst); </code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="right">single element (2)</td>
<td><code>void splice_after (const_iterator position, forward_list&amp; fwdlst, const_iterator i); </code><br /><code>void splice_after (const_iterator position, forward_list&amp;&amp; fwdlst, const_iterator i);</code></td>
</tr>
<tr>
<td align="right">element range (3)</td>
<td><code>void splice_after (const_iterator position, forward_list&amp; fwdlst,                   const_iterator first, const_iterator last); </code><br /><code>void splice_after (const_iterator position, forward_list&amp;&amp; fwdlst,                   const_iterator first, const_iterator last);</code></td>
</tr>
</tbody></table>
<p>Transfers elements from <em>fwdlst</em> into the container inserting them <strong>after the element pointed by <em>position</em>.</strong></p>
<p>This effectively inserts those elements into the container and removes them from <em>fwdlst</em>, <strong>altering the sizes of both containers</strong>. The operation does not involve the construction or destruction of any element. They are transferred, no matter whether <em>fwdlst</em> is an lvalue or an rvalue, or whether the <code>value_type</code> supports move-construction or not.</p>
<p>The <em>first version (1)</em> transfers all the elements of <em>fwdlst</em> into the container.<br>The <em>second version (2)</em> transfers only the element pointed by <em>i</em> from <em>fwdlst</em> into the container.<br>The <em>third version (3)</em> transfers the range <code>(first,last)</code> from <em>fwdlst</em> into the container.</p>
<h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Removes from the container all the elements that compare equal to <em>val</em>. This calls the destructor of these objects and reduces the container size by the number of elements removed.</p>
<h3 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt; <span class="function"><span class="type">void</span> <span class="title">remove_if</span> <span class="params">(Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Removes from the container all the elements for which <em>Predicate pred</em> returns <code>true</code>. This calls the destructor of these objects and reduces the container size by the number of elements removed.</p>
<p>Predicate should be function or class with () overloaded</p>
<h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><table>
<thead>
<tr>
<th align="right">(1)</th>
<th><code>void unique(); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">(2)</td>
<td><code>template &lt;class BinaryPredicate&gt;  void unique (BinaryPredicate binary_pred);</code></td>
</tr>
</tbody></table>
<p>The version with no parameters <em>(1)</em>, removes all but the first element from every consecutive group of equal elements in the container.Thus, this function is especially useful for sorted lists.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">forward_list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">l.<span class="built_in">unique</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : l)</span><br><span class="line">  cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 2 3 4 2 1</span></span><br></pre></td></tr></table></figure>

<p>for (2), notice that the function will call <code>binary_pred(*i,*(i-1))</code> for all pairs of elements (where <code>i</code> is an iterator to an element, starting from the second) and remove <code>i</code> from the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/forward_list">forward_list</a> if the predicate returns <code>true</code>.</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><table>
<thead>
<tr>
<th align="right">(1)</th>
<th><code> void merge (forward_list&amp; fwdlst);</code><br /><code>void merge (forward_list&amp;&amp; fwdlst);</code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">(2)</td>
<td><code>template &lt;class Compare&gt;  void merge (forward_list&amp; fwdlst, Compare comp); </code><br /><code>template &lt;class Compare&gt;  void merge (forward_list&amp;&amp; fwdlst, Compare comp);</code></td>
</tr>
</tbody></table>
<p>Merges <em>x</em> into the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/forward_list">forward_list</a> by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in <em>x</em> (which becomes <a target="_blank" rel="noopener" href="https://www.cplusplus.com/forward_list::empty">empty</a>), and inserts them into their ordered position within container</p>
<p>The template versions with two parameters (2), have the same behavior, but take a specific predicate (<em>comp</em>) to perform the comparison operation between elements. This comparison shall produce a <em>strict weak ordering</em> of the elements.</p>
<blockquote>
<p><em>strict weak ordering</em></p>
<p>&#x3D;&#x3D; equeals !(a&lt;b) &amp;&amp; !(b&lt;a)</p>
</blockquote>
<p>This function requires that the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/forward_list">forward_list</a> containers have their elements already ordered by value (or by <em>comp</em>) before the call. For an alternative on unordered lists, see <a target="_blank" rel="noopener" href="https://www.cplusplus.com/list::splice">list::splice</a>.</p>
<p>Assuming such ordering, each element of <em>x</em> is inserted at the position that corresponds to its value according to the <em>strict weak ordering</em> defined by <code>operator&lt;</code> or <em>comp</em>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">forward_list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; l2&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">0</span>&#125;;</span><br><span class="line">l.<span class="built_in">sort</span>();</span><br><span class="line">l2.<span class="built_in">sort</span>();</span><br><span class="line">l.<span class="built_in">merge</span>(l2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : l)</span><br><span class="line">  cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//0 1 1 2 2 2 3 4 10 13 20</span></span><br><span class="line"></span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; l2&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">0</span>&#125;;</span><br><span class="line">l.<span class="built_in">merge</span>(l2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : l)</span><br><span class="line">  cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 2 3 4 2 1 10 20 13 0</span></span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><table>
<thead>
<tr>
<th align="right">(1)</th>
<th><code> void sort();</code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">(2)</td>
<td><code>template &lt;class Compare&gt;  void sort (Compare comp);</code></td>
</tr>
</tbody></table>
<p>strict weak ordering, stable, equivalent elements preserve the relative order they had before the call.</p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><blockquote>
<p>special: doubly-linked lists</p>
</blockquote>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><table>
<thead>
<tr>
<th align="right">entire list (1)</th>
<th><code>void splice (const_iterator position, list&amp; x); </code><br /><code>void splice (const_iterator position, list&amp;&amp; x); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">single element (2)</td>
<td><code>void splice (const_iterator position, list&amp; x, const_iterator i);</code><br /><code>void splice (const_iterator position, list&amp;&amp; x, const_iterator i);</code></td>
</tr>
<tr>
<td align="right">element range (3)</td>
<td><code>void splice (const_iterator position, list&amp; x, const_iterator first, const_iterator last); </code><br /><code>void splice (const_iterator position, list&amp;&amp; x, const_iterator first, const_iterator last);</code></td>
</tr>
</tbody></table>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><blockquote>
<p>special: key unique, Internally, the elements in a <code>map</code> are <strong>always sorted</strong> by its <em>key</em> following a specific <em>strict weak ordering</em> criterion indicated by its internal <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map::key_comp">comparison object</a> (of type <code>Compare</code>).</p>
<p>Maps are typically implemented as <em>binary search trees</em>.</p>
<p>begin() returns sorted first element</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><p>If <em>k</em> does not match the key of any element in the container, the function inserts a new element with that key and returns a reference to its mapped value. Notice that this <strong>always increases</strong> the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::size">container size</a> by one, even if no mapped value is assigned to the element (<strong>the element is constructed using its default constructor</strong>).</p>
<h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><table>
<thead>
<tr>
<th align="right">single element (1)</th>
<th><code>pair&lt;iterator,bool&gt; insert (const value_type&amp; val); </code><br /><code>template &lt;class P&gt; pair&lt;iterator,bool&gt; insert (P&amp;&amp; val); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">with hint (2)</td>
<td><code>iterator insert (const_iterator position, const value_type&amp; val);</code><br /><code>template &lt;class P&gt; iterator insert (const_iterator position, P&amp;&amp; val);</code></td>
</tr>
<tr>
<td align="right">range (3)</td>
<td><code>template &lt;class InputIterator&gt;  void insert (InputIterator first, InputIterator last); </code></td>
</tr>
<tr>
<td align="right">initializer list (4)</td>
<td><code>void insert (initializer_list&lt;value_type&gt; il);</code></td>
</tr>
</tbody></table>
<p>Because element keys in a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map">map</a> are unique, the insertion operation <strong>checks</strong> whether each inserted element has a key equivalent to the one of an element already in the container, and if so, the element is not inserted, <strong>returning an iterator to this existing element</strong> (if the function returns a value).</p>
<p>can also just use <code>[]</code></p>
<p>The function optimizes its insertion time if <em>position</em> points to the element that will <strong>follow</strong> the inserted element (or to the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map::end">end</a>, if it would be the last).</p>
<p>Notice that this is just a hint and does not force the new element to be inserted at that position within the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map">map</a> container (the elements in a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map">map</a> always follow a specific order depending on their key).</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4342204/is-there-any-position-limitation-on-the-insert-hint-for-stdmap/4342257">hint</a></p>
<p>Insert with hint is logarithmic in general, but it is amortized constant time if t is inserted immediately before p.</p>
<p>So I’d say hinting on either side gives about the same result, and is always better than no hint at all. Choosing a poor hint position (such as the start) is worse than no hint at all.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;Key,T,Compare,Allocator&gt;::extract</span><br><span class="line"><span class="comment">//return node_type</span></span><br><span class="line"><span class="comment">//parammeter: iterator or key</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//used to change key, normally key is const</span></span><br><span class="line"><span class="comment">//extract, change key, insert(move())</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">char</span>&gt; cont&#123;&#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> print = [](std::pair&lt;<span class="type">const</span> <span class="type">int</span>, <span class="type">char</span>&gt;&amp; n) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&#x27;)&#x27;</span>; </span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Extract node handle and change key</span></span><br><span class="line">    <span class="keyword">auto</span> nh = cont.<span class="built_in">extract</span>(<span class="number">1</span>);</span><br><span class="line">    nh.<span class="built_in">key</span>() = <span class="number">4</span>; </span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After extract and before insert:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Insert node handle back</span></span><br><span class="line">    cont.<span class="built_in">insert</span>(<span class="built_in">move</span>(nh));</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Start: 1(a) 2(b) 3(c)</span></span><br><span class="line"><span class="comment">After extract and before insert: 2(b) 3(c)</span></span><br><span class="line"><span class="comment">End: 2(b) 3(c) 4(a)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>Searches the container for an element with a <em>key</em> equivalent to <em>k</em> and returns an iterator to it if found, otherwise it returns an iterator to <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map::end">map::end</a>.</p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>Searches the container for elements with a key equivalent to <em>k</em> and returns the number of matches.</p>
<p>Because all elements in a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map">map</a> container are unique, the function can only return <em>1</em> (if the element is found) or zero (otherwise).</p>
<h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      <span class="function">iterator <span class="title">lower_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>Returns an iterator pointing to the first element in the container whose key is not considered to go before <em>k</em> (i.e., either it is equivalent or goes after).</p>
<p>&lt;&#x3D;</p>
<h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="function">iterator <span class="title">upper_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>the function returns an iterator to the first element whose key is greater than <em>k</em>.</p>
<p>&gt;</p>
<h3 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;const_iterator,const_iterator&gt; <span class="title">equal_range</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">pair&lt;iterator,iterator&gt;             <span class="title">equal_range</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Returns the bounds of a range that includes all the elements in the container which have a <em>key</em> equivalent to <em>k</em>.</p>
<p>the range returned will contain a single element at most.</p>
<p>If no matches are found, the range returned has a length of zero, with both iterators pointing to the first element that has a key considered to go after <em>k</em> according to the container’s <a target="_blank" rel="noopener" href="https://www.cplusplus.com/map::key_comp">internal comparison object</a> (<a target="_blank" rel="noopener" href="https://www.cplusplus.com/map::key_comp">key_comp</a>).</p>
<p>map.equal_range().first &#x3D;&gt; lower_bound</p>
<p>map.equal_range().second &#x3D;&gt; upper_bound</p>
<p>not found, both upper_bound</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m &#123;&#125;;</span><br><span class="line">m[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">m[<span class="string">&quot;e&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">m[<span class="string">&quot;w&quot;</span>] = <span class="number">4</span>;</span><br><span class="line">cout&lt;&lt; m.<span class="built_in">equal_range</span>(<span class="string">&quot;e&quot;</span>).first-&gt;first &lt;&lt; m.<span class="built_in">equal_range</span>(<span class="string">&quot;e&quot;</span>).second-&gt;first &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; m.<span class="built_in">equal_range</span>(<span class="string">&quot;f&quot;</span>).first-&gt;first &lt;&lt; m.<span class="built_in">equal_range</span>(<span class="string">&quot;f&quot;</span>).second-&gt;first &lt;&lt;endl;</span><br><span class="line"><span class="comment">//ew</span></span><br><span class="line"><span class="comment">//ww</span></span><br></pre></td></tr></table></figure>

<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><blockquote>
<p>multiple elements can have equivalent keys.</p>
<p>use equal_range to get all pairs for certain key</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">multi_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">map.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">map.<span class="built_in">erase</span>(key);</span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><blockquote>
<p>special:</p>
<p>Internally, the elements in the <code>unordered_map</code> are not sorted in any particular order with respect to either their <em>key</em> or <em>mapped</em> values, but organized into <strong><em>buckets</em> depending on their hash values</strong> to allow for fast access to individual elements directly by their <em>key values</em> (with a constant average time complexity on average).</p>
</blockquote>
<h3 id="bucket"><a href="#bucket" class="headerlink" title="bucket"></a>bucket</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">bucket</span> <span class="params">( <span class="type">const</span> key_type&amp; k )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>Returns the bucket number where the element with key <em>k</em> is located.</p>
<p>A bucket is a slot in the container’s internal hash table to which elements are assigned based on the hash value of their key. Buckets are numbered from <code>0</code> to <code>(bucket_count-1)</code>.</p>
<p>Individual elements in a bucket can be accessed by means of the range iterators returned by <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::begin">unordered_map::begin</a> and <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::end">unordered_map::end</a>.</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><blockquote>
<p>hash container in stl:</p>
<ul>
<li><code>unordered_map</code></li>
<li><code>unordered_set</code></li>
<li><code>unordered_multimap</code></li>
<li><code>unordered_multiset</code></li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17016175/c-unordered-map-using-a-custom-class-type-as-the-key">hash function for customed class</a></p>
<p>To be able to use <code>std::unordered_map</code> (or one of the other unordered associative containers) with a user-defined key-type, you need to define two things:</p>
<ol>
<li>A <strong>hash function</strong>; this must be a class that overrides <code>operator()</code> and calculates the hash value given an object of the key-type. One particularly straight-forward way of doing this is to specialize the <code>std::hash</code> template for your key-type.</li>
<li>A <strong>comparison function for equality</strong>; this is required because the hash cannot rely on the fact that the hash function will always provide a unique hash value for every distinct key (i.e., it needs to be able to deal with collisions), so it needs a way to compare two given keys for an exact match. You can implement this either as a class that overrides <code>operator()</code>, or as a specialization of <code>std::equal</code>, or – easiest of all – by overloading <code>operator==()</code> for your key type (as you did already).</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Key</span></span><br><span class="line">&#123;</span><br><span class="line">  std::string first;</span><br><span class="line">  std::string second;</span><br><span class="line">  <span class="type">int</span>         third;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Key &amp;other) <span class="type">const</span></span><br><span class="line">  &#123; <span class="built_in">return</span> (first == other.first</span><br><span class="line">            &amp;&amp; second == other.second</span><br><span class="line">            &amp;&amp; third == other.third);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Key&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Key&amp; k)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">using</span> std::<span class="type">size_t</span>;</span><br><span class="line">      <span class="keyword">using</span> std::hash;</span><br><span class="line">      <span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Compute individual hash values for first,</span></span><br><span class="line">      <span class="comment">// second and third and combine them using XOR</span></span><br><span class="line">      <span class="comment">// and bit shifting:</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ((<span class="built_in">hash</span>&lt;string&gt;()(k.first)</span><br><span class="line">               ^ (<span class="built_in">hash</span>&lt;string&gt;()(k.second) &lt;&lt; <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">               ^ (<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(k.third) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//or just a new function object</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KeyHasher</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Key&amp; k)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::<span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> std::hash;</span><br><span class="line">    <span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">hash</span>&lt;string&gt;()(k.first)</span><br><span class="line">             ^ (<span class="built_in">hash</span>&lt;string&gt;()(k.second) &lt;&lt; <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">             ^ (<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(k.third) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::unordered_map&lt;Key,std::string,KeyHasher&gt; m6 = &#123;</span><br><span class="line">    &#123; &#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="number">12</span>&#125;, <span class="string">&quot;example&quot;</span>&#125;,</span><br><span class="line">    &#123; &#123;<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;Sue&quot;</span>, <span class="number">21</span>&#125;, <span class="string">&quot;another&quot;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="load-factor"><a href="#load-factor" class="headerlink" title="load_factor"></a>load_factor</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">load_factor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>The load factor is the ratio between the number of elements in the container (its <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::size">size</a>) and the number of buckets (<a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket_count</a>)</p>
<p>load_factor &#x3D; <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::size">size</a> &#x2F; <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket_count</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14851249/whats-the-difference-between-the-rehash-and-reserve-methods-of-the-c-unor">see more for difference between rehash and reserve</a></p>
<p>The difference is in <em>purpose</em>, although both are doing something similar.</p>
<ul>
<li><code>rehash</code> takes an existing map and rebuilds a <em>new</em> size of buckets, rehashing in the process and redistributing elements into the new buckets.</li>
<li><code>reserve</code> guarantees you that if you don’t insert more than the reserved number of elements, there will be no rehashing (i.e. your iterators will remain valid).</li>
</ul>
<p>Those are two somewhat different things, albeit related. <code>rehash</code> doesn’t give you any guarantees, and <code>reserve</code> doesn’t express the purpose of rehashing. Use <code>rehash</code> if you think your map is inefficient, and <code>reserve</code> if you’re preparing for a lot of insertions.</p>
<p>As @Xeo points out, <code>reserve</code> is just a wrapper around <code>rehash</code>, though, taking into account the permissible load factor of the map.</p>
</blockquote>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">( size_type n )</span></span>;</span><br></pre></td></tr></table></figure>

<p>Sets the number of buckets in the container to <em>n</em> or more.</p>
<p>If <em>n</em> is greater than the current number of buckets in the container (<a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket_count</a>), a rehash is forced. The new <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket count</a> can either be equal or greater than <em>n</em>.</p>
<p>If <em>n</em> is lower than the current number of buckets in the container (<a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket_count</a>), the function may have no effect on the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket count</a> and may not force a rehash.</p>
<p>A rehash is the reconstruction of the hash table: All the elements in the container are rearranged according to their hash value into the new set of buckets. This may alter the order of iteration of elements within the container.</p>
<p>Rehashes are automatically performed by the container whenever its <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::load_factor">load factor</a> is going to surpass its <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::max_load_factor">max_load_factor</a> in an operation.</p>
<p>Notice that this function expects the number of buckets as argument. A similar function exists, <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::reserve">unordered_map::reserve</a>, that expects the number of elements in the container as argument.</p>
<h3 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span> <span class="params">( size_type n )</span></span>;</span><br></pre></td></tr></table></figure>

<p>Sets the number of buckets in the container (<a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket_count</a>) to the most appropriate to contain at least <em>n</em> elements.</p>
<p>If <em>n</em> is greater than the current <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket_count</a> multiplied by the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::max_load_factor">max_load_factor</a>, the container’s <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::bucket_count">bucket_count</a> is increased and a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/unordered_map::rehash">rehash</a> is forced.</p>
<p>If <em>n</em> is lower than that, the function may have no effect.</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><blockquote>
<p>special:</p>
<p>unique elements following a specific order.</p>
<p>The value of the elements in a <code>set</code> cannot be modified once in the container (the elements are <strong>always const</strong>), but they can be inserted or removed from the container.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="right">single element (1)</th>
<th><code>pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</code><br /><code>pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);</code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">with hint (2)</td>
<td><code>iterator insert (const_iterator position, const value_type&amp; val);</code><br /><code>iterator insert (const_iterator position, value_type&amp;&amp; val);</code></td>
</tr>
<tr>
<td align="right">range (3)</td>
<td><code>template &lt;class InputIterator&gt;  </code><br /><code>void insert (InputIterator first, InputIterator last); </code></td>
</tr>
<tr>
<td align="right">initializer list (4)</td>
<td><code>void insert (initializer_list&lt;value_type&gt; il);</code></td>
</tr>
</tbody></table>
<p>Extends the container by inserting new elements, effectively increasing the container <a target="_blank" rel="noopener" href="https://www.cplusplus.com/set::size">size</a> by the number of elements inserted.</p>
<p>Because elements in a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/set">set</a> are unique, the insertion operation <strong>checks whether each inserted element is equivalent to an element already in the container,</strong> and if so, the element is not inserted, returning an iterator to this existing element (if the function returns a value).</p>
<p>For a similar container allowing for duplicate elements, see <a target="_blank" rel="noopener" href="https://www.cplusplus.com/multiset">multiset</a>.</p>
<p>Internally, <a target="_blank" rel="noopener" href="https://www.cplusplus.com/set">set</a> containers keep all their elements sorted following the criterion specified by its <a target="_blank" rel="noopener" href="https://www.cplusplus.com/set::key_comp">comparison object</a>. The elements are always inserted in its respective position following this ordering.</p>
<p>The parameters determine how many elements are inserted and to which values they are initialized:</p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><blockquote>
<p>special:</p>
<p>following a specific order, and where multiple elements can have equivalent values.</p>
<p>the elements are always const</p>
</blockquote>
<h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h3><p>数组, 随机访问, 容量扩充两倍, 增删对象时会进行构造和析构操作</p>
<h3 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h3><p>双向链表, 快速增删</p>
<h3 id="deque-1"><a href="#deque-1" class="headerlink" title="deque"></a>deque</h3><p>中央控制器+多个缓冲区, 快速增删, 随机访问, 不支持在中间增删</p>
<h3 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack queue"></a>stack queue</h3><p>list 或 deque</p>
<h3 id="set-multiset-map-multimap"><a href="#set-multiset-map-multimap" class="headerlink" title="set, multiset, map, multimap"></a>set, multiset, map, multimap</h3><p>红黑树, sorted, 查找增删O(logn)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Key</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Allocator = std::allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> set;</span><br></pre></td></tr></table></figure>

<h3 id="unordered-set-unordered-map-and-multi"><a href="#unordered-set-unordered-map-and-multi" class="headerlink" title="unordered_set, unordered_map and multi~"></a>unordered_set, unordered_map and multi~</h3><p>hash 访问最慢是 O(n)</p>
<h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a>find_end</h2><p>Searches the range <code>[first1,last1)</code> for the <strong>last occurrence</strong> of the sequence defined by <code>[first2,last2)</code>, and returns an iterator to its first element, or last1 if no occurrences are found.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2&gt;</span></span><br><span class="line"><span class="function">  ForwardIterator1 <span class="title">find_end</span> <span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ForwardIterator2 first2, ForwardIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first2==last2) <span class="keyword">return</span> last1;  <span class="comment">// specified in C++11</span></span><br><span class="line"></span><br><span class="line">  ForwardIterator1 ret = last1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (first1!=last1)</span><br><span class="line">  &#123;</span><br><span class="line">    ForwardIterator1 it1 = first1;</span><br><span class="line">    ForwardIterator2 it2 = first2;</span><br><span class="line">    <span class="keyword">while</span> (*it1==*it2) &#123;    <span class="comment">// or: while (pred(*it1,*it2)) for version (2)</span></span><br><span class="line">        ++it1; ++it2;</span><br><span class="line">        <span class="keyword">if</span> (it2==last2) &#123; ret=first1; <span class="keyword">break</span>; &#125;<span class="comment">//reserve last occurrence</span></span><br><span class="line">        <span class="keyword">if</span> (it1==last1) <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ++first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of"></a>find_first_of</h2><p>Returns an iterator to the first element in the range <code>[first1,last1)</code> that <strong>matches any of the elements in <code>[first2,last2)</code>.</strong> If no such element is found, the function returns last1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function">  InputIterator <span class="title">find_first_of</span> <span class="params">( InputIterator first1, InputIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ForwardIterator first2, ForwardIterator last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1!=last1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ForwardIterator it=first2; it!=last2; ++it) &#123;</span><br><span class="line">      <span class="keyword">if</span> (*it==*first1)          <span class="comment">// or: if (pred(*it,*first)) for version (2)</span></span><br><span class="line">        <span class="keyword">return</span> first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p>Assigns the value returned by successive calls to gen to the elements in the range <code>[first,last)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Generator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">generate</span> <span class="params">( ForwardIterator first, ForwardIterator last, Generator gen )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    *first = <span class="built_in">gen</span>();</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>Returns true if the <strong>sorted</strong> range <code>[first1,last1)</code> contains all the elements in the <strong>sorted</strong> range <code>[first2,last2)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">includes</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                 InputIterator2 first2, InputIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first2!=last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (first1==last1) || (*first2&lt;*first1) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(*first1&lt;*first2)) ++first2;<span class="comment">//only when *first1==*first2, first2++</span></span><br><span class="line">    ++first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><table>
<thead>
<tr>
<th align="right">default (1)</th>
<th><code>template &lt;class RandomAccessIterator&gt;  void make_heap (RandomAccessIterator first, RandomAccessIterator last); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">custom (2)</td>
<td><code>template &lt;class RandomAccessIterator, class Compare&gt;  void make_heap (RandomAccessIterator first, RandomAccessIterator last, Compare comp );</code></td>
</tr>
</tbody></table>
<p>Rearranges the elements in the range <code>[first,last)</code> in such a way that they form a <em>heap</em>.</p>
<p>A heap is a way to organize the elements of a range that allows for fast retrieval(检索) of the element with the highest value at any moment (with <a target="_blank" rel="noopener" href="https://www.cplusplus.com/pop_heap">pop_heap</a>), even repeatedly, while allowing for fast insertion of new elements (with <a target="_blank" rel="noopener" href="https://www.cplusplus.com/push_heap">push_heap</a>).</p>
<p><strong>The element with the highest value is always pointed by first.</strong> The order of the other elements depends on the particular implementation, but it is consistent throughout all heap-related functions of this header.</p>
<p>The elements are compared using <code>operator&lt;</code> (for the first version), or comp (for the second): The element with the highest value is an element for which this would return <code>false</code> when compared to every other element in the range.</p>
<p>The standard container adaptor <a target="_blank" rel="noopener" href="https://www.cplusplus.com/priority_queue">priority_queue</a> calls make_heap, <a target="_blank" rel="noopener" href="https://www.cplusplus.com/push_heap">push_heap</a> and <a target="_blank" rel="noopener" href="https://www.cplusplus.com/pop_heap">pop_heap</a> automatically to maintain <em>heap properties</em> for a container.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6b526aa481b1">see more for heap</a></p>
<p>堆分为两种：<em>最大堆</em>和<em>最小堆</em>，两者的差别在于节点的排序方式。</p>
<p>在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。</p>
<p>如果 <code>i</code> 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent(i) = floor((i - <span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">left(i)   = <span class="number">2i</span> + <span class="number">1</span></span><br><span class="line">right(i)  = <span class="number">2i</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>insert, 插入到数组最后, shift_up</p>
<p>remove, 数组最后替代删除节点, shift_down</p>
</blockquote>
<h3 id="is-partitioned"><a href="#is-partitioned" class="headerlink" title="is_partitioned"></a>is_partitioned</h3><p>Returns <code>true</code> if all the elements in the range <code>[first,last)</code> for which pred returns <code>true</code> precede those for which it returns <code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">UnaryPredicate</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_partitioned</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first!=last &amp;&amp; <span class="built_in">pred</span>(*first)) &#123;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//if first==last, return true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="is-permutation"><a href="#is-permutation" class="headerlink" title="is_permutation"></a>is_permutation</h3><p>Compares the elements in the range <code>[first1,last1)</code> with those in the range beginning at first2, and returns <code>true</code> if all of the elements in both ranges match, even in a different order.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_permutation</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                       InputIterator2 first2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::<span class="built_in">tie</span> (first1,first2) = std::<span class="built_in">mismatch</span> (first1,last1,first2);</span><br><span class="line">  <span class="keyword">if</span> (first1==last1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  InputIterator2 last2 = first2; std::<span class="built_in">advance</span> (last2,std::<span class="built_in">distance</span>(first1,last1));</span><br><span class="line">  <span class="keyword">for</span> (InputIterator1 it1=first1; it1!=last1; ++it1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">find</span>(first1,it1,*it1)==it1) &#123;</span><br><span class="line">      <span class="keyword">auto</span> n = std::<span class="built_in">count</span> (first2,last2,*it1);</span><br><span class="line">      <span class="keyword">if</span> (n==<span class="number">0</span> || std::<span class="built_in">count</span> (it1,last1,*it1)!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">max_element</span> <span class="params">( ForwardIterator first, ForwardIterator last )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first==last) <span class="keyword">return</span> last;</span><br><span class="line">  ForwardIterator largest = first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++first!=last)</span><br><span class="line">    <span class="keyword">if</span> (*largest&lt;*first)    <span class="comment">// or: if (comp(*largest,*first)) for version (2)</span></span><br><span class="line">      largest=first;</span><br><span class="line">  <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="swap-1"><a href="#swap-1" class="headerlink" title="swap"></a>swap</h3><table>
<thead>
<tr>
<th align="right">non-array (1)</th>
<th><code>template &lt;class T&gt; void swap (T&amp; a, T&amp; b)  noexcept (is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_nothrow_move_assignable&lt;T&gt;::value); </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">array (2)</td>
<td><code>template &lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N])  noexcept (noexcept(swap(*a,*b)));</code></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">c</span><span class="params">(std::move(a))</span></span>; a=std::<span class="built_in">move</span>(b); b=std::<span class="built_in">move</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt; <span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(T &amp;a[N], T &amp;b[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;N; ++i) <span class="built_in">swap</span> (a[i],b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><p>An initialized <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object represents an active thread of execution; Such a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object is <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em>, and has a unique <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::get_id">thread id</a></em>.</p>
<p>A default-constructed (non-initialized) <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object is <em>not <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em>, and its <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::get_id">thread id</a></em> is common for all <em>non-<a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em> threads.</p>
<p>A <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em> thread becomes <em>not <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em> if <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::operator=">moved from</a></em>, or if either <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::join">join</a> or <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::detach">detach</a> are called on them.</p>
<h2 id="consturctor"><a href="#consturctor" class="headerlink" title="consturctor"></a>consturctor</h2><table>
<thead>
<tr>
<th align="right">default (1)</th>
<th><code>thread() noexcept; </code></th>
</tr>
</thead>
<tbody><tr>
<td align="right">initialization (2)</td>
<td><code>template &lt;class Fn, class... Args&gt; explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;... args); </code></td>
</tr>
<tr>
<td align="right">copy [deleted] (3)</td>
<td><code>thread (const thread&amp;) = delete; </code></td>
</tr>
<tr>
<td align="right">move (4)</td>
<td><code>thread (thread&amp;&amp; x) noexcept;</code></td>
</tr>
</tbody></table>
<p>(2) initialization constructor</p>
<p>Construct a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object that represents a new <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em> thread of execution.<br>The new thread of execution calls fn passing args as arguments (using <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/decay">decay copies</a></em> of its lvalue or rvalue references).<br>The completion of this construction synchronizes with the beginning of the invocation of this copy of fn.</p>
<p>(3) copy constructor</p>
<p>Deleted constructor form (<a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> objects <strong>cannot be copied</strong>).</p>
<p>(4) move constructor</p>
<p>Construct a <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object that acquires the thread of execution represented by x (if any). This operation does not affect the execution of the moved thread in any way, it simply transfers its handler.<br>The x object no longer represents any thread of execution.</p>
<h2 id="get-id"><a href="#get-id" class="headerlink" title="get_id"></a>get_id</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id get_id() const noexcept;</span><br></pre></td></tr></table></figure>

<p>If the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object is <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em>, the function returns a value that uniquely identifies the thread.</p>
<p>If the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object is <em>not <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em>, the function returns a <em><strong>default-constructed</strong></em> object of member type <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::id">thread::id</a>.</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><h3 id="what’s-join"><a href="#what’s-join" class="headerlink" title="what’s join"></a>what’s join</h3><p>A <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object is joinable if it represents a thread of execution.</p>
<p>A <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object is not joinable in any of these cases:</p>
<ul>
<li>if it was <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::thread">default-constructed</a></em>.</li>
<li>if it has been moved from (either <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::thread">constructing</a></em> another <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object, or <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::operator=">assigning to it</a></em>).</li>
<li>if either of its members <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::join">join</a> or <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::detach">detach</a> has been called.</li>
</ul>
<h3 id="Join-thread"><a href="#Join-thread" class="headerlink" title="Join thread"></a>Join thread</h3><p>当thread::join()函数被调用后，调用它的线程会被block，直到线程的执行被完成。当thread::join()返回时，OS的执行的线程已经完成，C++线程对象可以被销毁。</p>
<p><strong>The function returns when the thread execution has completed.</strong></p>
<p>This synchronizes the moment this function returns with the completion of all the operations in the thread: This blocks the execution of the thread that calls this function until the function called on construction returns (if it hasn’t yet).</p>
<p>After a call to this function, the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object becomes non-<em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em> and can be <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::~thread">destroyed</a></em> safely.</p>
<h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p>Detaches the thread represented by the object from the calling thread, allowing them to execute independently from each other.</p>
<p>Both threads continue without blocking nor synchronizing in any way. Note that when either one ends execution, its resources are released.</p>
<p>After a call to this function, the <a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread">thread</a> object becomes <em>non-<a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::joinable">joinable</a></em> and can be <em><a target="_blank" rel="noopener" href="https://www.cplusplus.com/thread::~thread">destroyed</a></em> safely.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>         <span class="comment">// std::chrono::seconds</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pause_thread</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span> (std::chrono::<span class="built_in">seconds</span>(n));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;pause of &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; seconds ended\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Spawning and detaching 3 threads...\n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">thread</span> (pause_thread,<span class="number">1</span>).<span class="built_in">detach</span>();</span><br><span class="line">  std::<span class="built_in">thread</span> (pause_thread,<span class="number">2</span>).<span class="built_in">detach</span>();</span><br><span class="line">  std::<span class="built_in">thread</span> (pause_thread,<span class="number">3</span>).<span class="built_in">detach</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Done spawning threads.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(the main thread will now pause for 5 seconds)\n&quot;</span>;</span><br><span class="line">  <span class="comment">// give the detached threads time to finish (but not guaranteed!):</span></span><br><span class="line">  <span class="built_in">pause_thread</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Spawning and detaching 3 threads...</span></span><br><span class="line"><span class="comment">Done spawning threads.</span></span><br><span class="line"><span class="comment">(the main thread will now pause for 5 seconds)</span></span><br><span class="line"><span class="comment">pause of 1 seconds ended</span></span><br><span class="line"><span class="comment">pause of 2 seconds ended</span></span><br><span class="line"><span class="comment">pause of 3 seconds ended</span></span><br><span class="line"><span class="comment">pause of 5 seconds ended</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

























</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2022/01/16/stl/">https://sinos_wei.gitee.io/2022/01/16/stl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a><a class="post-meta__tags" href="/tags/stl/">stl</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/IMG_0783.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/16/leetcode/"><img class="prev-cover" src="/img/cover/IMG_2059.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">leetcode</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/12/cpp/"><img class="next-cover" src="/img/cover/IMG_3035.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">cpp 从入门到汇编</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lightmanwei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lightmanwei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#global-function"><span class="toc-number">1.</span> <span class="toc-text">global function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#remove"><span class="toc-number">1.1.</span> <span class="toc-text">remove</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#move-forward"><span class="toc-number">1.2.</span> <span class="toc-text">move forward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator"><span class="toc-number">1.3.</span> <span class="toc-text">iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rbegin"><span class="toc-number">1.3.1.</span> <span class="toc-text">rbegin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#container"><span class="toc-number">2.</span> <span class="toc-text">container</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">2.1.</span> <span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">常用函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">2.2.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">常用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">2.2.2.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear"><span class="toc-number">2.2.3.</span> <span class="toc-text">clear</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#erase"><span class="toc-number">2.2.4.</span> <span class="toc-text">erase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assign"><span class="toc-number">2.2.5.</span> <span class="toc-text">assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-back"><span class="toc-number">2.2.6.</span> <span class="toc-text">push_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop-back"><span class="toc-number">2.2.7.</span> <span class="toc-text">pop_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert"><span class="toc-number">2.2.8.</span> <span class="toc-text">insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap"><span class="toc-number">2.2.9.</span> <span class="toc-text">swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace"><span class="toc-number">2.2.10.</span> <span class="toc-text">emplace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace-back"><span class="toc-number">2.2.11.</span> <span class="toc-text">emplace_back</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque"><span class="toc-number">2.3.</span> <span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#push-front"><span class="toc-number">2.3.1.</span> <span class="toc-text">push_front</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop-front"><span class="toc-number">2.3.2.</span> <span class="toc-text">pop_front</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace-front"><span class="toc-number">2.3.3.</span> <span class="toc-text">emplace_front</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward-list"><span class="toc-number">2.3.4.</span> <span class="toc-text">forward_list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize"><span class="toc-number">2.3.5.</span> <span class="toc-text">resize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splice-after"><span class="toc-number">2.3.6.</span> <span class="toc-text">splice_after</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-1"><span class="toc-number">2.3.7.</span> <span class="toc-text">remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-if"><span class="toc-number">2.3.8.</span> <span class="toc-text">remove_if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique"><span class="toc-number">2.3.9.</span> <span class="toc-text">unique</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge"><span class="toc-number">2.3.10.</span> <span class="toc-text">merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">2.3.11.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-number">2.3.12.</span> <span class="toc-text">reverse</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-number">2.4.</span> <span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#splice"><span class="toc-number">2.4.1.</span> <span class="toc-text">splice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">2.5.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.5.1.</span> <span class="toc-text">[]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-number">2.5.3.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count"><span class="toc-number">2.5.4.</span> <span class="toc-text">count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lower-bound"><span class="toc-number">2.5.5.</span> <span class="toc-text">lower_bound</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#upper-bound"><span class="toc-number">2.5.6.</span> <span class="toc-text">upper_bound</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equal-range"><span class="toc-number">2.5.7.</span> <span class="toc-text">equal_range</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multimap"><span class="toc-number">2.6.</span> <span class="toc-text">multimap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map"><span class="toc-number">2.7.</span> <span class="toc-text">unordered_map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bucket"><span class="toc-number">2.7.1.</span> <span class="toc-text">bucket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash"><span class="toc-number">2.7.2.</span> <span class="toc-text">hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-factor"><span class="toc-number">2.7.3.</span> <span class="toc-text">load_factor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash"><span class="toc-number">2.7.4.</span> <span class="toc-text">rehash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reserve"><span class="toc-number">2.7.5.</span> <span class="toc-text">reserve</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">2.8.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiset"><span class="toc-number">2.9.</span> <span class="toc-text">multiset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-set"><span class="toc-number">2.10.</span> <span class="toc-text">unordered_set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.11.</span> <span class="toc-text">底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector-1"><span class="toc-number">2.11.1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-1"><span class="toc-number">2.11.2.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque-1"><span class="toc-number">2.11.3.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack-queue"><span class="toc-number">2.11.4.</span> <span class="toc-text">stack queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-multiset-map-multimap"><span class="toc-number">2.11.5.</span> <span class="toc-text">set, multiset, map, multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unordered-set-unordered-map-and-multi"><span class="toc-number">2.11.6.</span> <span class="toc-text">unordered_set, unordered_map and multi~</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#algorithm"><span class="toc-number">3.</span> <span class="toc-text">algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#find-end"><span class="toc-number">3.1.</span> <span class="toc-text">find_end</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-first-of"><span class="toc-number">3.2.</span> <span class="toc-text">find_first_of</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generate"><span class="toc-number">3.3.</span> <span class="toc-text">generate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#includes"><span class="toc-number">3.4.</span> <span class="toc-text">includes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#make-heap"><span class="toc-number">3.5.</span> <span class="toc-text">make_heap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#is-partitioned"><span class="toc-number">3.5.1.</span> <span class="toc-text">is_partitioned</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-permutation"><span class="toc-number">3.5.2.</span> <span class="toc-text">is_permutation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#max-element"><span class="toc-number">3.6.</span> <span class="toc-text">max_element</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#swap-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">swap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#thread"><span class="toc-number">4.</span> <span class="toc-text">thread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#consturctor"><span class="toc-number">4.1.</span> <span class="toc-text">consturctor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-id"><span class="toc-number">4.2.</span> <span class="toc-text">get_id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join"><span class="toc-number">4.3.</span> <span class="toc-text">join</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#what%E2%80%99s-join"><span class="toc-number">4.3.1.</span> <span class="toc-text">what’s join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-thread"><span class="toc-number">4.3.2.</span> <span class="toc-text">Join thread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#detach"><span class="toc-number">4.4.</span> <span class="toc-text">detach</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/ai/" title="ai"><img src="/img/cover/IMG_1882.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ai"/></a><div class="content"><a class="title" href="/2022/12/31/ai/" title="ai">ai</a><time datetime="2022-12-31T12:02:33.691Z" title="Updated 2022-12-31 20:02:33">2022-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/17/tcpip%E8%AF%A6%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="tcpip详解读书笔记"><img src="/img/cover/IMG_3302.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tcpip详解读书笔记"/></a><div class="content"><a class="title" href="/2022/12/17/tcpip%E8%AF%A6%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="tcpip详解读书笔记">tcpip详解读书笔记</a><time datetime="2022-12-30T03:02:34.287Z" title="Updated 2022-12-30 11:02:34">2022-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/24/effective-cpp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="effective_cpp读书笔记"><img src="/img/cover/IMG_3357.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="effective_cpp读书笔记"/></a><div class="content"><a class="title" href="/2022/09/24/effective-cpp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="effective_cpp读书笔记">effective_cpp读书笔记</a><time datetime="2022-12-21T08:23:48.511Z" title="Updated 2022-12-21 16:23:48">2022-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/08/insidecpp/" title="insidecpp"><img src="/img/cover/IMG_3032.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="insidecpp"/></a><div class="content"><a class="title" href="/2022/11/08/insidecpp/" title="insidecpp">insidecpp</a><time datetime="2022-12-21T08:13:03.570Z" title="Updated 2022-12-21 16:13:03">2022-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="http权威指南读书笔记"><img src="/img/cover/IMG_2617.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="http权威指南读书笔记"/></a><div class="content"><a class="title" href="/2022/12/12/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="http权威指南读书笔记">http权威指南读书笔记</a><time datetime="2022-12-21T08:13:03.565Z" title="Updated 2022-12-21 16:13:03">2022-12-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>