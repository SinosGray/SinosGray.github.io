<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cpp 从入门到汇编 | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="简介: cpp 简要指北   mac 下的 c++ 头文件位置 &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX xx.xx.sdk&#x2F;usr&#x2F;include&#x2F;c++">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp 从入门到汇编">
<meta property="og:url" content="https://sinos_wei.gitee.io/2022/01/45f494d95337.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:description" content="简介: cpp 简要指北   mac 下的 c++ 头文件位置 &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX xx.xx.sdk&#x2F;usr&#x2F;include&#x2F;c++">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/00000014.jpg">
<meta property="article:published_time" content="2022-01-11T16:09:19.000Z">
<meta property="article:modified_time" content="2023-08-19T07:30:50.115Z">
<meta property="article:author" content="Sinos">
<meta property="article:tag" content="cppreference">
<meta property="article:tag" content="int">
<meta property="article:tag" content="std">
<meta property="article:tag" content="template">
<meta property="article:tag" content="const">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/00000014.jpg"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="canonical" href="https://sinos_wei.gitee.io/2022/01/45f494d95337.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cpp 从入门到汇编',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-19 15:30:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/00000014.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Sinos_wei's blog"><span class="site-name">Sinos_wei's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">cpp 从入门到汇编</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2023-08-19T07:30:50.115Z" title="Updated 2023-08-19 15:30:50">2023-08-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/language/">language</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cpp 从入门到汇编"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>简介: cpp 简要指北</p>
</blockquote>
<ul>
<li><p>mac 下的 c++ 头文件位置 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX xx.xx.sdk/usr/include/c++</p>
<span id="more"></span></li>
</ul>
<h1 id="inline">inline</h1>
<p>When the program executes the function call instruction the <strong>CPU stores the memory address of the instruction following the function call, copies the arguments of the function on the stack and finally transfers control to the specified function</strong>. The CPU then <strong>executes the function code, stores the function return value in a predefined memory location/register and returns control to the calling function</strong>. This overhead occurs for small functions because execution time of small function is less than the switching time.</p>
<p>Inline function is a function that <strong>is expanded in line when it is called.</strong> When the inline function is called whole code of the inline function gets inserted or substituted at the point of inline function call. This substitution is performed by the <strong>C++ compiler at compile time.</strong> Inline function may increase efficiency if it is small. The syntax for defining the function inline is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline return-type function-name(parameters)</span><br><span class="line">&#123;</span><br><span class="line">    // function code</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>Remember, inlining is only a request to the compiler, not a command. Compiler can ignore the request for inlining. <strong>Compiler may not perform inlining</strong> in such circumstances like: \1) If a function contains a loop. (for, while, do-while) \2) If a function contains static variables. \3) If a function is recursive. \4) If a function return type is other than void, and the return statement doesn’t exist in function body. \5) If a function contains switch or goto statement.</p>
<p><strong>Inline functions provide following advantages:</strong> \1) Function call overhead doesn’t occur. \2) It also saves the overhead of push/pop variables on the stack when function is called. \3) It also saves overhead of a return call from a function. \4) When you inline a function, you may enable compiler to perform context specific optimization on the body of function. Such optimizations are not possible for normal function calls. Other optimizations can be obtained by considering the flows of calling context and the called context. \5) Inline function may be useful (if it is small) for embedded systems because inline can yield less code than the function call preamble and return.</p>
<p><strong>Inline function disadvantages:</strong> \1) The <strong>added variables from the inlined function consumes additional registers</strong>, After in-lining function if variables number which are going to use register increases than they may create overhead on register variable resource utilization. This means that when inline function body is substituted at the point of function call, total number of variables used by the function also gets inserted. So the number of register going to be used for the variables will also get increased. So if after function inlining variable numbers increase drastically then it would surely cause an overhead on register utilization.</p>
<p>\2) If you use too many inline functions then the size of the binary executable file will be large, because of the <strong>duplication of same code</strong>.</p>
<p>\3) Too much inlining can also reduce your <strong>instruction cache hit rate</strong>, thus reducing the speed of instruction fetch from that of cache memory to that of primary memory.</p>
<p>\4) Inline function may increase <strong>compile time</strong> overhead if someone changes the code inside the inline function then all the calling location has to be recompiled because compiler would require to replace all the code once again to reflect the changes, otherwise it will continue with old functionality.</p>
<p>\5) Inline functions may not be useful for many embedded systems. Because in embedded systems code size is more important than speed.</p>
<p>\6) Inline functions might cause <strong>thrashing内存抖动</strong> because inlining might increase size of the binary executable file. Thrashing in memory causes performance of computer to degrade.</p>
<p><strong>Inline function and classes:</strong> It is also possible to define the inline function inside the class. <strong>In fact, all the functions defined inside the class are implicitly inline.</strong> Thus, all the restrictions of inline functions are also applied here. If you need to explicitly declare inline function in the class then just declare the function inside the class and define it outside the class using inline keyword. For example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> s)</span> <span class="comment">// redundant use of inline</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above style is considered as a bad programming style. The best programming style is to just write the prototype of function inside the class and specify it as an inline in the function definition. For example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> s)</span></span>; <span class="comment">// declare the function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">S::square</span><span class="params">(<span class="type">int</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>What is wrong with macro?</strong></p>
<p>C++ compiler <strong>checks the argument types of inline functions and necessary conversions</strong> are performed correctly. Preprocessor macro is not capable for doing this. One other thing is that the <strong>macros are managed by preprocessor and inline functions are managed by C++ compiler.</strong></p>
<p>Remember: It is true that all the functions defined inside the class are implicitly inline and C++ compiler will perform inline call of these functions, <strong>but C++ compiler cannot perform inlining if the function is virtual</strong>. The reason is call to a <strong>virtual function is resolved at runtime instead of compile time.</strong> Virtual means wait until runtime and inline means during compilation, if the compiler doesn’t know which function will be called, how it can perform inlining?</p>
<h1 id="整形提升-integer-promotions"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/conversion">整形提升 Integer Promotions</a></h1>
<p>integer promotion is the implicit conversion of a value of any integer type with <em>rank</em> less or equal to <em>rank</em> of int or of a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/bit_field">bit field</a> of type _Bool, int, signed int, unsigned int, to the value of type int or unsigned int.</p>
<p>If int can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type int. Otherwise the value is converted to unsigned int.</p>
<p>Integer promotions preserve the value, including the sign:</p>
<h1 id="thread"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389140084">thread</a></h1>
<p>本篇主要对<code>C++11</code>中的线程<code>std::thread</code>作全面的梳理和总结，方便以后在工作中参考和使用。</p>
<h2 id="stdthread介绍及示例">1.<code>std::thread</code>介绍及示例</h2>
<p>首先说明一下，对于以前的编译器， 若要使用<code>C++11</code>的特性，编译时要设定参数如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-std=c++11</span><br></pre></td></tr></table></figure>
<p>这里先写一个简单的线程示例程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_one</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_two</span><span class="params">(<span class="type">int</span> num, string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;,name:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">tt</span><span class="params">(thread_one)</span></span>;</span><br><span class="line">    tt.<span class="built_in">join</span>();</span><br><span class="line">    string str = <span class="string">&quot;luckin&quot;</span>;</span><br><span class="line">    <span class="function">thread <span class="title">yy</span><span class="params">(thread_two, <span class="number">88</span>, ref(str))</span></span>;   </span><br><span class="line">      <span class="comment">//这里要注意是以引用的方式调用参数</span></span><br><span class="line">    yy.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码，我们创建了一个<code>tt</code>线程对象，其参数是函数<code>thread_one</code>，创建完成后被执行，<strong><code>tt.join()</code>是等待子线程执行完成之后，主线程才继续执行，此时主线程会释放掉执行完成后的子线程的资源</strong>。</p>
<p>对于线程对象<code>yy</code>，我们传入了调用函数的两个参数，这里在线程<code>yy</code>执行时，主线程不想等待子线程，故<strong>使用了<code>yy.detach()</code>将子线程从主线程中分离出来，这样主线程就对子线程没有控制权了，子线程执行完成后会自己释放掉资源</strong>。</p>
<h2 id="stdthread重要函数梳理">2.<code>std::thread</code>重要函数梳理</h2>
<blockquote>
<p>thread() noexcept：默认构造函数，创建一个空的<code>thread</code>执行对象； explicit thread(Fn&amp;&amp;fn, Args&amp;&amp;...args)：初始化构造函数，创建一个带函数调用参数的<code>thread</code>，这个<strong>线程是可<code>joinable</code>的</strong>； thread(const thread&amp;) = delete：拷贝构造函数被禁用，意味着<code>thread</code>对象不可拷贝构造； thread(thread&amp;&amp; x) noexcept：<strong>移动构造函数</strong>，调用成功之后，<code>x</code>不代表任何<code>thread</code>执行对象；</p>
</blockquote>
<p>其构造函数的使用示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;=====Thread:&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;======&quot;</span> &lt;&lt; endl;</span><br><span class="line">      this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;thread two executing&quot;</span> &lt;&lt; endl;</span><br><span class="line">      ++n;</span><br><span class="line">      this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    thread t1;    <span class="comment">//这是一个空的线程对象，还不是一个线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(f2, ref(n))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(move(t3))</span></span>;    <span class="comment">//t3不再是一个线程</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the result n is:&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thread中几个重要的成员函数">3.<code>thread</code>中几个重要的成员函数</h2>
<ul>
<li><code>get_id()</code>：获取线程的ID，它将返回一个类型为<code>std::thread::id</code>的对象。</li>
<li><code>joinable()</code>：检查线程是否可被<code>join</code>。</li>
</ul>
<p><strong>对于<code>join</code>这里值得注意</strong>：</p>
<p>在任意一个时间点上，线程是可结合<code>joinable</code>或者可分离<code>detached</code>的。<strong>一个可结合线程是可以被其它线程回收资源和杀死结束的，而对于<code>detached</code>状态的线程，其资源不能被其它线程回收和杀死，只能等待线程结束才能由系统自动释放</strong>。由默认构造函数创建的线程是不能被<code>join</code>的；另外，若某个线程已执行完任务，但是没有被<code>join</code>的话，该线程依然会被认为是一个活动的执行线程，因此是可以被<code>join</code>的。</p>
<ul>
<li><code>detach()</code>：将当前线程对象所代表的执行实例与此线程对象分离，使得线程可以单独执行。</li>
<li><code>swap()</code>：交换两个线程对象所代表的底层句柄，参数是两个线程对象；</li>
<li><code>std::this_thread::getid()</code>：获取当前线程的ID；</li>
<li><code>std::this_thread::yield()</code>：当前线程放弃执行，操作系统调度另一线程继续执行；</li>
<li><code>sleep_until()</code>：线程休眠至某个指定的时刻，才被重新唤醒；</li>
<li><code>sleep_for()</code>： 线程休眠某个指定的时间片，才被重新唤醒；</li>
</ul>
<h2 id="thread中的互斥量">4.<code>thread</code>中的互斥量</h2>
<p>在多个线程同时访问共享资源时，就需要对资源进行加锁互斥访问，<code>thread</code>提供了四种不同的互斥量：</p>
<ul>
<li><strong>独占式互斥量</strong>：<code>std::mutex</code> 。独占工互斥量加解锁是成对的，同一个线程内独占式互斥量在没有解锁的情况下，再次对其加锁是不正确的，会得到一个未定义的行为。</li>
<li><strong>递归式互斥量</strong>：<code>std::recursive_mutex</code>。递归式互斥量是在同一个线程内互斥量没有解锁的情况下可以再次对其加锁，但其加解锁的次数需要保持一致。这种互斥量平时用得比较少。</li>
<li>允许超时的独占式互斥量：<code>std::timed_mutex</code></li>
<li>允许超时的递归式互斥量：<code>std::recursive_timed_mutex</code></li>
</ul>
<p>下面的代码示例了独占式互斥量的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_num = <span class="number">0</span>;</span><br><span class="line">mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    g_num = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread1:&quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">    g_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock_guard&lt;mutex&gt;<span class="built_in">lg</span>(g_mutex);   <span class="comment">//用这种方式更安全</span></span><br><span class="line">    g_num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread2:&quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若线程1对共享资源的访问时间较长，这时线程2可能等不了那么久，故设定一个超时时间 ，在超时时间内若线程1中的互斥量还没有解锁，线程2就不等了，继续向下执行，这就是允许超时的互斥量。对于允许超时的互斥量，我们需要用<code>unique_lock</code>来包装。</p>
<p>下面代码示例了允许超时的互斥量的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">timed_mutex g_timed_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;timed_mutex&gt; <span class="title">t1</span><span class="params">(g_timed_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;timed_mutex&gt; <span class="title">t1</span><span class="params">(g_timed_mutex, chrono::milliseconds(<span class="number">1000</span>))</span></span>;<span class="comment">//设置超时时间为1秒</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">100</span>);   <span class="comment">//让线程1先启动</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>本文到此结束！</p>
<h1 id="virtual-function-in-compiling"><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3211262/what-does-a-compiled-c-class-look-like">virtual function in compiling</a></h1>
<blockquote>
<p>three steps:</p>
<p>create vtb, declare vp, assign vp in constructor</p>
</blockquote>
<p>The classes are (more or less) constructed as regular structs. The methods are (more or less...) <strong>converted into functions which first parameter is "this". References to the class variables are done as an offset to "this".</strong></p>
<p>As far as inheritance, lets quote from the C++ FAQ LITE, which is mirrored here http://www.parashift.com/c++-faq-lite/virtual-functions.html#faq-20.4 . This chapter shows how Virtual functions are called in the real hardware (what does the compile make in machine code.)</p>
<p>Let's work an example. Suppose class Base has 5 virtual functions: <code>virt0()</code> through <code>virt4()</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Your original C++ source code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> arbitrary_return_type <span class="title">virt0</span><span class="params">(...arbitrary params...)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> arbitrary_return_type <span class="title">virt1</span><span class="params">(...arbitrary params...)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> arbitrary_return_type <span class="title">virt2</span><span class="params">(...arbitrary params...)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> arbitrary_return_type <span class="title">virt3</span><span class="params">(...arbitrary params...)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> arbitrary_return_type <span class="title">virt4</span><span class="params">(...arbitrary params...)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Step #1</strong>: the compiler builds a <strong>static table containing 5 function-pointers</strong>, burying that table into static memory somewhere. Many (not all) compilers define this table while compiling the .cpp that defines Base's first non-inline virtual function. We call that table the <strong>v-table</strong>; let's pretend its technical name is <code>Base::__vtable</code>. If a function pointer fits into one machine word on the target hardware platform, <code>Base::__vtable</code> will end up consuming 5 hidden words of memory. Not 5 per instance, not 5 per function; just 5. It might look something like the following pseudo-code(伪代码):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pseudo-code (not C++, not C) for a static table defined within file Base.cpp</span></span><br><span class="line"><span class="comment">// Pretend FunctionPtr is a generic pointer to a generic member function</span></span><br><span class="line"><span class="comment">// (Remember: this is pseudo-code, not C++ code)</span></span><br><span class="line">FunctionPtr Base::__vtable[<span class="number">5</span>] = &#123;</span><br><span class="line">  &amp;Base::virt0, &amp;Base::virt1, &amp;Base::virt2, &amp;Base::virt3, &amp;Base::virt4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Step #2</strong>: the compiler adds a <strong>hidden pointer</strong> (typically also a machine-word) to each <strong>object of class Base</strong>. This is called the <strong>v-pointer</strong>. Think of this hidden pointer as a hidden data member, as if the compiler rewrites your class to something like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Your original C++ source code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  FunctionPtr* __vptr;  ← supplied by the compiler, hidden from the programmer</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Step #3</strong>: the compiler <strong>initializes <code>this-&gt;__vptr</code> within each constructor</strong>. The idea is to cause each object's v-pointer to point at its class's v-table, as if it adds the following instruction in each constructor's init-list:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base::<span class="built_in">Base</span>(...arbitrary params...)</span><br><span class="line">  : __vptr(&amp;Base::__vtable[<span class="number">0</span>])  ← supplied by the compiler, hidden from the programmer</span><br><span class="line">  ...</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now let's work out a derived class. Suppose your C++ code defines class Der that inherits from class Base. The compiler repeats steps #1 and #3 (but not #2). In step #1, the compiler creates a hidden v-table, keeping the same function-pointers as in <code>Base::__vtable</code> but <strong>replacing those slots that correspond to overrides</strong>. For instance, if Der overrides <code>virt0()</code> through <code>virt2()</code> and inherits the others as-is, Der's v-table might look something like this (pretend Der doesn't add any new virtuals):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pseudo-code (not C++, not C) for a static table defined within file Der.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pretend FunctionPtr is a generic pointer to a generic member function</span></span><br><span class="line"><span class="comment">// (Remember: this is pseudo-code, not C++ code)</span></span><br><span class="line">FunctionPtr Der::__vtable[<span class="number">5</span>] = &#123;</span><br><span class="line">  &amp;Der::virt0, &amp;Der::virt1, &amp;Der::virt2, &amp;Base::virt3, &amp;Base::virt4</span><br><span class="line">&#125;;                                        </span><br></pre></td></tr></table></figure>
<p>In step #3, the compiler adds a similar pointer-assignment at the beginning of each of Der's constructors. The idea is to change each Der object's v-pointer so it points at its class's v-table. (This is not a second v-pointer; it's the same v-pointer that was defined in the base class, Base; remember, the compiler does not repeat step #2 in class Der.)</p>
<p>Finally, let's see how the compiler implements a call to a virtual function. Your code might look like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Your original C++ code</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mycode</span><span class="params">(Base* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p-&gt;<span class="built_in">virt3</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The compiler has no idea whether this is going to call <code>Base::virt3()</code> or <code>Der::virt3()</code> or perhaps the <code>virt3()</code> method of another derived class that doesn't even exist yet. It only knows for sure that you are calling <code>virt3()</code> which happens to be the function in slot #3 of the v-table. It rewrites that call into something like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pseudo-code that the compiler generates from your C++</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mycode</span><span class="params">(Base* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p-&gt;__vptr[<span class="number">3</span>](p);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr />
<p>I strongly recommend every C++ developer to read the FAQ. It might take several weeks (as it's hard to read and long) but it will teach you a lot about C++ and what can be done with it.</p>
<h1 id="连续声明">连续声明</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Paddle* p1, * p2;</span><br></pre></td></tr></table></figure>
<p>指针!</p>
<h1 id="class-and-typename">class and typename</h1>
<ul>
<li><p>in template they are the same</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">/* class or function declaration */</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;    <span class="comment">/* class or function declaration */</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>typename unique</p>
<p>由于 C++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 <code>Type::foo</code> 的写法具体指的是一个类型还是类内成员。</p></li>
<li><p>class unique</p>
<p>?</p></li>
</ul>
<h1 id="class-memory-layout"><a target="_blank" rel="noopener" href="https://www.programmerall.com/article/1953260633/">class memory layout</a></h1>
<p><strong>Elements in Class</strong></p>
<ol start="0" type="1">
<li>Member variables<br />
</li>
<li>Member function<br />
</li>
<li>Static member variable<br />
</li>
<li>Static member function<br />
</li>
<li>Virtual function<br />
</li>
<li>Pure virtual function</li>
</ol>
<p><strong>Factors affecting object size</strong></p>
<ol start="0" type="1">
<li><strong>Member variables</strong><br />
</li>
<li>**Virtual function table pointer (_vftptr)**<br />
</li>
<li>**Virtual base table pointer**（_vbtptr）****<br />
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kekec/archive/2012/10/31/2748955.html">Memory alignment</a></strong></li>
</ol>
<p>A plain (non <code>virtual</code>) member function is just like a C function (except that it has <code>this</code> as an implicit, often first, parameter). For example your <code>getA</code> method is implemented like the following C function (outside of the object, e.g. in the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Code_segment">code segment</a> of the binary executable) :</p>
<p>A <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Virtual_function">virtual member function</a> is generally implemented thru a <em>vtable</em> (<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a>). An object with some virtual member functions (including destructor) has generally as its first (implicit) member field a pointer to such a table (generated elsewhere by the compiler).</p>
<h2 id="single-class">Single class</h2>
<p>(1). <strong>Empty</strong> class</p>
<figure>
<img src="https://www.programmerall.com/images/785/e7/e737e5eb9a1c03ff81c9e04e70c32a81.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>sizeof(CNull)=1（Used to identify the object）</p>
<p>(2). Class with only <strong>member variables</strong></p>
<figure>
<img src="https://www.programmerall.com/images/408/de/dea7e81d5b7972d759cccc5da7f88478.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nVarSize = sizeof(CVariable) = 12</p>
<figure>
<img src="https://www.programmerall.com/images/129/14/14959f5ed9b3f3e9a5106169d2547209.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/820/c7/c76f79fd497923d9b5d377591ef4e804.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>(3). Classes with <strong>only virtual functions</strong></p>
<figure>
<img src="https://www.programmerall.com/images/130/27/274775992046eccf696cb609eafcdaf2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nVFuntionSize = sizeof(CVFuction) = 4 (virtual table pointer)</p>
<figure>
<img src="https://www.programmerall.com/images/302/9d/9d317cdcaa5b510d03529b341031a956.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/128/ac/ac58a7dd9d3b88dfe416c7b770a4bb50.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>(4). Classes with <strong>member variables and virtual functions</strong></p>
<figure>
<img src="https://www.programmerall.com/images/572/a0/a010936b8c9773211780b86f48773404.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nParentSize = sizeof(CParent) = 8</p>
<figure>
<img src="https://www.programmerall.com/images/465/fd/fd9fc47b84bf351085ba51338b854451.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/563/95/952f09c0147c160ab2c4a4b5dc4ef16b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="single-inheritance">Single inheritance</h2>
<p>(including member variables, virtual functions, and virtual function coverage)</p>
<figure>
<img src="https://www.programmerall.com/images/463/63/637fd62d36bca5ad4de15057a7868faf.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nChildSize = sizeof(CChildren) = 12</p>
<p>The result displayed in vc (Note: There is also a virtual function CChildren::g1 that is not displayed):</p>
<figure>
<img src="https://www.programmerall.com/images/281/2c/2c830db2a2dcf19b468848f786904069.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/417/c3/c3ab0cf99399434a3a5c5597e59220f1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="multiple-inheritan">Multiple inheritan</h2>
<p>(including member variables, virtual functions, and virtual function coverage)</p>
<figure>
<img src="https://www.programmerall.com/images/841/ef/ef1a3a8b9024df6ecf162d29188de151.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nChildSize = sizeof(CChildren) = 20</p>
<p>The result displayed in vc (Note: There are two virtual functions CChildren::f2, CChildren::h2 is not displayed,this Pointer <strong>adjustor</strong>[Adjusted value] Did not print out):</p>
<figure>
<img src="https://www.programmerall.com/images/577/c8/c8c325fef2beb55ccac85749d915e8a9.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/482/74/740ccc3c414613726d1db0580fc3a8f2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="inheritance-with-a-depth-of-2">Inheritance with a depth of 2</h2>
<p>(including member variables, virtual functions, and virtual function coverage)</p>
<figure>
<img src="https://www.programmerall.com/images/501/38/383f54f27decf91277086e6652af8c4d.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nGrandSize = sizeof(CGrandChildren) = 24</p>
<p>The result displayed in vc (note: there are three virtual functions CGrandChildren::f2, CChildren::h2, CGrandChildren::f3 are not displayed,thisPointer<strong>adjustor</strong>[Adjusted value] Did not print out):</p>
<figure>
<img src="https://www.programmerall.com/images/160/62/62a008de8fedc9d4319acf0342aaf0c8.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/628/44/445528602bc7a24ece6a57ec1ec4fd94.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="repeated-inheritance">Repeated inheritance</h2>
<p>(including member variables, virtual functions, and virtual function coverage)</p>
<figure>
<img src="https://www.programmerall.com/images/357/9d/9de5e626ef9f14eb6a2cf25960fe015d.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nGrandSize = sizeof(CGrandChildren) = 28</p>
<figure>
<img src="https://www.programmerall.com/images/701/d7/d7ac32dcd9aad3cd190e6aa5567f852d.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/519/a3/a3f697becdc21542f80c4bd6bc850d5f.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Since there are two copies of m_nAge in the content, we cannot directly access this variable through pGrandChildrenA-&gt;m_nAge,</p>
<p>There will be ambiguity in this way, the compiler cannot know that it should accessCChildren1M_nAge in, orCChildren2M_nAge in.</p>
<p>In order to identify the unique m_nAge, you need to <strong>bring the class name of its scope</strong>. as follows:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> pGrandChildrenA-&gt;CChildren1::m_nAge = <span class="number">1</span>;</span><br><span class="line"><span class="number">2</span> pGrandChildrenA-&gt;CChildren2::m_nAge = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="single-virtual-inheritance">Single virtual inheritance</h2>
<blockquote>
<h3 id="the-diamond-problemwhat-is-virtual-inheritance">The diamond problem(what is virtual inheritance)</h3>
<p><em>Virtual inheritance</em> is a C++ technique that ensures that only one copy of a base class’s member variables are inherited by second-level derivatives (a.k.a. grandchild derived classes). Without virtual inheritance, if two classes B and C inherit from class A, and class D inherits from both B and C, then D will contain two copies of A’s member variables: one via B, and one via C. These will be accessible independently, using scope resolution.</p>
<p><strong>Instead, if classes B and C inherit virtually from class A, then objects of class D will contain only one set of the member variables from class A.</strong></p>
<p>As you probably guessed, this technique is useful when you have to deal with multiple inheritance and it’s a way to solve the infamous diamond inheritance.</p>
</blockquote>
<p>(including member variables, virtual functions, and virtual function coverage)</p>
<figure>
<img src="https://www.programmerall.com/images/309/fa/fa03df3f4df6647d00fb266caddf236d.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nChildSize = sizeof(CChildren) = 20</p>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/892/93/932b1f306be323fcb69c19b34985264c.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="multiple-virtual-inheritance">Multiple virtual inheritance</h2>
<p>(including member variables, virtual functions, and virtual function coverage)</p>
<ol type="1">
<li>virtual CParent1, CParent2</li>
</ol>
<figure>
<img src="https://www.programmerall.com/images/646/cb/cbbb0345c42eb7c2ce22540a52bb5386.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nChildSize = sizeof(CChildren) = 24</p>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/262/54/544e4b44be0ec086d33844a6afcf181e.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="2" type="1">
<li>CParent1, virtual CParent2</li>
</ol>
<figure>
<img src="https://www.programmerall.com/images/577/4d/4dd9dcff81dff8a38dc924e5e46dc919.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nChildSize = sizeof(CChildren) = 24</p>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/771/d3/d37a0c66a3119294621f0b068f014f83.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="3" type="1">
<li>virtual CParent1, virtual CParent2</li>
</ol>
<figure>
<img src="https://www.programmerall.com/images/45/25/25019c36b47c9ecc7567c51b816b37dd.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nChildSize = sizeof(CChildren) = 28</p>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/516/ed/ed9f7705303bbc56c83fc2e6239a1f44.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3324721/virtual-tables-and-virtual-pointers-for-multiple-virtual-inheritance-and-type-ca">to see more</a></p>
<h2 id="diamond-virtual-multiple-inheritance">Diamond virtual multiple inheritance</h2>
<p>(including member variables, virtual functions, and virtual function coverage)</p>
<figure>
<img src="https://www.programmerall.com/images/824/2e/2ea97acff318efac0811a600f20d0ad8.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>int nGrandChildSize = sizeof(CGrandChildren) = 36</p>
<p>Memory layout:</p>
<figure>
<img src="https://www.programmerall.com/images/676/21/21aba026ce6774a216e93f7c81690614.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="sizeof">sizeof</h1>
<p>Depending on the computer architecture, a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Byte">byte</a> may consist of 8 <em>or more</em> bits, the exact number being recorded in <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/climits">CHAR_BIT</a>.</p>
<p><strong>sizeof(empty object) = 1</strong></p>
<p><strong>The following <code>sizeof</code> expressions always evaluate to 1:</strong></p>
<ul>
<li><strong>sizeof(char)</strong></li>
<li><strong>sizeof(signed char)</strong></li>
<li><strong>sizeof(unsigned char)</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123; <span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bit</span> &#123; <span class="type">unsigned</span> bit: <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Empty e;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base&amp; b = d;</span><br><span class="line">    [[maybe_unused]] Bit bit;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    std::cout </span><br><span class="line">      &lt;&lt; <span class="string">&quot;1) size of empty class:              &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> e        &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">//1</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;2) size of pointer:                  &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> &amp;e       &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">//8</span></span><br><span class="line"><span class="comment">//    &lt;&lt; &quot;3) size of function:                 &quot; &lt;&lt; sizeof(void())  &lt;&lt; &#x27;\n&#x27; // error</span></span><br><span class="line"><span class="comment">//    &lt;&lt; &quot;4) size of incomplete type:          &quot; &lt;&lt; sizeof(int[])   &lt;&lt; &#x27;\n&#x27; // error</span></span><br><span class="line"><span class="comment">//    &lt;&lt; &quot;5) size of bit field:                &quot; &lt;&lt; sizeof bit.bit  &lt;&lt; &#x27;\n&#x27; // error</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;6) size of Bit class:                &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Bit)     &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">//4</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;7) size of array of 10 int:          &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>[<span class="number">10</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">//40</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;8) size of array of 10 int (2):      &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> a        &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">//40</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;9) length of array of 10 int:        &quot;</span> &lt;&lt; ((<span class="keyword">sizeof</span> a) / (<span class="keyword">sizeof</span> *a))   &lt;&lt; <span class="string">&#x27;\n&#x27;</span><span class="comment">// 10</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;A) length of array of 10 int (2):    &quot;</span> &lt;&lt; ((<span class="keyword">sizeof</span> a) / (<span class="keyword">sizeof</span> a[<span class="number">0</span>])) &lt;&lt; <span class="string">&#x27;\n&#x27;</span><span class="comment">// 10</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;B) size of the Derived:              &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> d        &lt;&lt; <span class="string">&#x27;\n&#x27;</span><span class="comment">// 8</span></span><br><span class="line">      &lt;&lt; <span class="string">&quot;C) size of the Derived through Base: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> b        &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="uml">uml</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/5336514-d05e8edc42eb1469.png?imageMogr2/auto-orient/strip|imageView2/2/w/512/format/webp" alt="img" style="zoom:33%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+表示 public</span><br><span class="line">-表示 private  </span><br><span class="line">#表示 protected </span><br><span class="line">~表示 default,也就是包权限  </span><br><span class="line">_下划线表示 static  </span><br><span class="line">斜体表示抽象  </span><br></pre></td></tr></table></figure>
<p>单向箭头关联 A--&gt;B, A 有 B 类型的指针</p>
<p>虚线箭头依赖 A~~&gt;B, A 依赖于 B</p>
<p>实心箭头组合 A&lt;*&gt;--&gt;B, A 中有(聚合了) B, 且 B 不能独立于 A</p>
<p>空心箭头聚合 A◇--&gt;B, A 中有(聚合了) B, B 能独立于 A</p>
<p>空心箭头继承 A--|&gt;B, A 继承自 B</p>
<p>虚线空心箭头 A~~|&gt;B, A 实现了 B 的接口</p>
<h1 id="initialization">initialization</h1>
<p>Depending on context, the initializer may invoke:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_initialization">Value initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s{}; This is the initialization performed when an object is constructed with an <strong>empty</strong> initializer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">&#125;; <span class="comment">// implicit default constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T2</span>(<span class="type">const</span> T2&amp;) &#123; &#125; <span class="comment">// user-provided copy constructor</span></span><br><span class="line">&#125;;                    <span class="comment">// no default constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T3</span>() &#123; &#125; <span class="comment">// user-provided default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::string s&#123;&#125;; <span class="comment">// class =&gt; default-initialization, the value is &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n&#123;&#125;;                <span class="comment">// scalar =&gt; zero-initialization, the value is 0</span></span><br><span class="line">    <span class="type">double</span> f = <span class="built_in">double</span>();    <span class="comment">// scalar =&gt; zero-initialization, the value is 0.0</span></span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>](); <span class="comment">// array =&gt; value-initialization of each element</span></span><br><span class="line">                            <span class="comment">//          the value of each element is 0</span></span><br><span class="line">    T1 t1&#123;&#125;;                <span class="comment">// class with implicit default constructor =&gt;</span></span><br><span class="line">                            <span class="comment">//     t1.mem1 is zero-initialized, the value is 0</span></span><br><span class="line">                            <span class="comment">//     t1.mem2 is default-initialized, the value is &quot;&quot;</span></span><br><span class="line"><span class="comment">//  T2 t2&#123;&#125;;                // error: class with no default constructor</span></span><br><span class="line">    T3 t3&#123;&#125;;                <span class="comment">// class with user-provided default constructor =&gt;</span></span><br><span class="line">                            <span class="comment">//     t3.mem1 is default-initialized to indeterminate value</span></span><br><span class="line">                            <span class="comment">//     t3.mem2 is default-initialized, the value is &quot;&quot;</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// value-initialization of each element</span></span><br><span class="line">                            <span class="comment">// the value of each element is 0</span></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/direct_initialization">Direct initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s("hello"); Initializes an object from explicit set of constructor arguments.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> mem;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> n)</span> : mem(n) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>; <span class="comment">// constructor from const char*</span></span><br><span class="line">    <span class="function">std::string <span class="title">s2</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// OK: explicit constructors allowed</span></span><br><span class="line"><span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // error: constructor is explicit</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// f is direct-initialized:</span></span><br><span class="line">              <span class="comment">// constructor parameter n is copy-initialized from the rvalue 2</span></span><br><span class="line">              <span class="comment">// f.mem is direct-initialized from the parameter n</span></span><br><span class="line"><span class="comment">//  Foo f2 = 2; // error: constructor is explicit</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f.mem  &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_initialization">Copy initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s = "hello"; Initializes an object from another object.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">12</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;test&quot;</span>;        <span class="comment">// OK: constructor is non-explicit</span></span><br><span class="line">    std::string s2 = std::<span class="built_in">move</span>(s); <span class="comment">// this copy-initialization performs a move</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // error: constructor is explicit</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;  <span class="comment">// OK: direct-initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="number">3.14</span>;    <span class="comment">// floating-integral conversion</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = n; <span class="comment">// const doesn&#x27;t matter</span></span><br><span class="line">    <span class="type">int</span> c = b;       <span class="comment">// ...either way</span></span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    B b0 = <span class="number">12</span>;</span><br><span class="line"><span class="comment">//  B b1 = a;       // &lt; error: conversion from &#x27;A&#x27; to non-scalar type &#x27;B&#x27; requested</span></span><br><span class="line">    B b2&#123;a&#125;;        <span class="comment">// &lt; identical, calling A::operator int(), then B::B(int)</span></span><br><span class="line">    B b3 = &#123;a&#125;;     <span class="comment">// &lt;</span></span><br><span class="line">    <span class="keyword">auto</span> b4 = B&#123;a&#125;; <span class="comment">// &lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  b0 = a;         // &lt; error, assignment operator overload needed </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/list_initialization">List initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s{'a', 'b', 'c'}; Initializes an object from <em>braced-init-list</em>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; mem = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// list-initialization of a non-static member</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; mem2;</span><br><span class="line">    <span class="built_in">Foo</span>() : mem2&#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125; &#123;&#125; <span class="comment">// list-initialization of a member in constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;std::string, std::string&gt; <span class="title">f</span><span class="params">(std::pair&lt;std::string, std::string&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;p.second, p.first&#125;; <span class="comment">// list-initialization in return statement</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n0&#123;&#125;;     <span class="comment">// value-initialization (to zero)</span></span><br><span class="line">    <span class="type">int</span> n1&#123;<span class="number">1</span>&#125;;    <span class="comment">// direct-list-initialization</span></span><br><span class="line">    std::string s1&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;; <span class="comment">// initializer-list constructor call</span></span><br><span class="line">    std::string s2&#123;s1, <span class="number">2</span>, <span class="number">2</span>&#125;;           <span class="comment">// regular constructor call</span></span><br><span class="line">    std::string s3&#123;<span class="number">0x61</span>, <span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">// initializer-list ctor is preferred to (int, char)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n2 = &#123;<span class="number">1</span>&#125;; <span class="comment">// copy-list-initialization</span></span><br><span class="line">    <span class="type">double</span> d = <span class="type">double</span>&#123;<span class="number">1.2</span>&#125;; <span class="comment">// list-initialization of a prvalue, then copy-init</span></span><br><span class="line">    <span class="keyword">auto</span> s4 = std::string&#123;<span class="string">&quot;HelloWorld&quot;</span>&#125;; <span class="comment">// same as above, no temporary created since C++17</span></span><br><span class="line"></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123; <span class="comment">// nested list-initialization</span></span><br><span class="line">           &#123;<span class="number">1</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">           &#123;<span class="number">2</span>, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125; &#125;,</span><br><span class="line">           &#123;<span class="number">3</span>, s1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f</span>(&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;).first <span class="comment">// list-initialization in function call</span></span><br><span class="line">              &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">int</span> <span class="params">(&amp;ar)</span>[2] </span>= &#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// binds a lvalue reference to a temporary array</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; r1 = &#123;<span class="number">1</span>&#125;; <span class="comment">// binds a rvalue reference to a temporary int</span></span><br><span class="line"><span class="comment">//  int&amp; r2 = &#123;2&#125;; // error: cannot bind rvalue to a non-const lvalue ref</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  int bad&#123;1.0&#125;; // error: narrowing conversion</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc1&#123;<span class="number">10</span>&#125;; <span class="comment">// okay</span></span><br><span class="line"><span class="comment">//  unsigned char uc2&#123;-1&#125;; // error: narrowing conversion</span></span><br><span class="line"></span><br><span class="line">    Foo f;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; n0 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; s1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p: m)</span><br><span class="line">        std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n: f.mem)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n: f.mem2)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate initialization</a>, e.g. char a[3] = {'a', 'b'}; Initializes an aggregate from braced-init-list.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s1 = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125; &#125;;</span><br><span class="line">    S s2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// same, but with brace elision 括号省略</span></span><br><span class="line">    S s3&#123;<span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125; &#125;; <span class="comment">// same, using direct-list-initialization syntax</span></span><br><span class="line">    S s4&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// error until CWG 1270:</span></span><br><span class="line">                            <span class="comment">// brace elision only allowed with equals sign</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ar[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// ar is int[3]</span></span><br><span class="line">    <span class="type">int</span> ab[] (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// (C++20) ab is int[3]</span></span><br><span class="line"><span class="comment">//  char cr[3] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;; // too many initializer clauses</span></span><br><span class="line">    <span class="type">char</span> cr[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">// array initialized as &#123;&#x27;a&#x27;, &#x27;\0&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ar2d1[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;; <span class="comment">// fully-braced 2D array: &#123;1, 2&#125;</span></span><br><span class="line">                                        <span class="comment">//                        &#123;3, 4&#125;</span></span><br><span class="line">    <span class="type">int</span> ar2d2[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// brace elision: &#123;1, 2&#125;</span></span><br><span class="line">                                    <span class="comment">//                &#123;3, 4&#125;</span></span><br><span class="line">    <span class="type">int</span> ar2d3[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;;   <span class="comment">// only first column: &#123;1, 0&#125;</span></span><br><span class="line">                                    <span class="comment">//                    &#123;2, 0&#125;</span></span><br><span class="line"></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; std_ar2&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &#125;;  <span class="comment">// std::array is an aggregate</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; std_ar1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// brace-elision okay</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  int ai[] = &#123; 1, 2.0 &#125;; // narrowing conversion from double to int:</span></span><br><span class="line">                           <span class="comment">// error in C++11, okay in C++03</span></span><br><span class="line"></span><br><span class="line">    std::string ars[] = &#123;std::<span class="built_in">string</span>(<span class="string">&quot;one&quot;</span>), <span class="comment">// copy-initialization</span></span><br><span class="line">                         <span class="string">&quot;two&quot;</span>,              <span class="comment">// conversion, then copy-initialization</span></span><br><span class="line">                         &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125; &#125;; <span class="comment">// list-initialization</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* b;</span><br><span class="line">    &#125;;</span><br><span class="line">    U u1 = &#123;<span class="number">1</span>&#125;; <span class="comment">// OK, first member of the union</span></span><br><span class="line"><span class="comment">//  U u2 = &#123; 0, &quot;asdf&quot; &#125;; // error: too many initializers for union</span></span><br><span class="line"><span class="comment">//  U u3 = &#123; &quot;asdf&quot; &#125;; // error: invalid conversion to int</span></span><br><span class="line"></span><br><span class="line">    [](<span class="keyword">auto</span>...) &#123; std::<span class="built_in">puts</span>(<span class="string">&quot;Garbage unused variables... Done.&quot;</span>); &#125; (</span><br><span class="line">        s1, s2, s3, s4, ar, ab, cr, ar2d1, ar2d2, ar2d3, std_ar2, std_ar1, u1</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aggregate</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">base1</span> &#123; <span class="type">int</span> b1, b2 = <span class="number">42</span>; &#125;;</span><br><span class="line"><span class="comment">// non-aggregate</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">base2</span> &#123;</span><br><span class="line">  <span class="built_in">base2</span>() : <span class="built_in">b3</span>(<span class="number">42</span>) &#123;&#125;</span><br><span class="line">  <span class="type">int</span> b3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// aggregate in C++17</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">derived</span> : base1, base2 &#123; <span class="type">int</span> d; &#125;;</span><br><span class="line">derived d1&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123; &#125;, <span class="number">4</span>&#125;; <span class="comment">// d1.b1 = 1, d1.b2 = 2,  d1.b3 = 42, d1.d = 4</span></span><br><span class="line">derived d2&#123; &#123;    &#125;, &#123; &#125;, <span class="number">4</span>&#125;; <span class="comment">// d2.b1 = 0, d2.b2 = 42, d2.b3 = 42, d2.d = 4</span></span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reference_initialization">Reference initialization</a>, e.g. char&amp; c = a[0]; Binds a reference to an object.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> mi;</span><br><span class="line">    <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; mp; <span class="comment">// reference member</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">int</span>&amp;() &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">B</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; bad_r;      // error: no initializer</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span>&amp; ext_r; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  Lvalues</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>&amp; r1 = n;                    <span class="comment">// lvalue reference to the object n</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">cr</span><span class="params">(n)</span></span>;               <span class="comment">// reference can be more cv-qualified</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>&amp; cv&#123;n&#125;;            <span class="comment">// any initializer syntax can be used</span></span><br><span class="line">    <span class="type">int</span>&amp; r2 = r1;                   <span class="comment">// another lvalue reference to the object n</span></span><br><span class="line"><span class="comment">//  int&amp; bad = cr;                  // error: less cv-qualified</span></span><br><span class="line">    <span class="type">int</span>&amp; r3 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(cr); <span class="comment">// const_cast is needed</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (&amp;rf)(<span class="type">int</span>) = foo; <span class="comment">// lvalue reference to function</span></span><br><span class="line">    <span class="type">int</span> ar[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">int</span> (&amp;ra)[<span class="number">3</span>] = ar;     <span class="comment">// lvalue reference to array</span></span><br><span class="line"></span><br><span class="line">    B b;</span><br><span class="line">    A&amp; base_ref = b;        <span class="comment">// reference to base subobject</span></span><br><span class="line">    <span class="type">int</span>&amp; converted_ref = b; <span class="comment">// reference to the result of a conversion</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Rvalues</span></span><br><span class="line"><span class="comment">//  int&amp; bad = 1;        // error: cannot bind lvalue ref to rvalue</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; cref = <span class="number">1</span>; <span class="comment">// bound to rvalue</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; rref = <span class="number">1</span>;      <span class="comment">// bound to rvalue</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> A&amp; cref2 = <span class="built_in">bar</span>(); <span class="comment">// reference to A subobject of B temporary</span></span><br><span class="line">    A&amp;&amp; rref2 = <span class="built_in">bar</span>();      <span class="comment">// same</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp;&amp; xref = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(n); <span class="comment">// bind directly to n</span></span><br><span class="line"><span class="comment">//  int&amp;&amp; copy_ref = n;                 // error: can&#x27;t bind to an lvalue</span></span><br><span class="line">    <span class="type">double</span>&amp;&amp; copy_ref = n;              <span class="comment">// bind to an rvalue temporary with value 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Restrictions on temporary lifetimes</span></span><br><span class="line">    std::ostream&amp; buf_ref = std::<span class="built_in">ostringstream</span>() &lt;&lt; <span class="string">&#x27;a&#x27;</span>; <span class="comment">// the ostringstream temporary</span></span><br><span class="line">                      <span class="comment">// was bound to the left operand of operator&lt;&lt;</span></span><br><span class="line">                      <span class="comment">// but its lifetime ended at the semicolon</span></span><br><span class="line">                      <span class="comment">// so buf_ref is a dangling reference</span></span><br><span class="line"></span><br><span class="line">    S a &#123;<span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>&#125; &#125;;         <span class="comment">// temporary pair &#123;2, 3&#125; bound to the reference member</span></span><br><span class="line">                              <span class="comment">// a.mp and its lifetime is extended to match </span></span><br><span class="line">                              <span class="comment">// the lifetime of object a</span></span><br><span class="line">    S* p = <span class="keyword">new</span> S&#123;<span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>&#125; &#125;; <span class="comment">// temporary pair &#123;2, 3&#125; bound to the reference</span></span><br><span class="line">                              <span class="comment">// member p-&gt;mp, but its lifetime ended at the semicolon</span></span><br><span class="line">                              <span class="comment">// p-&gt;mp is a dangling reference</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="types-in-cpp">types in cpp</h1>
<ul>
<li><p>Object types</p>
<ul>
<li><p>Scalars scalars are primitive objects which contain <strong>a single value</strong> and are not composed of other C++ objects.</p>
<ol type="1">
<li><p>arithmetic (integral, float)</p></li>
<li><p>pointers: <code>T *</code> for any type <code>T</code></p></li>
<li><p>enum</p></li>
<li><p>pointer-to-member</p></li>
<li><p><code>nullptr_t</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">nullptr_t</span> nullp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Passed a null pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>Arrays: <code>T[]</code> or <code>T[N]</code> for any complete, non-reference type <code>T</code></p></li>
<li><p>Classes: <code>class Foo</code> or <code>struct Bar</code></p>
<ol type="1">
<li>Trivial classes</li>
<li>Aggregates</li>
<li>POD classes</li>
<li>(etc. etc.)</li>
</ol></li>
<li><p>Unions: <code>union Zip</code></p></li>
</ul></li>
<li><p>References types: <code>T &amp;</code>, <code>T &amp;&amp;</code> for any object or free-function type <code>T</code></p></li>
<li><p>Function types</p>
<ul>
<li>Free functions: <code>R foo(Arg1, Arg2, ...)</code></li>
<li>Member functions: <code>R T::foo(Arg1, Arg2, ...)</code></li>
</ul></li>
<li><p><code>void</code></p></li>
</ul>
<p>POD-classes, POD-unions, scalar types, and arrays of such types are collectively called <strong><em>POD-types.</em></strong></p>
<h1 id="aggregates-and-podplain-old-data"><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special">aggregates and POD(plain old data)</a></h1>
<h2 id="c03">c++03</h2>
<ul>
<li><p>An aggregate is</p>
<ol type="1">
<li>an array or</li>
<li>a class (clause 9) with <strong>no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).</strong></li>
</ol>
<ul>
<li>An aggregate class can have a user-declared/user-defined copy-assignment operator and/or destructor</li>
<li>An array is an aggregate even if it is an array of non-aggregate class type.</li>
<li>This does not mean an aggregate class cannot have constructors, in fact it can have a default constructor and/or a copy constructor as long as they are <strong>implicitly declared by the compiler</strong>, and not explicitly by the user</li>
</ul></li>
<li><p>aggregate feature</p>
<p>They, unlike non-aggregate classes, can be initialized with curly braces <code>&#123;&#125;</code>.</p>
<p>We should understand that memberwise initialization with braces implies that the class is nothing more than the sum of its members.</p></li>
<li><p>POD</p>
<p>A POD-struct is an aggregate class that has <strong>no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference,</strong> and <strong>has no user-defined copy assignment operator and no user-defined destructor</strong>. Similarly, a POD-union is an aggregate union that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. A POD class is a class that is either a POD-struct or a POD-union.</p>
<p>An aggregate class is called a POD if <strong>it has no user-defined copy-assignment operator and destructor and none of its nonstatic members is a non-POD class, array of non-POD, or a reference</strong>.</p></li>
</ul>
<h2 id="c11">c++11</h2>
<p>A POD struct is a non-union class that is both a trivial class and a standard-layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD struct or a POD union.</p>
<ul>
<li><p>trivial classes</p>
<p>Basically this means that a copy or move constructor is trivial if it is not user-provided, the class has nothing virtual in it, and this property holds recursively for all the members of the class and for the base class.</p></li>
<li><p>standard layout</p>
<p>The standard mentions that these are useful for communicating with other languages, and that's because a standard-layout class has the same memory layout of the equivalent C struct or union.</p></li>
</ul>
<h1 id="const-in-function">const in function</h1>
<p>A "const function", denoted with the keyword <code>const</code> after a function declaration, <strong>makes it a compiler error for this class function to change a member variable of the class</strong>. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error.</p>
<p>Another way of thinking about such "const function" is by viewing a class function as a normal function taking an implicit <code>this</code> pointer. So a method <code>int Foo::Bar(int random_arg)</code> (<strong>without the const</strong> at the end) results in a function like <code>int Foo_Bar(Foo* this, int random_arg)</code>, and a call such as <code>Foo f; f.Bar(4)</code> will internally correspond to something like <code>Foo f; Foo_Bar(&amp;f, 4)</code>. Now adding the const at the end (<code>int Foo::Bar(int random_arg) const</code>) can then be understood as a declaration <strong>with a const this pointer</strong>: <code>int Foo_Bar(const Foo* this, int random_arg)</code>. Since the type of <code>this</code> in such case is const, no modifications of member variables are possible.</p>
<h1 id="const-in-pointer">const in pointer</h1>
<ul>
<li><code>int*</code> - pointer to int</li>
<li><code>int const *</code> - pointer to const int</li>
<li><code>int * const</code> - const pointer to int</li>
<li><code>int const * const</code> - const pointer to const int</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pi1 = &amp;ci;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> pi2 = &amp;i;</span><br><span class="line">*pi1 = <span class="number">2</span>;<span class="comment">//error read only</span></span><br><span class="line">*pi2 = <span class="number">3</span>;</span><br><span class="line">pi2 = &amp;i2;<span class="comment">//error cannot assign</span></span><br><span class="line">pi1 = &amp;i;</span><br><span class="line">*pi1 = <span class="number">2</span>;<span class="comment">//error read only</span></span><br></pre></td></tr></table></figure>
<h1 id="traits"><a target="_blank" rel="noopener" href="https://www.internalpointers.com/post/quick-primer-type-traits-modern-cpp">traits</a></h1>
<p><strong>Type traits</strong> are a clever technique used in C++ template metaprogramming that gives you the ability to inspect and transform the properties of <em>types</em>.</p>
<p>For example, given a generic type <code>T</code> — it could be <code>int</code>, <code>bool</code>, <code>std::vector</code> or whatever you want — with type traits you can ask the compiler some questions: is it an integer? Is it a function? Is it a pointer? Or maybe a class? Does it have a destructor? Can you copy it? Will it throw exceptions? ... and so on. This is extremely useful in <strong>conditional compilation</strong>, where you instruct the compiler to pick the right path according to the type in input. We will see an example shortly.</p>
<p>The beauty of these techniques is that everything takes place at <em>compile time</em> with no runtime penalties: it's template metaprogramming, after all.</p>
<h1 id="typedef-in-stl">typedef in stl</h1>
<p>private 底下的那些，主要就是因为原类型名完整写出来太长，于是取个短名字。</p>
<p>public 底下那些，除了名字长以外，通常还有很重要一个原因：就是标准规定实现某种类型（典型的如容器，比如本例的 std::map），需要对外提供这些类型。最典型如图中的“iterator”和“const_iterator”，就是因为STL中的（正经）容器，需要对外提供“迭代器”类型和“常量迭代器”类型。 这样，当有一天你需要遍历一个 容器，比如map时，你才可以方便地这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( std::map&lt;std::string, <span class="type">int</span>&gt;::const_iterator it = m.<span class="built_in">cbegin</span>(); it != m.<span class="built_in">cend</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>那个 const_iterator 哪来的？就是在 map&lt;K, V&gt; 里定义的那个 typedef 。 链接：https://www.zhihu.com/question/441345616/answer/1699499726</p>
<h1 id="adl-argument-dependent-lookup">ADL argument-dependent lookup</h1>
<p>Argument-dependent lookup, also known as ADL, or Koenig lookup [<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/adl#cite_note-1">1]</a>, is the set of rules for looking up the unqualified function names in <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_other">function-call expressions</a>, including implicit function calls to <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operators">overloaded operators</a>. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lookup">unqualified name lookup</a>.</p>
<p>Argument-dependent lookup makes it possible to use operators defined in a different namespace. Example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test\n&quot;</span>; <span class="comment">// There is no operator&lt;&lt; in global namespace, but ADL</span></span><br><span class="line">                           <span class="comment">// examines std namespace because the left argument is in</span></span><br><span class="line">                           <span class="comment">// std and finds std::operator&lt;&lt;(std::ostream&amp;, const char*)</span></span><br><span class="line">    <span class="keyword">operator</span>&lt;&lt;(std::cout, <span class="string">&quot;Test\n&quot;</span>); <span class="comment">// same, using function call notation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// however,</span></span><br><span class="line">    std::cout &lt;&lt; endl; <span class="comment">// Error: &#x27;endl&#x27; is not declared in this namespace.</span></span><br><span class="line">                       <span class="comment">// This is not a function call to endl(), so ADL does not apply</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">endl</span>(std::cout); <span class="comment">// OK: this is a function call: ADL examines std namespace</span></span><br><span class="line">                     <span class="comment">// because the argument of endl is in std, and finds std::endl</span></span><br><span class="line"></span><br><span class="line">    (endl)(std::cout); <span class="comment">// Error: &#x27;endl&#x27; is not declared in this namespace.</span></span><br><span class="line">                       <span class="comment">// The sub-expression (endl) is not a function call expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dependent-name-name-binding"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent name</a> &amp; name binding</h1>
<p>inside the definition of a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/templates">template</a> (both <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template">class template</a> and <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/function_template">function template</a>), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may <strong>depend on types of type template parameters and values of non-type template parameters.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> : B&lt;T&gt; <span class="comment">// &quot;B&lt;T&gt;&quot; is dependent on T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::A* pa; <span class="comment">// &quot;T::A&quot; is dependent on T</span></span><br><span class="line">                       <span class="comment">// (see below for the meaning of this use of &quot;typename&quot;)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B&lt;T&gt;* pb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> i = B&lt;T&gt;::i; <span class="comment">// &quot;B&lt;T&gt;::i&quot; is dependent on T</span></span><br><span class="line">        pb-&gt;j++; <span class="comment">// &quot;pb-&gt;j&quot; is dependent on T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>name binding</p>
<p>为模板显式或隐式使用的每个名字寻找其声明 的过程称为名字绑定</p>
<p>模板中使用的名字分为依赖性名字 dependent name, 非依赖性名字</p>
<ul>
<li><p>dependent name 依赖于模板参数的名字, 在实例化点完成绑定 默认情况下, 编译器假定 dependent name 不是类型名, 如果需要, 必须用 typename 显式声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fct</span><span class="params">(Container&amp; c)</span></span>&#123;</span><br><span class="line">  Container::value_type v1 = c[<span class="number">7</span>];<span class="comment">//error</span></span><br><span class="line">  <span class="keyword">typename</span> Container::value_type v2 = c[<span class="number">9</span>];<span class="comment">//coorect</span></span><br><span class="line">  <span class="keyword">auto</span> v3 = c[<span class="number">11</span>];<span class="comment">//correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者使用别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Value_type&lt;T&gt; = <span class="keyword">typename</span> T::value_type;</span><br></pre></td></tr></table></figure></li>
<li><p>independent name 不依赖于模板参数的名字, 在定义点完成绑定</p></li>
</ul></li>
</ul>
<h1 id="qualified-name">qualified name</h1>
<p>A <em>qualified</em> name is a name that appears on the right hand side of the scope resolution operator <code>::</code> (see also <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/identifiers#Qualified_identifiers">qualified identifiers</a>).</p>
<h1 id="nested-class">nested class</h1>
<p>A nested class is a class which is declared in another enclosing class. A nested class is a member and as such has the same access rights as any other member.</p>
<h1 id="typename">typename</h1>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords">Where and why do I have to put the "template" and "typename" keywords?</a></p>
<p>(See <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/17579889/4561887">here also for my C++11 answer</a>)</p>
<p>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t * f;</span><br></pre></td></tr></table></figure>
<p>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what <code>t</code> means. If it's a type, then it will be a declaration of a pointer <code>f</code>. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</p>
<blockquote>
<p>Some names denote types or templates. In general, <strong>whenever a name is encountered it is necessary to determine whether that name denotes one of these entities</strong> before continuing to parse the program that contains it. The process that determines this is called <strong>name lookup.</strong></p>
</blockquote>
<p>How will the compiler find out what a name <code>t::x</code> refers to, if <code>t</code> refers to a template type parameter? <code>x</code> could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. <strong>If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a *dependent name* (it "depends" on the template parameters).</strong></p>
<p>You might recommend to just wait till the user instantiates the template:</p>
<blockquote>
<p><em>Let's wait until the user instantiates the template, and then later find out the real meaning of <code>t::x \* f;</code>.</em></p>
</blockquote>
<p>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place.</p>
<p>So there has to be a way to tell the compiler that certain names are types and that certain names aren't.</p>
<h1 id="the-typename-keyword">The "typename" keyword</h1>
<p>The answer is: <em>We</em> decide how the compiler should parse this. If <code>t::x</code> is a dependent name, then we need to prefix it by <code>typename</code> to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</p>
<blockquote>
<p>A name used in a template declaration or definition and that is dependent on a template-parameter <strong>is assumed not to name a type</strong> unless the applicable name lookup finds a type name or the name is qualified by the keyword typename.</p>
</blockquote>
<p>There are many names for which <code>typename</code> is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with <code>T *f;</code>, when <code>T</code> is a type template parameter. But for <code>t::x * f;</code> to be a declaration, it must be written as <code>typename t::x *f;</code>. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// t::x is taken as non-type, but as an expression the following misses an operator between the two names or a semicolon separating them.</span></span><br><span class="line">t::x f;</span><br></pre></td></tr></table></figure>
<p><em>The syntax allows <code>typename</code> only before qualified names</em> - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</p>
<p>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</p>
<h1 id="the-template-keyword">The "template" keyword</h1>
<p>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boost::function&lt; <span class="type">int</span>() &gt; f;</span><br></pre></td></tr></table></figure>
<p>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of <code>boost::function</code> and <code>f</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost &#123; <span class="type">int</span> function = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">  boost::function&lt; <span class="type">int</span>() &gt; f; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That's actually a <strong>valid <em>expression</em></strong>! It uses the less-than operator to compare <code>boost::function</code> against zero (<code>int()</code>), and then uses the greater-than operator to compare the resulting <code>bool</code> against <code>f</code>. However as you might well know, <code>boost::function</code> <a target="_blank" rel="noopener" href="http://www.boost.org/doc/libs/1_54_0/doc/html/function.html">in real life</a> is a template, so the compiler knows (14.2/3):</p>
<blockquote>
<p>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &lt;, the &lt; is always taken as the beginning of a template-argument-list and never as a name followed by the less-than operator.</p>
</blockquote>
<p>Now we are back to the same problem as with <code>typename</code>. What if we can't know yet whether the name is a template when parsing the code? We will need to insert <code>template</code> immediately before the template name, as specified by <code>14.2/4</code>. This looks like:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t::<span class="keyword">template</span> <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// call a function template</span></span><br></pre></td></tr></table></figure>
<p>Template names can not only occur after a <code>::</code> but also after a <code>-&gt;</code> or <code>.</code> in a class member access. You need to insert the keyword there too:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="keyword">template</span> <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// call a function template</span></span><br></pre></td></tr></table></figure>
<h1 id="dependencies">Dependencies</h1>
<p>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</p>
<p>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to <em>depend</em> on template parameters.</p>
<p>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</p>
<ul>
<li>Dependent types (e.g: a type template parameter <code>T</code>)</li>
<li>Value-dependent expressions (e.g: a non-type template parameter <code>N</code>)</li>
<li>Type-dependent expressions (e.g: a cast to a type template parameter <code>(T)0</code>)</li>
</ul>
<p>Most of the rules are intuitive and are built up recursively: For example, a type constructed as <code>T[N]</code> is a dependent type if <code>N</code> is a value-dependent expression or <code>T</code> is a dependent type. The details of this can be read in section <code>(14.6.2/1</code>) for dependent types, <code>(14.6.2.2)</code> for type-dependent expressions and <code>(14.6.2.3)</code> for value-dependent expressions.</p>
<h1 id="dependent-names">Dependent names</h1>
<p>The Standard is a bit unclear about what <em>exactly</em> is a <em>dependent name</em>. On a simple read (you know, the principle of least surprise), all it defines as a <em>dependent name</em> is the special case for function names below. But since clearly <code>T::x</code> also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</p>
<p>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore "dependent names". A name can take different forms - the Standard says:</p>
<blockquote>
<p>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</p>
</blockquote>
<p>An identifier is just a plain sequence of characters / digits, while the next two are the <code>operator +</code> and <code>operator type</code> form. The last form is <code>template-name &lt;argument list&gt;</code>. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</p>
<p>A value dependent expression <code>1 + N</code> is not a name, but <code>N</code> is. The subset of all dependent constructs that are names is called <em>dependent name</em>. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule.</p>
<h1 id="dependent-function-names">Dependent function names</h1>
<p>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example <code>f((T)0)</code>, <code>f</code> is a dependent name. In the Standard, this is specified at <code>(14.6.2/1)</code>.</p>
<h1 id="additional-notes-and-examples">Additional notes and examples</h1>
<p>In enough cases we need both of <code>typename</code> and <code>template</code>. Your code should look like the following</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionNode</span> : <span class="keyword">public</span> Tail &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">struct</span> <span class="title class_">inUnion</span> &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Tail::<span class="keyword">template</span> inUnion&lt;U&gt; dummy;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The keyword <code>template</code> doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> t::<span class="keyword">template</span> iterator&lt;<span class="type">int</span>&gt;::value_type v;</span><br></pre></td></tr></table></figure>
<p>In some cases, the keywords are forbidden, as detailed below</p>
<ul>
<li><p>On the name of a dependent base class you are not allowed to write <code>typename</code>. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">derive_from_Has_type</span> : <span class="comment">/* typename */</span> SomeBase&lt;T&gt;::type </span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>In using-declarations it's not possible to use <code>template</code> after the last <code>::</code>, and the C++ committee <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109">said</a> not to work on a solution.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">derive_from_Has_type</span> : SomeBase&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">using</span> SomeBase&lt;T&gt;::<span class="keyword">template</span> type; <span class="comment">// error</span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">typename</span> SomeBase&lt;T&gt;::type; <span class="comment">// typename *is* allowed</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="size_t"><a target="_blank" rel="noopener" href="https://jeremybai.github.io/blog/2014/09/10/size-t">size_t</a></h1>
<p>每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。</p>
<p>适当地使用size_t还会使你的代码变得如同自带文档。当你看到一个对象声明为size_t类型，你马上就知道它代表字节大小或数组索引，而不是错误代码或者是一个普通的算术值。</p>
<h1 id="compiler-default">compiler default</h1>
<h2 id="default-constructor">default constructor</h2>
<p>If no user-declared constructors of any kind are provided for a class type (struct, class, or union), the compiler will always declare a default constructor as an <code>inline public</code> member of its class.</p>
<p>it has the same effect as a user-defined constructor with <strong>empty body and empty initializer list.</strong></p>
<h2 id="destructor">destructor</h2>
<p>If no user-declared prospective (since C++20)destructor is provided for a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class">class type</a> (struct, class, or union), the compiler will always declare a destructor as an <code>inline public</code> member of its class.</p>
<p>This implicitly-defined destructor has an <strong>empty body.</strong></p>
<h2 id="copy-constructor">copy constructor</h2>
<p>This implicitly-declared copy constructor has the form T::T(const T&amp;) if all of the following are true:</p>
<ul>
<li>each direct and virtual base <code>B</code> of <code>T</code> has a copy constructor whose parameters are const B&amp; or const volatile B&amp;;</li>
<li>each non-static data member <code>M</code> of <code>T</code> of class type or array of class type has a copy constructor whose parameters are const M&amp; or const volatile M&amp;.</li>
</ul>
<p>For non-union class types (class and struct), the constructor performs full member-wise copy of the object's <strong>bases and non-static members</strong>, in their initialization order, using direct initialization.</p>
<h2 id="copy-assignment">copy assignment</h2>
<p>For non-union class types (class and struct), the operator performs member-wise copy assignment of the object's <strong>bases and non-static members</strong>, in their initialization order, using <strong>built-in assignment for the scalars and copy assignment operator for class types</strong>.</p>
<h2 id="move-assignment">move assignment</h2>
<p>For non-union class types (class and struct), the move assignment operator performs full member-wise move assignment of the object's direct <strong>bases and immediate non-static members</strong>, in their declaration order, using <strong>built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types</strong> (called non-virtually).</p>
<h1 id="unix-linux-gnu">UNIX Linux GNU</h1>
<ul>
<li>UNIX 非开源 AT&amp;T</li>
<li>BSD 为 UNIX 一个开源版本</li>
<li>GNU(GNU is not UNIX) 开源软件项目</li>
<li>Linux Linus 写的内核, 属于类 UNIX, 兼容 POSIX</li>
</ul>
<h1 id="运算符重载-operator-overload"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operators">运算符重载 operator overload</a></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">T</span>(T &amp;t):<span class="built_in">i</span>(t.i), <span class="built_in">s</span>(t.s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy assignment</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; other)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//move assignment</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>=(T&amp;&amp; other)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stream extraction</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> T&amp; obj);</span><br><span class="line">    <span class="comment">//stream insertion</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, <span class="type">const</span> T&amp; obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prefix ++</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span> ++()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//postfix ++</span></span><br><span class="line">    T <span class="keyword">operator</span> ++(<span class="type">int</span>)&#123;</span><br><span class="line">        T old = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">operator</span>++();</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> --()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//postfix --</span></span><br><span class="line">    T <span class="keyword">operator</span> --(<span class="type">int</span>)&#123;</span><br><span class="line">        T old = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">operator</span>--();</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+, +=</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> T&amp; rhs)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">friend</span> T <span class="keyword">operator</span>+(T lhs, <span class="type">const</span> T&amp; rhs)&#123;</span><br><span class="line">        lhs += rhs;</span><br><span class="line">        <span class="keyword">return</span> lhs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//comparison &lt; first</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt; (<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)&#123; <span class="comment">/* do actual comparison */</span> &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> rhs &lt; lhs; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> !(lhs &gt; rhs); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> !(lhs &lt; rhs); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)&#123; <span class="comment">/* do actual comparison */</span> &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> !(lhs == rhs); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//function call</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//pointer</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//type cast</span></span><br><span class="line">      <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> T&amp; obj)&#123;<span class="keyword">return</span> os;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, <span class="type">const</span> T&amp; obj)&#123;<span class="keyword">return</span> is;&#125;</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ul>
<li><p>&lt;&lt; &gt;&gt; 运算符重载</p>
<p>These operators must be overloaded as a global function. And if we want to allow them to access private data members of the class, we must make them friend.</p>
<p><strong>Why these operators must be overloaded as global?</strong> In operator overloading, if an operator <strong>is overloaded as a member, then it must be a member of the object on the left side of the operator</strong>. For example, consider the statement “ob1 + ob2” (let ob1 and ob2 be objects of two different classes). To make this statement compile, we must overload ‘+’ in a class of ‘ob1’ or make ‘+’ a global function. The operators ‘&lt;&lt;‘ and ‘&gt;&gt;’ are called like ‘cout &lt;&lt; ob1’ and ‘cin &gt;&gt; ob1’. So if we want to make them a member method, then they must be made members of ostream and istream classes, which is not a good option most of the time. Therefore, these operators are overloaded as global functions with two parameters, cout and object of user-defined class.</p></li>
<li><p>public or private?</p></li>
<li><p>(+, +=)Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if <code>operator+</code> is a member function of the complex type, then only complex+integer would compile, and not integer+complex).Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:</p></li>
<li><p>Standard algorithms such as <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/algorithm/sort">std::sort</a> and containers such as <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/set">std::set</a> expect operator&lt; to be defined, by default</p></li>
<li><p>++ --++</p>
<p>++lvalue ⇒ lvalue+=1 ⇒ lvalue = lvalue+1</p>
<p>y=x++ ⇒ y=(t=x, x=x+1, t)</p></li>
</ul>
<h1 id="自引用-this">自引用 this</h1>
<p>状态更新函数, 一种很有用的技术是令他们返回已更新对象的返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Date&amp; <span class="title">Date::add_year</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(d==<span class="number">29</span> &amp;&amp; m==<span class="number">2</span> &amp;&amp; !<span class="built_in">leapyear</span>(y+n))&#123;</span><br><span class="line">    d=<span class="number">1</span>;</span><br><span class="line">    m=<span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  y+=n;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类 X 的 nonconst 成员函数中, this 的类型时 X*</p>
<p>在类 X 的 const 成员函数中, this 的类型时 const X*</p>
<h1 id="explicit">explicit</h1>
<p><code>explicit</code>的作用是用来声明类构造函数是显示调用的，而非隐式调用，所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显示调用的。再加上<code>explicit</code>关键字也没有什么意义。</p>
<h1 id="internal-linkage">internal linkage</h1>
<p>When you write an implementation file (<code>.cpp</code>, <code>.cxx</code>, etc) your compiler generates a <strong>translation unit</strong>. This is the source file from your implementation plus all the headers you <code>#include</code> in it.</p>
<p><em>Internal linkage</em> refers to everything only <strong>in scope of a translation unit</strong>.</p>
<p><em>External linkage</em> refers to things that exist beyond a particular translation unit. In other words, <strong>accessible through the whole program</strong>, which is the combination of all translation units (or object files).</p>
<p>You can explicitly control the linkage of a symbol by using the <code>extern</code> and <code>static</code> keywords. If the linkage is not specified then the default linkage is <code>extern</code> (external linkage) for non-<code>const</code> symbols and <code>static</code> (internal linkage) for <code>const</code> symbols.</p>
<p>Note that instead of using <code>static</code> (internal linkage), it is better to use <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions"><em>anonymous</em> namespaces</a> into which you can also put <code>class</code>es. Though they allow <code>extern</code> linkage, anonymous namespaces are unreachable from other translation units, making linkage <em>effectively</em> <code>static</code>.</p>
<h1 id="重载">重载</h1>
<p>重载解析与函数声明的次序无关</p>
<p>重载解析过程中不考虑函数的返回类型, 独立于上下文</p>
<h1 id="对象与引用">对象与引用</h1>
<h2 id="对象">对象</h2>
<h3 id="临时对象">临时对象</h3>
<p>除非我们把临时对象绑定到引用上或者用它初始化一个命名对象, 否则大多数时候在临时对象所在的完整表达式末尾, 他就被销毁了</p>
<h3 id="普通对象">普通对象</h3>
<p>对象(object) --&gt; 一段内存空间</p>
<h2 id="引用">引用</h2>
<h3 id="左值引用">左值引用</h3>
<p>有身份的对象的引用</p>
<h3 id="右值引用"><a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">右值引用</a></h3>
<p>可移动的对象的引用</p>
<h2 id="左值右值引用">左值右值引用</h2>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxbenbxsxmj30e60323yf.jpg" alt="image-20211212221135490" /><figcaption aria-hidden="true">image-20211212221135490</figcaption>
</figure>
<p>有身份 i</p>
<p>可移动 m</p>
<p>The original definition of lvalues and rvalues from the earliest days of C is as follows: <strong>An <em>lvalue</em> is an expression <code>e</code> that may appear on the left or on the right hand side of an assignment, whereas an <em>rvalue</em> is an expression that can only appear on the right hand side of an assignment.</strong></p>
<p>An <em>lvalue</em> is an expression that refers to a <strong>memory location</strong> and allows us to take the address of that <strong>memory location</strong> <strong>via the <code>&amp;</code> operator</strong>. An <em>rvalue</em> is an expression that is not an lvalue.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// perhaps use x in various ways</span></span><br><span class="line">x = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>
<p>其中<code>x = foo()</code>包括以下步骤</p>
<ul>
<li>clones the resource from the temporary returned by <code>foo</code>,</li>
<li>destructs the resource held by <code>x</code> and replaces it with the clone,</li>
<li>destructs the temporary and thereby releases its resource.</li>
</ul>
<p>move action is aimed to swap the resource instead of clone it</p>
<p>you can overload in different ways</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp; x)</span></span>; <span class="comment">// lvalue reference overload</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp;&amp; x)</span></span>; <span class="comment">// rvalue reference overload</span></span><br><span class="line"></span><br><span class="line">X x;</span><br><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">foo</span>(x); <span class="comment">// argument is lvalue: calls foo(X&amp;)</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">foobar</span>()); <span class="comment">// argument is rvalue: calls foo(X&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>=(X <span class="type">const</span> &amp; rhs); <span class="comment">// classical implementation</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>=(X&amp;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Move semantics: exchange content between this and rhs</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string var &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">string&amp; r1&#123;var&#125;;</span><br><span class="line">string&amp; r2&#123;<span class="built_in">f</span>()&#125;;<span class="comment">//error f() is rvalue</span></span><br><span class="line">string&amp; r3&#123;<span class="string">&quot;hello&quot;</span>&#125;;<span class="comment">//error 不允许绑定到临时变量</span></span><br><span class="line"></span><br><span class="line">string&amp;&amp; rr1&#123;<span class="built_in">f</span>()&#125;;</span><br><span class="line">string&amp;&amp; rr2&#123;var&#125;;<span class="comment">//error var is lvalue</span></span><br><span class="line">string&amp;&amp; rr3&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string&amp; cr1 &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>除非我们把临时对象绑定到引用上或者用它初始化一个命名对象, 否则大多数时候在临时对象所在的完整表达式末尾, 他就被销毁了</p>
<p>临时量可以用作 const 引用或者命名对象的初始化器(见why rvalue is allowed to passed by const reference)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fs</span><span class="params">(string&amp; s1, string&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> string&amp; cs = s1+s2;<span class="comment">//ok</span></span><br><span class="line">    string ss = s1+s2;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    string&amp; s = s1+s2;<span class="comment">//error</span></span><br><span class="line">        <span class="comment">//non-const lvalue reference to type &#x27;basic_string&lt;...&gt;&#x27; cannot bind to a temporary of type &#x27;basic_string&lt;...&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="why-rvalue-is-allowed-to-passed-by-const-reference"><a target="_blank" rel="noopener" href="https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/">why rvalue is allowed to passed by const reference</a></h1>
<p>C++ deliberately specifies that <strong>binding a temporary object to a reference <em>to const</em> on the stack lengthens the lifetime of the temporary to the lifetime of the reference itself</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example 1 legal</span></span><br><span class="line"><span class="function">string <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> string&amp; s = <span class="built_in">f</span>();</span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;    <span class="comment">// can we still use the &quot;temporary&quot; object? yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 2 illegal</span></span><br><span class="line"><span class="function">string <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string&amp; s = <span class="built_in">f</span>();       <span class="comment">// still legal? no</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 3</span></span><br><span class="line"></span><br><span class="line"><span class="function">Derived <span class="title">factory</span><span class="params">()</span></span>; <span class="comment">// construct a Derived object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Base&amp; b = <span class="built_in">factory</span>(); <span class="comment">// calls Derived::Derived here</span></span><br><span class="line">  <span class="comment">// … use b …</span></span><br><span class="line">&#125; <span class="comment">// calls Derived::~Derived directly here — not Base::~Base + virtual dispatch!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//example to explain eg3</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">base</span> &#123;</span><br><span class="line">    ~<span class="built_in">base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;base&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">derived</span> : base &#123;</span><br><span class="line">    ~<span class="built_in">derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;derived&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">derived <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f&quot;</span>&lt;&lt;endl;</span><br><span class="line">    derived d;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base * p = <span class="keyword">new</span> derived;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="type">const</span> base&amp; c = <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">base</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">derived</span></span><br><span class="line"><span class="comment">base</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//~base 不是虚函数, 说明 c 的销毁直接调用 ~derived, </span></span><br><span class="line"><span class="comment">//而不是~base + virtual dispatch</span></span><br><span class="line"><span class="comment">//所以例子3 说明的就是 temporary binded to const ref 析构函数直接调用 temporary 类型的析构函数</span></span><br></pre></td></tr></table></figure>
<p>only lvalues can be bound to references to non-const.</p>
<h1 id="初始化">初始化</h1>
<p>使用=进行初始化可能会发生窄化转换, 使用初始化列表不会, 所以推荐使用初始化列表, 但是 auto 不推荐, 因为会得到 list 类型.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X a1 &#123;v&#125;;</span><br><span class="line">X a2 = &#123;v&#125;;</span><br><span class="line">X a3 = v;</span><br><span class="line"><span class="function">X <span class="title">a4</span><span class="params">(v)</span></span>;</span><br><span class="line"><span class="comment">//newß</span></span><br><span class="line">CTest*  pTest = <span class="keyword">new</span>  <span class="built_in">CTest</span>();</span><br></pre></td></tr></table></figure>
<p>缺少初始化容器</p>
<ul>
<li>全局变量, 局部 static 变量, static 成员会执行{} 初始化</li>
<li>局部变量, 堆对象, 除非位于默认构造函数中, 否则不会进行默认初始化</li>
</ul>
<h1 id="raw-string">raw string</h1>
<p>C++11 引入了原始字符串。最基本的用法是<code>R"(...)"</code>，由<code>R</code>开头，双引号内包围着<code>(...)</code>，实际的字符序列是小括号内的内容，小括号是字符序列的定界符。当然，左小括号和右小括号是首位对应的。</p>
<p>“原始”（raw）体现在字符串里的字符一就是一，二就是二，不会给你转义。也就是说，传统的<code>"\\n"</code>除了字符串结尾符，仅包含换行符，而原始字符串<code>R"(\\n)"</code>则包含反斜杠和字符<code>n</code>，这是明显的不同。</p>
<p>从现在来看，貌似已经很好的解决问题了，但如果字符序列里包含<code>)"</code>，如<code>R"(坐标: "(x,y)")"</code>，此时编译器是懵的，因为<code>"(</code>对应了两个<code>)"</code>。在这种情况下，我们可以选择其他定界符，如，<code>R"&amp;(坐标: "(x,y)")&amp;"</code>。语法如下：<code>R"delim(...)delim"</code>，<code>delim</code>的选取比较灵活，最长不超过16个字符，且不为小括号、空白、控制字符和反斜杠。</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxad138yhzj30rk0igwgr.jpg" alt="image-20211212003002953" /><figcaption aria-hidden="true">image-20211212003002953</figcaption>
</figure>
<h1 id="变量与类型">变量与类型</h1>
<ul>
<li>类型 type: 定义一组可能的值以及一组操作</li>
<li>对象 object: 存放某类型的内存空间</li>
<li>值 value: 一组二进制位, 含义由其类型决定</li>
<li>变量 variable: 是一个命名的对象</li>
</ul>
<h1 id="函数对象函子">函数对象(函子)</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Less_than</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> T val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Less_than</span>(<span class="type">const</span> T&amp; v) :<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x&lt;val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function call</span></span><br><span class="line"></span><br><span class="line">Less_than&lt;<span class="type">int</span>&gt; lti &#123;<span class="number">42</span>&#125;;</span><br><span class="line"><span class="built_in">lti</span>(<span class="number">36</span>);</span><br></pre></td></tr></table></figure>
<h1 id="模板-template">模板 template</h1>
<p>模板类声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Vector</span>(<span class="type">int</span> s);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模板函数声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="type">int</span> s)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="enum">enum</h1>
<p>使用 enum class 定义枚举类型时不能与 int 类型互相转换, 运算只有&gt; &lt; ==, 而且 enum class 的枚举值名字位于 enum 局部作用域内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Traffic_light</span> &#123;red, yellow, green&#125;;</span><br><span class="line">Traffic_light l = Traffic_light::red;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Warning</span> &#123;green, yellow, orange, red&#125;;</span><br><span class="line">Warning w = green;</span><br></pre></td></tr></table></figure>
<h1 id="literal-type"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/LiteralType">literal type</a></h1>
<p>Literal types are the types of <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code> variables</a> and they can be constructed, manipulated, and returned from <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code> functions</a>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">constexpr</span> <span class="title">A</span><span class="params">(<span class="type">int</span>)</span> </span>= <span class="keyword">delete</span>; <span class="type">char</span> c; &#125;;  <span class="comment">// A is a literal type</span></span><br><span class="line"><span class="keyword">constexpr</span> A v = std::<span class="built_in">bit_cast</span>&lt;A&gt;(<span class="string">&#x27;0&#x27;</span>);  <span class="comment">// OK in C++20</span></span><br><span class="line">                                        <span class="comment">// v has literal type and thus can be constexpr</span></span><br></pre></td></tr></table></figure>
<h1 id="constexpr"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr</a></h1>
<p>编译时求值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">func1</span><span class="params">(<span class="type">double</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">func2</span><span class="params">(<span class="type">double</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>+<span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> I = <span class="number">17</span>;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">17</span>;</span><br><span class="line"><span class="comment">//    constexpr double x1 = sqrt(I);</span></span><br><span class="line"><span class="comment">//    constexpr double x2 = sqrt(var);</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x3 = <span class="built_in">sqrt</span>(I);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> x4 = <span class="number">17</span>+<span class="number">18</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> x5 = I;</span><br><span class="line"><span class="comment">//    constexpr double x6 = var;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> x7 = <span class="built_in">func1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> x8 = <span class="built_in">func2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> x9 = <span class="built_in">func1</span>(I);</span><br><span class="line"><span class="comment">//    constexpr double x10 = func1(var);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注释掉的代码为错误代码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">array_size1</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error, constant expression required in array declaration</span></span><br><span class="line"><span class="comment">//???</span></span><br><span class="line"><span class="type">int</span> array[<span class="built_in">array_size1</span>(<span class="number">10</span>)];    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">array_size2</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// OK, constexpr functions can be evaluated at compile time</span></span><br><span class="line"><span class="comment">// and used in contexts that require constant expressions. </span></span><br><span class="line"><span class="type">int</span> array[<span class="built_in">array_size2</span>(<span class="number">10</span>)];     </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="built_in">S</span>() &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">S</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;  <span class="comment">// Error, f must not be virtual.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">55</span>;</span><br><span class="line">  &#125;       </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NL</span> &#123;</span><br><span class="line">  ~<span class="built_in">NL</span>() &#123; &#125;  <span class="comment">// The user-provided destructor (even if it is trivial) </span></span><br><span class="line">             <span class="comment">// makes the type a non-literal type.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> NL <span class="title">f1</span><span class="params">()</span> </span>&#123;  <span class="comment">// Error, return type of f1 must be a literal type.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NL</span>();</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f2</span><span class="params">(NL)</span> </span>&#123;  <span class="comment">// Error, the parameter type NL is not a literal type.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">55</span>; </span><br><span class="line">&#125;                 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> S <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">S</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123; val = <span class="built_in">f3</span>() &#125;;  <span class="comment">// Error, initialization of the return value in f3()</span></span><br><span class="line">                      <span class="comment">// uses a non-constexpr constructor.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;  <span class="comment">// Error, return type should not be void.</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f5</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// Error, function body contains more than</span></span><br><span class="line">  <span class="keyword">if</span> (x&lt;<span class="number">0</span>)                <span class="comment">// return statement.</span></span><br><span class="line">    x = -x;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-v-qualified-class"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/cv">c-v qualified class</a></h1>
<p>const and volatile class</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// non cv_qualified </span></span><br><span class="line"><span class="type">int</span> first; </span><br><span class="line"><span class="type">char</span> *second; </span><br><span class="line"></span><br><span class="line"><span class="comment">// cv-qualified </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> third; </span><br><span class="line"><span class="keyword">volatile</span> <span class="type">char</span> * fourth; </span><br></pre></td></tr></table></figure>
<p>For any type <code>T</code> (including incomplete types), other than <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/functions">function type</a> or <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reference">reference type</a>, there are three more distinct types in the C++ type system: <em>const-qualified</em> <code>T</code>, <em>volatile-qualified</em> <code>T</code>, and <em>const-volatile-qualified</em> <code>T</code>.</p>
<ul>
<li><strong><em>const object</em></strong> - an object whose type is <em>const-qualified</em>, or a non-mutable subobject of a const object. <strong>Such object cannot be modified: attempt to do so directly is a compile-time error</strong>, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.</li>
<li><strong><em>volatile object</em></strong> - an object whose type is <em>volatile-qualified</em>, or a subobject of a volatile object, or a mutable subobject of a const-volatile object. Every access (read or write operation, member function call, etc.) made through a glvalue(A <em>glvalue expression</em> is either lvalue or xvalue.) expression of volatile-qualified type is treated as a visible side-effect for the <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/as_if">purposes of optimization</a> (that is, within a single thread of execution, volatile accesses cannot be optimized out or reordered with another visible side effect that is <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/eval_order">sequenced-before</a> or sequenced-after the volatile access. This makes volatile objects suitable for communication with a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/program/signal">signal handler</a>, but not with another thread of execution, see <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>). Any attempt to refer to a volatile object through a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category#glvalue">glvalue</a> of non-volatile type (e.g. through a reference or pointer to non-volatile type) results in undefined behavior.</li>
<li><strong><em>const volatile object</em></strong> - an object whose type is <em>const-volatile-qualified</em>, a non-mutable subobject of a const volatile object, a const subobject of a volatile object, or a non-mutable volatile subobject of a const object. Behaves as both a const object and as a volatile object.</li>
</ul>
<h1 id="accumulation">accumulation</h1>
<p><code>#include &lt;numeric&gt;</code></p>
<h1 id="c11-vscode">c++11 vscode</h1>
<p>"clang.cxxflags": ["-std=c++14"]</p>
<p>setting.json</p>
<p><strong>C++ Clang Command Adapter</strong> 删除!!!! 原因应该是这个插件不继承c_cpp_properties.json中设置的C++版本</p>
<h1 id="mid">mid</h1>
<p><code>mid = (l+r)/2;</code></p>
<p><code>mid = l+(r-l)/2;</code></p>
<p>防溢出</p>
<h1 id="stdvectorbool"><a target="_blank" rel="noopener" href="http://blog.csdn.net/haolexiao/article/details/56837445">std::vector&lt;bool&gt;</a></h1>
<p>vector<bool>并不是一个STL容器，不是一个STL容器，不是一个STL容器！</p>
<p>首先<strong>vector&lt; bool&gt; 并不是一个通常意义上的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=vector容器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A148258487%7D">vector容器</a></strong>，这个源自于历史遗留问题。 早在C++98的时候，就有vector&lt; bool&gt;这个类型了，但是因为当时为了考虑到节省空间的想法，<strong>所以vector&lt; bool&gt;里面不是一个Byte一个Byte储存的，它是一个bit一个bit储存的！</strong></p>
<p>因为C++没有直接去给一个bit来操作，所以用operator[]的时候，正常容器返回的应该是一个对应元素的引用，但是对于vector&lt; bool&gt;实际上访问的是一个"proxy reference"而不是一个"true reference"，返回的是"std::vector&lt; bool&gt;:reference"类型的对象。 而一般情况情况下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; c&#123; <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span> &#125;; </span><br><span class="line"><span class="type">bool</span> b = c[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">auto</span> d = c[<span class="number">0</span>]; </span><br></pre></td></tr></table></figure>
<p>对于b的初始化它其实暗含了一个隐式的类型转换。</p>
<p><strong>此时 auto 代表的是一个右值引用</strong></p>
<p>而对于d，它的类型并不是bool，而是一个vector&lt; bool&gt;中的一个内部类。</p>
<p>而此时如果修改d的值，c中的值也会跟着修改</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">d = true;</span><br><span class="line">for(auto i:c)</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">//上式会输出1 1 0 1 0</span><br></pre></td></tr></table></figure>
<p>而如果c被销毁，d就会变成一个悬垂指针，再对d操作就属于未定义行为。</p>
<p>而为什么说vector&lt; bool&gt;不是一个标准容器，就是因为它不能支持一些容器该有的基本操作，诸如取地址给指针初始化操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; c&#123; <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span> &#125;; </span><br><span class="line">&amp;tmp = c[<span class="number">0</span>];    <span class="comment">//错误，不能编译，对于引用来说，因为c[0]不是一个左值 </span></span><br><span class="line"><span class="type">bool</span> *p = &amp;c[<span class="number">0</span>];    <span class="comment">//错误，不能编译，因为无法将一个临时量地址给绑定到指针 ``` </span></span><br></pre></td></tr></table></figure>
<p>The <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;bool&gt; specialization defines <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;bool&gt;::reference as a publicly-accessible nested class. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;bool&gt;::reference proxies the behavior of references to a single bit in <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;bool&gt;.</p>
<p>The primary use of <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;bool&gt;::reference is to provide an l-value that can be returned from <code>operator[]</code>.</p>
<p>Any reads or writes to a vector that happen via a <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;bool&gt;::reference potentially read or write to the entire underlying vector.</p>
<h1 id="for-循环">for 循环</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : array)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="varient-type-in-for-range-loop"><a target="_blank" rel="noopener" href="https://blog.petrzemek.net/2016/08/17/auto-type-deduction-in-range-based-for-loops/">varient type in for range loop</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt; v&#123;<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">  x = <span class="literal">true</span>; <span class="comment">// Changes the element inside v!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>After the loop ends, <code>v</code> will contain <code>true, true, true</code>, which is clearly something you would not expect. See <a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/on-vectorbool">this blog post</a> for more details. Here, instead of using <code>auto</code>, it is better to explicitly specify the type (<code>bool</code>). With <code>bool</code>, it will work as expected: the contents of the vector will be left unchanged.</p>
<p>Using just <code>auto</code> will not work when iterating over ranges containing move-only types, such as <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>. As <code>auto</code> creates a copy of each element in the range, the compilation will fail because move-only types cannot be copied.</p>
<h3 id="const-auto-dont-use">const auto (dont use)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> x : range)</span><br></pre></td></tr></table></figure>
<p>The use of <code>const auto</code> may suggest that you want to work with an immutable copy of each element. However, when would you want this? Why not use <code>const auto&amp;</code>? Why creating a copy when you will not be able to change it? And, even if you wanted this, from a code-review standpoint, it looks like you forgot to put <code>&amp;</code> after <code>auto</code>. Therefore, I see <strong>no reason</strong> for using <code>const auto</code>. Use <code>const auto&amp;</code> instead.</p>
<h3 id="auto">auto&amp;</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : range)</span><br></pre></td></tr></table></figure>
<p>Use <code>auto&amp;</code> <strong>when you want to modify elements in the range in non-generic code</strong>. The first part of the previous sentence should be clear as <code>auto&amp;</code> will create references to the original elements in the range. To see why this code should not be used in generic code (e.g. inside templates), take a look at the following function template:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sets all elements in the given range to the given value.</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Value&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_all_to</span><span class="params">(Range&amp; range, <span class="type">const</span> Value&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : range) &#123;    </span><br><span class="line">    x = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It will work. Well, most of the time. Until someone tries to use it on the dreaded <code>std::vector&lt;bool&gt;</code>. Then, the example will fail to compile because dereferencing an iterator of <code>std::vector&lt;bool&gt;</code> yields a temporary proxy object, which cannot bind to an lvalue reference (<code>auto&amp;</code>). As we will see shortly, the solution is to use “one more <code>&amp;</code>” when writing generic code.</p>
<p>(error: non-const lvalue reference to type '__bit_reference&lt;...&gt;' cannot bind to a temporary of type '__bit_reference&lt;...&gt;')</p>
<h3 id="const-auto-read-only">const auto&amp; (read only)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; x : range)</span><br></pre></td></tr></table></figure>
<p>Use <code>const auto&amp;</code> <strong>when you want read-only access to elements in the range</strong>, even in generic code. This is the number one choice for iterating over a range when all you want to is read its elements. <strong>No copies are made</strong> and the compiler can verify that you indeed do not modify the elements.</p>
<p>Nevertheless, keep in mind that even though you will not be able to modify the elements in the range directly, you may still be able to modify them indirectly. For example, when the elements in the range are <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Smart_pointer">smart pointers</a>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">std::string name;  <span class="comment">// ...</span></span><br><span class="line">&#125;; </span><br><span class="line">std::vector&lt;std::unique_ptr&lt;Person&gt;&gt; v;<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; x : v) &#123;</span><br><span class="line">    x-&gt;name = <span class="string">&quot;John Doe&quot;</span>; <span class="comment">// This will change the name of all people in v.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In such situations, you have to pay close attention to what you are doing because the compiler will not help you, even if you write <code>const auto&amp;</code>.</p>
<h3 id="auto-1">auto&amp;&amp;</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">see more for &amp;&amp;</a></p>
<p>The essence of the issue is that “<code>&amp;&amp;</code>” in a type declaration sometimes means rvalue reference, but sometimes it means <em>either</em> rvalue reference <em>or</em> lvalue reference. As such, some occurrences of “<code>&amp;&amp;</code>” in source code may actually have the meaning of “<code>&amp;</code>”, i.e., have the syntactic <em>appearance</em> of an rvalue reference (“<code>&amp;&amp;</code>”), but the <em>meaning</em> of an lvalue reference (“<code>&amp;</code>”). References where this is possible are more flexible than either lvalue references or rvalue references. Rvalue references may bind only to rvalues, for example, and lvalue references, in addition to being able to bind to lvalues, may bind to rvalues only under restricted circumstances.[1] In contrast, references declared with “<code>&amp;&amp;</code>” that may be either lvalue references or rvalue references may bind to <em>anything</em>. Such unusually flexible references deserve their own name. I call them <em>universal references</em>.</p>
<p><strong>If a variable or parameter is declared to have type <code>T&amp;&amp;</code> for some deduced(推断) type <code>T</code>, that variable or parameter is a <em>universal reference</em>.</strong></p>
<p>In practice, almost all universal references are parameters to <strong>function templates</strong>.Because the type deduction rules for <strong><code>auto</code>-</strong>declared variables are essentially the same as for templates, it’s also possible to have <code>auto</code>-declared universal references.</p>
<p>i.e. auto&amp;&amp;</p>
<p>i.e. template&lt;typename T&gt; void f(T&amp;&amp; param)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x : range)</span><br></pre></td></tr></table></figure>
<p>Use <code>auto&amp;&amp;</code> <strong>when you want to modify elements in the range in generic code</strong>. To elaborate, <code>auto&amp;&amp;</code> is a <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf">forwarding reference</a>, also known as a <a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">universal reference</a>. It behaves as follows:</p>
<ul>
<li>When initialized with an <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/value_category">lvalue</a>, it creates an <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/reference">lvalue reference</a>.</li>
<li>When initialized with an <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/value_category">rvalue</a>, it creates an <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/reference">rvalue reference</a>.</li>
</ul>
<p>A detailed explanation of forwarding references is outside of scope of the present post. For more details, see <a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">this article</a> by Scott Meyers. Anyway, the use of <code>auto&amp;&amp;</code> allows us to write generic loops that can also modify elements of ranges yielding proxy objects, such as our friend (or foe?) <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/vector_bool"><code>std::vector&lt;bool&gt;</code></a>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sets all elements in the given range to the given value.// Now working even with std::vector&lt;bool&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Value&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_all_to</span><span class="params">(Range&amp; range, <span class="type">const</span> Value&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x : range) &#123; </span><br><span class="line">    <span class="comment">// Notice &amp;&amp; instead of &amp;.    </span></span><br><span class="line">    x = value;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, you may wonder: if <code>auto&amp;&amp;</code> works even in generic code, why should I ever use <code>auto&amp;</code>? As Howard Hinnant puts it, liberate use of <code>auto&amp;&amp;</code> results in so-called <a target="_blank" rel="noopener" href="http://stackoverflow.com/a/13130795/2580955">confuscated code</a>: code that unnecessarily confuses people. My advice is to use <code>auto&amp;</code> in non-generic code and <code>auto&amp;&amp;</code> only in generic code(generic programming 泛型编程).</p>
<p>By the way, there was a <a target="_blank" rel="noopener" href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3853.htm">proposal for C++1z</a> to allow writing just <code>for (x : range)</code>, which would be translated into <code>for (auto&amp;&amp; x : range)</code>. Such range-based for loops were called <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/25468486/what-are-terse-ranged-based-for-loops">terse</a>. However, this proposal was <a target="_blank" rel="noopener" href="https://botondballo.wordpress.com/2014/11/23/trip-report-c-standards-meeting-in-urbana-champaign-november-2014/">removed from consideration</a> and will not be part of C++.</p>
<h3 id="const-autodont-use">const auto&amp;&amp;(dont use)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x : range)</span><br></pre></td></tr></table></figure>
<p>This variant will bind only to rvalues, which you will not be able to modify or move because of the <code>const</code>. This makes it less than useless. Hence, there is <strong>no reason</strong> for choosing this variant over <code>const auto&amp;</code>.</p>
<h3 id="decltypeauto">decltype(auto)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(decltype(auto) x : range) // C++14</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C++14">C++14</a> introduced <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C++14#Alternate_type_deduction_on_declaration"><code>decltype(auto)</code></a>. It means: apply automatic type deduction, but use <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> rules. Whereas <code>auto</code> strips down top-level <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/cv">cv qualifiers</a> and references, <code>decltype</code> preserves them.</p>
<blockquote>
<p>see more for auto and decltype</p>
</blockquote>
<p>As is stated in <a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/cpp14-language#decltype-auto">this C++ FAQ</a>, <code>decltype(auto)</code> is primarily useful for deducing the return type of forwarding functions and similar wrappers. However, it is not intended to be a widely used feature beyond that. And indeed, <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/38421392/range-based-for-loop-with-decltypeauto">there seems to be <strong>no reason</strong> for using it in range-based for loops</a>.</p>
<h3 id="summary">Summary</h3>
<p>To summarize:</p>
<ul>
<li>Use <code>auto</code> when you want to work with a <strong>copy</strong> of elements in the range.(<strong>except for bool,</strong> use bool instead of auto)</li>
<li>Use <code>auto&amp;</code> when you want to <strong>modify elements in the range in non-generic code.</strong></li>
<li>Use <code>auto&amp;&amp;</code> when you want to <strong>modify elements in the range in generic code.</strong></li>
<li>Use <code>const auto&amp;</code> when you want <strong>read-only</strong> access to elements in the range (even in generic code).</li>
</ul>
<p>Other variants are generally less useful.</p>
<h1 id="decltype"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/decltype">decltype</a></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">double</span> x; &#125;;</span><br><span class="line"><span class="type">const</span> A* a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x) y;       <span class="comment">// type of y is double (declared type)</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x)) z = y; <span class="comment">// type of z is const double&amp; (lvalue expression)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// return type depends on template parameters</span></span></span><br><span class="line"><span class="function"><span class="comment">// return type can be deduced since C++14</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getRef</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> </span>&#123; <span class="keyword">return</span> *p; &#125;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(getRef), <span class="type">const</span> <span class="type">int</span>&amp;(<span class="type">const</span> <span class="type">int</span>*)&gt;);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getRefFwdBad</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getRef</span>(p); &#125;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(getRefFwdBad), <span class="built_in">int</span>(<span class="type">const</span> <span class="type">int</span>*)&gt;,</span><br><span class="line">    <span class="string">&quot;Just returning auto isn&#x27;t perfect forwarding.&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">getRefFwdGood</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getRef</span>(p); &#125;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(getRefFwdGood), <span class="type">const</span> <span class="type">int</span>&amp;(<span class="type">const</span> <span class="type">int</span>*)&gt;,</span><br><span class="line">    <span class="string">&quot;Returning decltype(auto) perfectly forwards the return type.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alternatively:</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getRefFwdGood1</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> -&gt; <span class="title">decltype</span><span class="params">(getRef(p))</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getRef</span>(p); &#125;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(getRefFwdGood1), <span class="type">const</span> <span class="type">int</span>&amp;(<span class="type">const</span> <span class="type">int</span>*)&gt;,</span><br><span class="line">    <span class="string">&quot;Returning decltype(return expression) also perfectly forwards the return type.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(i) j = i * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i and j are the same type? &quot;</span> &lt;&lt; std::boolalpha</span><br><span class="line">              &lt;&lt; std::is_same_v&lt;<span class="keyword">decltype</span>(i), <span class="keyword">decltype</span>(j)&gt; &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(f) g = f; <span class="comment">// the type of a lambda function is unique and unnamed</span></span><br><span class="line">    i = <span class="built_in">f</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    j = <span class="built_in">g</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="reverse-iterator">reverse iterator</h1>
<p><code>std::reverse_iterator</code> produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator.</p>
<figure>
<img src="https://upload.cppreference.com/mwiki/images/3/39/range-rbegin-rend.svg" alt="range-rbegin-rend.svg" /><figcaption aria-hidden="true">range-rbegin-rend.svg</figcaption>
</figure>
<h1 id="c.h文件-.h文件里不要定义变量可以声明"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html">.c&amp;.h文件</a> .h文件里不要定义变量，可以声明！！</h1>
<ul>
<li><p>一个经典错误。3a222 在a.h头文件中定义变量temp并初始化，即显式初始化。int temp = 0；</p>
<p>a.c b.c文件中都包含了a.h头文件，则在编译时会出现：multiple definition of `a’的错误。</p>
<p>a.h中定义变量temp，不初始化为0即为不显示初始化。</p>
<p>不显示初始化不出错原因： —— 不显式的初始化，在C语言中（C++中不是这样的），则先假定为声明，多次声明是没错的，最后才是定义。</p></li>
</ul>
<h1 id="内置变量">内置变量</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool:         所占字节数：1    最大值：1        最小值：0</span><br><span class="line">char:         所占字节数：1    最大值：        最小值：?</span><br><span class="line">signed char:     所占字节数：1    最大值：        最小值：?</span><br><span class="line">unsigned char:     所占字节数：1    最大值：?        最小值：</span><br><span class="line">wchar_t:     所占字节数：4    最大值：2147483647        最小值：-2147483648</span><br><span class="line">short:         所占字节数：2    最大值：32767        最小值：-32768</span><br><span class="line">int:         所占字节数：4    最大值：2147483647    最小值：-2147483648</span><br><span class="line">unsigned:     所占字节数：4    最大值：4294967295    最小值：0</span><br><span class="line">long:         所占字节数：8    最大值：9223372036854775807    最小值：-9223372036854775808</span><br><span class="line">unsigned long:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">double:     所占字节数：8    最大值：1.79769e+308    最小值：2.22507e-308</span><br><span class="line">long double:     所占字节数：16    最大值：1.18973e+4932    最小值：3.3621e-4932</span><br><span class="line">float:         所占字节数：4    最大值：3.40282e+38    最小值：1.17549e-38</span><br><span class="line">size_t:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">string:     所占字节数：24</span><br></pre></td></tr></table></figure>
<h1 id="extern">Extern</h1>
<p>用extern来<strong>声明</strong>在别的文件中已经存在的变量和函数，而且格式必须严格一致（比如数组不等价于指针）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;</span><br></pre></td></tr></table></figure>
<p>其实相当于只声明, 不定义.</p>
<ul>
<li><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</li>
</ul>
<h1 id="传参">传参</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">调用类型</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td>
<td style="text-align: left;">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td>
<td style="text-align: left;">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td>
<td style="text-align: left;">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
</tbody>
</table>
<ul>
<li>参数可以有默认值</li>
</ul>
<h1 id="lambda表达式">lambda表达式</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;return_type&#123;body&#125;</span><br></pre></td></tr></table></figure>
<p>每当你定义一个<code>lambda</code>表达式后，编译器会自动生成一个匿名类（这个类当然重载了<code>()</code>运算符），我们称为闭包类型（closure type）。那么在运行时，这个<code>lambda</code>表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的<code>lambda</code>表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为<code>lambda</code>捕捉块。</p>
<p>捕获列表[]: [&amp;]通过引用捕获, [=]通过值捕获, [this]成员通过引用捕获</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add_x = [x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;  <span class="comment">// 复制捕捉x</span></span><br><span class="line">    <span class="keyword">auto</span> multiply_x = [&amp;x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a * x; &#125;;  <span class="comment">// 引用捕捉x</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_x</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">multiply_x</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出：20 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> C, <span class="keyword">class</span> Oper&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_all</span><span class="params">(C&amp; c, Oper op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:c)</span><br><span class="line">        <span class="built_in">op</span>(*x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vetcor&lt;unique_ptr&lt;Shape&gt;&gt; v;</span><br><span class="line">for_all(v, [](Shape&amp; s)&#123;s.<span class="built_in">draw</span>();&#125;)</span><br><span class="line"></span><br><span class="line">[=]()-&gt;<span class="type">int</span>&#123;<span class="keyword">if</span>(y) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="虚函数-虚基类">虚函数 虚基类</h1>
<figure>
<img src="https://jacktang816.github.io/img/cpp/virtualFunction/vptrLocation.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="虚函数">虚函数</h2>
<p>➢ 编译程序为有虚函数的类创建一个虚函数入口地址表VFT，</p>
<p>➢ 表首地址存放在对象的起始单元中。</p>
<p>➢ 当对象调用虚函数时，通过其起始单元得到VFT首址，</p>
<p>动态绑定到相应的函数成员。</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxacrfe7eaj30pa09q75b.jpg" alt="截屏2021-11-12 上午11.43.14" /><figcaption aria-hidden="true">截屏2021-11-12 上午11.43.14</figcaption>
</figure>
<p>vtbl (virtual function table) 指明了每个类在运行时应该调用 which 虚函数</p>
<p>每个类有一个自己的vtbl</p>
<p>开销: 每个对象需要一个额外的指针即指向 vtbl 的指针, 每个类需要一个 vtbl</p>
<p>https://stackoverflow.com/questions/3324721/virtual-tables-and-virtual-pointers-for-multiple-virtual-inheritance-and-type-ca</p>
<p><strong>question:</strong></p>
<p>I am little confused about vptr and representation of objects in the memory, and hope you can help me understand the matter better.</p>
<ol type="1">
<li>Consider <code>B</code> inherits from <code>A</code> and both define virtual functions <code>f()</code>. From what I learned the representation of an object of class B in the memory looks like this:<code>[ vptr | A | B ]</code> and the <code>vtbl</code> that <code>vptr</code> points to contains <code>B::f()</code>. I also understood that casting the object from <code>B</code> to <code>A</code> does nothing except ignoring the <code>B</code> part at the end of the object. Is it true? Doesn't this behavior is wrong? We want that object of type <code>A</code> to execute <code>A::f()</code> method and not <code>B::f()</code>.</li>
<li>Are there a number of <code>vtables</code> in the system as the number of classes?</li>
<li>How will a <code>vtable</code> of class that inherits from two or more classes look like? How will the object of C be represented in the memory?</li>
<li>Same as question 3 but with virtual inheritance.</li>
</ol>
<p><strong>answer:</strong></p>
<p>The following is true for GCC (and it seems true for LLVM <a target="_blank" rel="noopener" href="https://llvm.org/docs/CompilerWriterInfo.html#abi">link</a>), but may also be true for the compiler you're using. All these is implementation-dependent, and is not governed by C++ standard. However, GCC write its own binary standard document, <a target="_blank" rel="noopener" href="http://static.coldattic.info/cxx-abi/abi.html">Itanium ABI</a>.</p>
<p>I tried to explain basic concepts of how virtual tables are laid out in more simple words as a part of my <a target="_blank" rel="noopener" href="http://coldattic.info/post/3/">article about virtual function performance in C++</a>, which you may find useful. Here are answers to your questions:</p>
<ol type="1">
<li><p>A more correct way to depict internal representation of the object is:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">| vptr | ======= | ======= |  &lt;-- your object</span><br><span class="line">       |----A----|         |</span><br><span class="line">       |---------B---------|</span><br></pre></td></tr></table></figure>
<p><code>B</code> <em>contains</em> its base class <code>A</code>, <strong>it just adds a couple of his own members after its end.</strong></p>
<p>Casting from <code>B*</code> to <code>A*</code> indeed does nothing, it returns the same pointer, and <code>vptr</code> remains the same. But, in a nutshell, <strong>virtual functions are not always called via vtable</strong>. Sometimes they're called just like the other functions.</p>
<p>Here's more detailed explanation. You should distinguish two ways of calling member function:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A a, *aptr;</span><br><span class="line">a.<span class="built_in">func</span>();         <span class="comment">// the call to A::func() is precompiled!</span></span><br><span class="line">aptr-&gt;A::<span class="built_in">func</span>();  <span class="comment">// ditto</span></span><br><span class="line">aptr-&gt;<span class="built_in">func</span>();     <span class="comment">// calls virtual function through vtable.</span></span><br><span class="line">                  <span class="comment">// It may be a call to A::func() or B::func().</span></span><br></pre></td></tr></table></figure>
<p>The thing is that it's known <em>at compile time</em> how the function will be called: via vtable or just will be a usual call. And the thing is that <strong>the type of a casting expression is known at compile time</strong>, and therefore the compiler chooses the right function at compile time.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B b, *bptr;          </span><br><span class="line"><span class="built_in">static_cast</span>&lt;A&gt;(b)::<span class="built_in">func</span>(); <span class="comment">//calls A::func, because the type</span></span><br><span class="line">   <span class="comment">// of static_cast&lt;A&gt;(b) is A!</span></span><br></pre></td></tr></table></figure>
<p>It doesn't even look inside vtable in this case!</p></li>
<li><p>Generally, no. A class can have several vtables if it inherits from several bases, each having its own vtable. Such set of virtual tables forms a "virtual table group" (see pt. 3).</p>
<p>Class also needs a set of construction vtables, to correctly distpatch virtual functions when constructing bases of a complex object. You can read further in <a target="_blank" rel="noopener" href="http://static.coldattic.info/cxx-abi/abi.html#vtable-ctor">the standard I linked</a>.</p></li>
<li><p>Here's an example. Assume <strong><code>C</code> inherits from <code>A</code> and <code>B</code></strong>, each class defining <code>virtual void func()</code>, as well as <code>a</code>,<code>b</code> or <code>c</code> virtual function relevant to its name.</p>
<p>The <code>C</code> will have a vtable group of two vtables. It will share one vtable with <code>A</code> (the vtable where the own functions of the current class go is called "primary"), and a vtable for <code>B</code> will be appended:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">| C::<span class="built_in">func</span>()   |   <span class="built_in">a</span>()  |  <span class="built_in">c</span>()  || C::<span class="built_in">func</span>()  |   <span class="built_in">b</span>()   |</span><br><span class="line">|---- vtable <span class="keyword">for</span> A ----|        |---- vtable <span class="keyword">for</span> B ----| </span><br><span class="line">|--- <span class="string">&quot;primary virtual table&quot;</span> --||- <span class="string">&quot;secondary vtable&quot;</span> -|</span><br><span class="line">|-------------- <span class="keyword">virtual</span> table group <span class="keyword">for</span> C -------------|</span><br></pre></td></tr></table></figure>
<p>The representation of object in memory will look nearly the same way its vtable looks like. Just add a <code>vptr</code> before every vtable in a group, and you'll have a rough estimate how the data are laid out inside the object. You may read about it in the <a target="_blank" rel="noopener" href="http://static.coldattic.info/cxx-abi/abi.html#layout">relevant section</a> of the GCC binary standard.</p></li>
<li><p>Virtual bases (some of them) are laid out at the end of vtable group. This is done because each class should have only one virtual base, and if they were mingled with "usual" vtables, then compiler couldn't re-use parts of constructed vtables to making those of derived classes. This would lead to computing unnecessary offsets and would decrease performance.</p>
<p>Due to such a placement, virtual bases also introduce into their vtables additional elements: <code>vcall</code> offset (<strong>to get address of a final overrider when jumping from the pointer to a virtual base inside a complete object</strong> to the beginning of the class that overrides the virtual function) for each virtual function defined there. Also each virtual base adds <code>vbase</code> offsets, w<strong>hich are inserted into vtable of the derived class; they allow to find where the data of the virtual base begin</strong> (it can't be precompiled since the actual address depends on the hierarchy: virtual bases are at the end of object, and the shift from beginning varies depending on how many non-virtual classes the current class inherits.).</p></li>
</ol>
<p>Woof, I hope I didn't introduce much unnecessary complexity. In any case, you may refer to the original standard, or to any document of your own compiler.</p>
<h2 id="虚基类">虚基类</h2>
<p>Virtual inheritance is there to solve this problem(菱形继承). When you specify virtual when inheriting your classes, you're telling the compiler that you only want a single instance.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="声明-定义">声明 定义</h1>
<p>区分声明与定义</p>
<p>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</p>
<p>2、另一种是不需要建立存储空间的。 例如：extern int a 其中变量a是在别的文件中定义的</p>
<p>声明是向编译器介绍名字－－标识符。它告诉编译器“这个函数或变量在某处可找到。</p>
<p>而定义是说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的是函数还是变量，编译器都要为它们在定义点分配存储空间。对于变量，编译器确定变量的大小，然后在内存中开辟空间来保存其数据，对于函数，编译器会生成代码，这些代码最终也要占用一定的内存。</p>
<p><strong>基本类型变量的声明和定义是同时产生的, 对于对象来说则是分开的</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A a; <span class="comment">//对象声明</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">//对象定义(初始化)</span></span><br></pre></td></tr></table></figure>
<p>所谓定义就是（编译器）创建一个对象，为这个对象分配一块内存，并给它取上一个名字，这个名字就是就是我们经常所说的变量名或对象名。</p>
<p>声明有2重含义：</p>
<p>（1） 告诉编译器，这个名字已经匹配到一块内存上，下面的代码用到变量或者对象是在别的地方定义的。声明可以出现多次。</p>
<p>（2） 告诉编译器，这个名字已经被预定了，别的地方再也不能用它来作为变量名或对象名。</p>
<p><strong><em>*定义和声明的最重要区别就是：*</em></strong></p>
<p><strong><em>*定义创建对象并为这个对象分配了内存，声明没有分配内存。*</em></strong></p>
<p>函数原型: 在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/程序设计">计算机编程</a>中，<strong>函数原型</strong>（英语：<strong>Function prototype</strong>）或<strong>函数接口</strong>（英语：<strong>Function interface</strong>）是用于指定函数的名称和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/类型特征">类型特征</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/元数">元数</a>，参数的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/資料類型">数据类型</a>和返回值类型）的一种省略了函数体的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/子程序">函数</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=声明&amp;action=edit&amp;redlink=1">声明</a>。</p>
<h1 id="strcut和class的区别"><a href="(https://www.jianshu.com/p/409f931c17d9)">strcut和class的区别</a></h1>
<ol type="1">
<li>默认的继承访问权。class默认的是private,strcut默认的是public(union 也是 public)。</li>
<li>默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li>
<li>“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数</li>
<li>class和struct在使用大括号{ }上的区别 关于使用大括号初始化 1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化 2.）如果没有定义构造函数，struct可以用大括号初始化。 3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化</li>
</ol>
<h1 id="namespace">namespace</h1>
<p>类的头文件应该是自己形成一个命名空间, 然后 cpp <strong>文件因为是相当于在类外进行定义</strong>所以要使用命名空间指明函数定义</p>
<h1 id="explicit-implicit">explicit implicit</h1>
<p>上面的代码中, "CxString string2 = 10;" 这句为什么是可以的呢? 在C++中, 如果的<strong>构造函数只有一个参数</strong>时, 那么在编译的时候就会有一个<strong>缺省的转换操作:将该构造函数对应数据类型的数据转换为该类对象.</strong> 也就是说 "CxString string2 = 10;" 这段代码, 编译器自动将整型转换为CxString类对象, 实际上等同于下面的操作:</p>
<p><code>CxString string2(10);</code></p>
<p>即隐式转换</p>
<p>当使用 explicit 关键字修饰构造函数以后, 就能避免这种操作</p>
<p>默认情况下构造函数都是 implicit 的</p>
<h1 id="friend-友元">friend 友元</h1>
<p>原则上, 类的私有（private）和受保护（protected）成员不能从声明它们的同一类外部访问。但是, 此规则不适用于友元 "friends"。</p>
<p>以friend关键字修饰的函数或类称为友元函数或友元类。</p>
<p><strong>友元函数</strong>是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：</p>
<p><code>friend 类型 函数名(形式参数);</code></p>
<p><strong>友元类</strong>的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p>
<p>　　当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下：</p>
<p><code>friend class 类名;</code></p>
<p>其中：friend和class是关键字，类名必须是程序中的一个已定义过的类。</p>
<p><strong>使用友元类时注意</strong>：</p>
<p>　　1、友元关系不能被继承。</p>
<p>　　2、友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p>
<p>　　3、友元关系具有非传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</p>
<h1 id="public-protect-private-继承">public protect private 继承</h1>
<p>类继承方式 -&gt; 基类成员的访问权限</p>
<p><strong>继承无法访问父变量的 private 成员</strong></p>
<p><strong>访问权限</strong></p>
<p><strong>private</strong>：私有成员</p>
<p>仅可被本类的函数成员访问</p>
<p>不能被派生类、其它类和普通函数访问</p>
<p><strong>protected</strong>：受保护成员</p>
<p>可被本类和派生类的函数成员访问</p>
<p>不能被其它类函数成员和普通函数访问</p>
<p><strong>public</strong>：公有成员</p>
<p>可被任何函数成员和普通函数访问</p>
<p><strong>继承权限</strong> <strong>public继承</strong> 派生类通过public继承，基类的各种权限不变 。 派生类的成员函数，可以访问基类的public成员、protected成员，但是无法访问基类的private成员。 派生类的实例变量，可以访问基类的public成员，但是无法访问protected、private成员，仿佛基类的成员之间加到了派生类一般。 可以将public继承看成派生类将基类的public,protected成员囊括到派生类，但是不包括private成员。</p>
<p><strong>protected继承</strong> 派生类通过protected继承，基类的public成员在派生类中的权限变成了protected 。protected和private不变。 派生类的成员函数，可以访问基类的public成员、protected成员，但是无法访问基类的private成员。 派生类的实例变量，无法访问基类的任何成员，因为基类的public成员在派生类中变成了protected。 可以将protected继承看成派生类将基类的public,protected成员囊括到派生类，全部作为派生类的protected成员，但是不包括private成员。 private成员是基类内部的隐私，除了友元，所有人员都不得窥探。派生类的友元，都不能访问</p>
<p><strong>private继承</strong> 派生类通过private继承，基类的所有成员在派生类中的权限变成了private。 派生类的成员函数，可以访问基类的public成员、protected成员，但是无法访问基类的private成员。 派生类的实例变量，无法访问基类的任何成员，因为基类的所有成员在派生类中变成了private。 可以将private继承看成派生类将基类的public,protected成员囊括到派生类，全部作为派生类的private成员，但是不包括private成员。 private成员是基类内部的隐私，除了友元，所有人员都不得窥探。派生类的友元，都不能访问</p>
<p><strong>总结：继承修饰符，就像是一种筛子，将基类的成员筛到派生类。public、protected、private，就是筛子的眼。</strong> <strong>通过public继承，所有基类成员（除了private），public、protected都到了派生类里面，public筛眼比较大，不会改变访问权限。</strong> <strong>通过protected继承，所有基类成员（除了private），public、protected都到了派生类里面，protected筛眼大小适中，所有过来的成员都变成了protected。</strong> <strong>通过private继承，所有基类成员（除了private），public、protected都到了派生类里面，private筛眼最小，所有过来的成员都变成了private。</strong></p>
<h1 id="隐式转换和显式转换">隐式转换和显式转换</h1>
<p>隐式转换: 比如 double = int, 或者调用构造函数的那种(见explicit implicit)</p>
<p>显式转换: 又称强制类型转换. 比如 int(), static_cast</p>
<p>保护值不被改变的隐式类型转换称为"提升", 如整型提升</p>
<p>浮点到整数发生截断, -1.6 → -1</p>
<h1 id="返回引用">返回引用</h1>
<p>当返回的值不是引用型时，编译器会专门给返回值分配出一块内存的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">t</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">T x = <span class="built_in">function1</span>();</span><br></pre></td></tr></table></figure>
<p>这里的过程是： 1.创建命名对象t 2.<strong>拷贝构造一个无名的临时对象，并返回这个临时对象</strong> 3.由临时对象拷贝构造对象x 4.T x=function1();这句语句结束时，析构临时对象 这里一共生成了3个对象，一个命名对象t，一个临时对象作为返回值，一个命名对象x。</p>
<p>返回引用, 其实就是返回了一个对象的引用, 新对象 = 返回的引用, 调用了拷贝构造函数</p>
<h1 id="静态数据成员">静态数据成员</h1>
<p>静态成员变量必须?要在类外部定义(c++11 整型可在内), 因为要在对象创建之前就分配内存</p>
<p>They can't be initialised inside the class, but they can be initialised outside the class, in a source file:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inside the class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line">    <span class="type">static</span> string RE_ANY;</span><br><span class="line">    <span class="type">static</span> string RE_ANY_RELUCTANT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in the source file</span></span><br><span class="line">string Thing::RE_ANY = <span class="string">&quot;([^\\n]*)&quot;</span>;</span><br><span class="line">string Thing::RE_ANY_RELUCTANT = <span class="string">&quot;([^\\n]*?)&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>Essentially it's because <code>x</code> exists independently of the number of <em>instances</em> of <code>A</code> that are created.</p>
<p>So storage for <code>x</code> needs to be defined somewhere - you can't rely on an instance of <code>A</code> to do that, and that's what</p>
<p>in exactly one translation unit, does.</p>
<p>When the <code>const</code> qualifier is present, the static variable can be considered as a constant expression. Initializing it in the class definition goes to that effect. It's just some constant value, may not even need any storage.</p>
<p>But in the other case, it's not a constant expression. It definitely needs storage. And as <span class="citation" data-cites="Bathsheba">@Bathsheba</span> points out, it needs to be defined in only one translation unit (pre-C++17). Generally speaking, a declaration that contains an initializer is also a definition. So it just can't be initialized when declared.</p>
<h1 id="缺省参数-默认参数">缺省参数 (默认参数)</h1>
<p>带缺省值的参数必须放在参数列表的最后面。因为传参是从右向左的(<em>arguments</em> are pushed onto the stack from <em>right to left</em>)。</p>
<p>即默认参数往右必须全是默认参数</p>
<p>缺省参数不能同时在函数声明和定义中出现，只能二者留其一。</p>
<h1 id="构造函数">构造函数</h1>
<p>在构造函数体前初始化：只读成员、引用成员、对象成员, 包括在声明时初始化和在列表中初始化</p>
<h1 id="作用域">作用域</h1>
<p>从小到大可以分为五级：</p>
<p>① 作用于表达式内 (常量)</p>
<p>② 作用于函数成员内 (函数参数、局部变量、局部类型)</p>
<p>③ 作用于类或派生类内 (数据/函数/类型 成员)</p>
<p>④ 作用于基类内 (数据/函数/类型 成员)</p>
<p>⑤ 作用于虚基类内 (数据/函数/类型 成员)</p>
<p>虚基类 &gt; 基类 &gt; 类/派生类 &gt; 成员函数 &gt; 表达式内</p>
<h1 id="成员指针">成员指针</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class Student &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line">……</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">xu</span><span class="params">(<span class="number">123</span>,<span class="string">&quot;Xuxiangyang&quot;</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">zhang</span><span class="params">(<span class="number">456</span>,”Zhangsan”,<span class="number">99</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;xu.number; <span class="comment">// p 指向对象 xu中的number</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Student::*q = &amp;Student::number; <span class="comment">// q 数据成员指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int Student::*q; q= &amp;Student::number;</span></span><br><span class="line">cout &lt;&lt; xu.*q&lt;&lt;endl; <span class="comment">// cout &lt;&lt; xu.number &lt;&lt;endl; </span></span><br><span class="line">cout &lt;&lt; zhang.*q &lt;&lt;endl;</span><br><span class="line"><span class="type">int</span> *p = &amp;Student::number; <span class="comment">//无法从 Student::* 转换为 int ***</span></span><br></pre></td></tr></table></figure>
<p>对于普通指针变量来说，其值是它所指向的地址，0表示空指针。 而对于数据成员指针变量来说，其值是数据成员所在地址相对于对象起始地址的偏移值，空指针用-1表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VALUE_OF_PTR(p)     (*(long*)&amp;p)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> X::*p = <span class="number">0</span>;  <span class="comment">// VALUE_OF_PTR(p) == -1</span></span><br><span class="line">    p = &amp;X::a;      <span class="comment">// VALUE_OF_PTR(p) == 0</span></span><br><span class="line">    p = &amp;X::b;      <span class="comment">// VALUE_OF_PTR(p) == 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆与栈"><a target="_blank" rel="noopener" href="https://blog.csdn.net/hairetz/article/details/4141043">堆与栈</a></h1>
<p>https://zhuanlan.zhihu.com/p/344377490</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* p0;</span><br><span class="line">    <span class="type">void</span>* p1;</span><br><span class="line">    <span class="type">void</span>* p2;</span><br><span class="line">    <span class="type">void</span>* p3;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* p4;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* p5;</span><br><span class="line">    <span class="type">void</span>* p6;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* pi;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* pc = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    string* s456 = <span class="keyword">new</span> string&#123;<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">    string s123 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    string s234 &#123;<span class="string">&quot;234&quot;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> string cs123 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">const</span> string cs234 = <span class="string">&quot;234&quot;</span>;</span><br><span class="line">    <span class="type">static</span> string ss456 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p0 = pc;</span><br><span class="line">    p1 = s456;</span><br><span class="line">    p2 = &amp;s123;</span><br><span class="line">    p3 = &amp;s234;</span><br><span class="line">    p4 = &amp;cs123;</span><br><span class="line">    p5 = &amp;cs234;</span><br><span class="line">    p6 = &amp;ss456;</span><br><span class="line">    pi = &amp;i;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;p0&lt;&lt;endl&lt;&lt;p1&lt;&lt;endl&lt;&lt;p2&lt;&lt;endl&lt;&lt;p3&lt;&lt;endl&lt;&lt;p4&lt;&lt;endl&lt;&lt;p5&lt;&lt;endl&lt;&lt;p6&lt;&lt;endl&lt;&lt;pi&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x10b906e21    char* pc = &quot;123&quot;</span></span><br><span class="line"><span class="comment">0x10b9071b8    static string ss456 = &quot;456&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x600002b1d120 string* s456 = new string&#123;&quot;456&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x7ff7b45fc900 string s123&#123;&quot;123&quot;&#125;</span></span><br><span class="line"><span class="comment">0x7ff7b45fc8e8 string s234&#123;&quot;234&quot;&#125;</span></span><br><span class="line"><span class="comment">0x7ff7b45fc8d0 const string cs123 = &quot;123&quot;</span></span><br><span class="line"><span class="comment">0x7ff7b45fc8b8 const string cs234 = &quot;234&quot;</span></span><br><span class="line"><span class="comment">0x7ff7bda118d4 const int i = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">可以看出 <span class="type">static</span> 和字符串常量在一个位置</span><br></pre></td></tr></table></figure>
<h2 id="预备知识程序的内存分配">预备知识—程序的内存分配</h2>
<figure>
<img src="https://pic1.zhimg.com/80/v2-6b739f63e83c84d07db2b7badcbe472c_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分</p>
<p>关于 bss 和数据段的区别https://zhuanlan.zhihu.com/p/28659560</p>
<p><strong>data段</strong> :用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常所说的静态存储区，赋了初值的全局变量、常量和静态变量都存放在这个域。</p>
<p>而<strong>bss段</strong>不在可执行文件中，由系统初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ar[<span class="number">30000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ar[<span class="number">300000</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现程序2编译之后所得的可执行文件比程序1大得多。</p>
<p>区别很明显，程序1位于bss段，程序2位于data段，两者的区别在于：</p>
<p>全局的未初始化变量存在于bss段中，具体体现为一个占位符，全局的已初始化变量存于data段中，而函数内的自动变量都在栈上分配空间。</p>
<p>bss不占用可执行文件空间，其内容由操作系统初始化（清零），裸机程序需要自行手动清零。</p>
<p>而data段则需要占用可执行文件空间，其内容由程序初始化，因此造成了上述情况。</p>
<p><strong>注意</strong>：</p>
<p>bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。</p>
<p>data段（已手动初始化的数据）为数据分配空间，数据保存在目标文件中。</p>
<p>data段包含经过初始化的全局变量以及它们的值。</p>
<p>BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区。</p>
<ol type="1">
<li><p><strong>Code Segment（代码区）</strong></p>
<p>也称Text Segment，存放可执行程序的机器码。</p>
<p><strong>Data Segment (数据区）</strong></p>
<p>存放已初始化的全局和静态变量， 常量数据（如<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=字符串&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A344377490%7D">字符串</a>常量）。</p>
<p><strong>BSS（Block started by symbol)</strong> better save space</p>
<p>存放未初始化的全局和静态变量。（默认设为0）</p>
<p><strong>Heap（堆）</strong></p>
<p>从低地址向高地址增长。容量大于栈，程序中动态分配的内存在此区域。</p>
<p><strong>Stack（栈）</strong></p>
<p>从高地址向低地址增长。由编译器自动管理分配。程序中的局部变量、函数参数值、返回变量等存在此区域。</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp  </span></span><br><span class="line"><span class="type">int</span>  a  =  <span class="number">0</span>;  全局初始化区  </span><br><span class="line"><span class="type">char</span>  *p1;  全局未初始化区  </span><br><span class="line"><span class="built_in">main</span>()  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">int</span>  b;  栈  </span><br><span class="line">  <span class="type">char</span>  s[]  =  <span class="string">&quot;abc&quot;</span>;  栈  </span><br><span class="line">  <span class="type">char</span>  *p2;  栈  </span><br><span class="line">  <span class="type">char</span>  *p3  =  <span class="string">&quot;123456&quot;</span>;  <span class="number">123456</span>/<span class="number">0</span>在常量区，p3在栈上。  </span><br><span class="line">  <span class="type">static</span>  <span class="type">int</span>  c  =<span class="number">0</span>；  全局（静态）初始化区  </span><br><span class="line">  p1  =  (<span class="type">char</span>  *)<span class="built_in">malloc</span>(<span class="number">10</span>);  </span><br><span class="line">  p2  =  (<span class="type">char</span>  *)<span class="built_in">malloc</span>(<span class="number">20</span>);  </span><br><span class="line">  <span class="comment">//分配得来得10和20字节的区域就在堆区。  </span></span><br><span class="line">  <span class="built_in">strcpy</span>(p1,  <span class="string">&quot;123456&quot;</span>);  <span class="comment">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="堆和栈的理论知识">堆和栈的理论知识</h2>
<h3 id="申请方式">申请方式</h3>
<ul>
<li>stack:<br />
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间<br />
</li>
<li>heap:<br />
需要程序员自己申请，并指明大小，在c中malloc函数<br />
如p1 = (char *)malloc(10);<br />
在C++中用new运算符<br />
如p2 = new char[10];<br />
<strong>但是注意p1、p2本身是在栈中的。</strong></li>
</ul>
<h3 id="申请后系统的响应">申请后系统的响应</h3>
<ul>
<li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br />
</li>
<li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序 ，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部 分重新放入空闲链表中。</li>
</ul>
<h3 id="申请大小的限制">申请大小的限制</h3>
<ul>
<li>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br />
</li>
<li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li>
</ul>
<h3 id="申请效率的比较">申请效率的比较：</h3>
<ul>
<li>栈由系统自动分配，速度较快。但程序员是无法控制的。<br />
</li>
<li>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br />
另外，在WINDOWS 下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈, 是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</li>
</ul>
<h3 id="堆和栈中的存储内容">堆和栈中的存储内容</h3>
<ul>
<li>栈：在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。<br />
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br />
</li>
<li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li>
</ul>
<h3 id="存取效率的比较">存取效率的比较</h3>
<p>char s1[] = "aaaaaaaaaaaaaaa";<br />
char *s2 = "bbbbbbbbbbbbbbbbb";<br />
aaaaaaaaaaa是在运行时刻赋值的；<br />
而bbbbbbbbbbb是在编译时就确定的；<br />
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="type">char</span>  a  =  <span class="number">1</span>;  </span><br><span class="line">  <span class="type">char</span>  c[]  =  <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">  <span class="type">char</span>  *p  =<span class="string">&quot;1234567890&quot;</span>; </span><br><span class="line">  a  =  c[<span class="number">1</span>];  </span><br><span class="line">  a  =  p[<span class="number">1</span>];  </span><br><span class="line">  <span class="keyword">return</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>对应的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:  a  =  c[1];  </span><br><span class="line">00401067  8A  4D  F1  mov  cl,byte  ptr  [ebp-0Fh]  </span><br><span class="line">0040106A  88  4D  FC  mov  byte  ptr  [ebp-4],cl  </span><br><span class="line">11:  a  =  p[1];  </span><br><span class="line">0040106D  8B  55  EC  mov  edx,dword  ptr  [ebp-14h]  </span><br><span class="line">00401070  8A  42  01  mov  al,byte  ptr  [edx+1]  </span><br><span class="line">00401073  88  45  FC  mov  byte  ptr  [ebp-4],al  </span><br></pre></td></tr></table></figure>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。</p>
<h2 id="各自优点">各自优点</h2>
<h3 id="堆heap"><strong>堆（heap）</strong></h3>
<p>堆是一个内存空间，这个内存控件可以由程序员分配和释放，当然部分语言自带 GC（ Garbage Collection 垃圾回收），部分堆内存可以由 GC 回收。</p>
<p>堆是程序在运行的时候<strong>请求操作系统分配给自己内存</strong>。由于从操作系统管理的内存分配，所以在分配和销毁时都要占用时间，因此用堆的效率相对栈来说略低。但是堆的优点在于，<strong>编译器不必知道要从堆里分配多少内存空间，也不必知道存储的数据要在堆里停留多长的时间</strong>，因此用堆保存数据时会得到更大的灵活性。因此，为达到这种灵活性，在堆里分配存储空间时会花掉相对更长的时间，这也是效率低于栈的原因。</p>
<h3 id="栈stack"><strong>栈（stack）</strong></h3>
<p>栈是由<strong>编译器自动分配和释放</strong>的，存放函数的参数值，局部变量的值等。也请注意，这里说的栈 不是数据结构中的栈，大家千万不要混淆。这里请注意，栈是由由系统自动分配。</p>
<p>栈的优势是，<strong>存取速度比堆要快，仅次于寄存器</strong>，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p>
<h1 id="类型转换"><a target="_blank" rel="noopener" href="https://blog.csdn.net/ydar95/article/details/69822540">类型转换</a></h1>
<blockquote>
<p>const_cast , static_cast , dynamic_cast , reinterpret_cast</p>
</blockquote>
<h2 id="c风格的强制转换">C风格的强制转换</h2>
<p>C风格的强制转换(Type Cast)容易理解,不管什么类型的转换都可以使用使用下面的方式.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TypeName b = (TypeName)a;<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>当然,C++也是支持C风格的强制转换,但是C风格的强制转换可能带来一些隐患,让一些问题难以察觉.所以C++提供了一组可以用在不同场合的强制转换的函数.</p>
<h2 id="c-四种强制转换类型函数">C++ 四种强制转换类型函数</h2>
<h3 id="const_cast">const_cast</h3>
<p>1、常量指针被转化成非常量的指针，并且仍然指向原来的对象； 2、常量引用被转换成非常量的引用，并且仍然指向原来的对象； 3、const_cast一般用于修改指针。如const char *p形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始数组</span></span><br><span class="line">    <span class="type">int</span> ary[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        std::cout &lt;&lt; ary[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量化数组指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>*c_ptr = ary;</span><br><span class="line">    <span class="comment">//c_ptr[1] = 233;   //error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过const_cast&lt;Ty&gt; 去常量</span></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(c_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        ptr[i] += <span class="number">1</span>;    <span class="comment">//pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印修改后的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        std::cout &lt;&lt; ary[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  out print</span></span><br><span class="line"><span class="comment">    1   2   3   4</span></span><br><span class="line"><span class="comment">    2   3   4   5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注意:对于在定义为常量的参数,使用const_cast可能会有不同的效果.类似代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_val = <span class="number">233</span>;  <span class="comment">//声明为常量类型</span></span><br><span class="line">    <span class="type">int</span> &amp;use_val = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(c_val); <span class="comment">//使用去const 引用</span></span><br><span class="line">    <span class="type">int</span> *ptr_val = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;c_val);<span class="comment">//使用去const 指针</span></span><br><span class="line"></span><br><span class="line">    use_val = <span class="number">666</span>;  <span class="comment">//未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; std::endl;</span><br><span class="line">    *ptr_val = <span class="number">110</span>; <span class="comment">//未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在 vs2017 下 输出为</span></span><br><span class="line"><span class="comment">    233 666 666</span></span><br><span class="line"><span class="comment">    233 110 110</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>未定义行为:C++标准对此类行为没有做出明确规定.同一份代码在使用不同的编译器会有不同的效果.在 vs2017 下, 虽然代码中 <em>c_val , use_val , ptr_val</em> 看到的地址是一样的.但是c_val的值并没有改变.有可能在某种编译器实现后,这一份代码的<em>c_val</em> 会被改变.也有可能编译器对这类行为直接 <em>error</em> 或 <em>warning</em>.</p>
<h3 id="static_cast">static_cast</h3>
<ol type="1">
<li>static_cast 作用和<strong>C语言风格强制转换</strong>的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。</li>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。</li>
<li>static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)</li>
<li>在c++ primer 中说道：<strong>c++ 的任何的隐式转换都是使用 <em>static_cast</em></strong> 来实现。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常规的使用方法 */</span></span><br><span class="line"><span class="type">float</span> f_pi=<span class="number">3.141592f</span></span><br><span class="line"><span class="type">int</span>   i_pi=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(f_pi); <span class="comment">/// i_pi 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* class 的上下行转换 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="built_in">static_cast</span>&lt;Sub*&gt;(&amp;base);    </span><br></pre></td></tr></table></figure>
<h3 id="dynamic_cast">dynamic_cast</h3>
<p><em>dynamic_cast</em>强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sub-&gt;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Sub * sub = <span class="keyword">new</span> <span class="built_in">Sub</span>();</span><br><span class="line">    sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Base* sub2base = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(sub);</span><br><span class="line">    <span class="keyword">if</span> (sub2base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sub2base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&lt;sub-&gt;base&gt; sub2base val is: &quot;</span> &lt;&lt; sub2base &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Base-&gt;Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Sub  *base2sub = <span class="built_in">dynamic_cast</span>&lt;Sub*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (base2sub != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        base2sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;&lt;base-&gt;sub&gt; base2sub val is: &quot;</span>&lt;&lt; base2sub &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* vs2017 输出为下</span></span><br><span class="line"><span class="comment">Sub-&gt;Base</span></span><br><span class="line"><span class="comment">I&#x27;m Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;sub-&gt;base&gt; sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base-&gt;Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;base-&gt;sub&gt; base2sub val is: 00000000   // VS2017的C++编译器,对此类错误的转换赋值为nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上边的代码和输出结果可以看出: <strong>对于<em>从子类到基类的指针转换</em> ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果</strong> <strong>而<em>从基类到子类的转换</em> , dynamic_cast 在转换时也没有报错,但是输出给 <em>base2sub</em> 是一个 <em>nullptr</em> ,说明dynami_cast 在程序运行时对类型转换对<em>“运行期类型信息”（Runtime type information，RTTI）</em>进行了检查.</strong> 这个检查主要来自<em>虚函数(virtual function)</em> 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。<em>因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数</em></p>
<h3 id="reinterpret_cast">reinterpret_cast</h3>
<p><strong>reinterpret_cast 运算符并不会改变括号中运算对象的值，而是对该对象从位模式上进行重新解释”</strong></p>
<p>reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！ 他是用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换，在下面的文章中将给出. 请看一个简单代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">233</span>);</span><br><span class="line">    <span class="type">uint32_t</span> ptr_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>&gt;(ptr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 的地址: &quot;</span> &lt;&lt; hex &lt;&lt; ptr &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;ptr_addr 的值(hex): &quot;</span> &lt;&lt; hex &lt;&lt; ptr_addr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ptr 的地址: 0061E6D8</span></span><br><span class="line"><span class="comment">ptr_addr 的值(hex): 0061e6d8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述代码将指针ptr的地址的值转换成了 <em>unsigned int</em> 类型的ptr_addr 的整数值. 提供下IBM C++ 对 reinterpret_cast 推荐使用的地方 A pointer to any integral type large enough to hold it （指针转向足够大的整数类型） A value of integral or enumeration type to a pointer （从整形或者enum枚举类型转换为指针） A pointer to a function to a pointer to a function of a different type （从指向函数的指针转向另一个不同类型的指向函数的指针） A pointer to an object to a pointer to an object of a different type （从一个指向对象的指针转向另一个不同类型的指向对象的指针） A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types （从一个指向成员的指针转向另一个指向类成员的指针！或者是类型，如果类型的成员和函数都是函数类型或者对象类型）</p>
<p>下面这个例子来自 MSDN 的一个<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/e0w9f63b(VS.80).aspx">哈希函数辅助</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// expre_reinterpret_cast_Operator.cpp  </span></span><br><span class="line"><span class="comment">// compile with: /EHsc  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a hash code based on an address  </span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">Hash</span><span class="params">(<span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">short</span>)(val ^ (val &gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">Hash</span>(a + i) &lt;&lt; endl;</span><br><span class="line">&#125;<span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h2 id="结尾">结尾</h2>
<p>在使用强制转换的时候,请先考虑清楚我们真的需要使用强制转换和我们应该使用那种强制转换. 我这只是简单的介绍这四种强制转换的用途,以上是自己的理解,文章中肯定有各种问题错误,希望大家帮忙指出矫正,本文仅供参考. 谢谢阅读.</p>
<h1 id="effective-c">Effective c++</h1>
<h2 id="绪论">绪论</h2>
<p>声明式: 告诉编译器某个东西的名称和类型</p>
<p>签名式(signature): 每个函数的声明揭示其签名式, 也就是参数和返回类型</p>
<p>定义式: 提供给编译器 一些声明式的细节, 对对象而言, 定义式是编译器为此对象拨发内存的地址; 对函数或者函数模板而言, 定义式提供了代码本体; 对于 class 而言定义式列出他们的成员</p>
<p>copy 构造函数定义了一个对象如何 passed by value</p>
<p>接口: 函数的签名或 class 内可访问的元素</p>
<h2 id="const-成员函数">const 成员函数</h2>
<p>不会对这个类的对象的数据成员作出任何改变, 即在 const 成员函数中无法赋值</p>
<table>
<thead>
<tr class="header">
<th>对象可否调用函数</th>
<th style="text-align: center;">const 对象</th>
<th style="text-align: center;">noconst 对象</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>const 成员函数</td>
<td style="text-align: center;">yes</td>
<td style="text-align: center;">yes</td>
</tr>
<tr class="even">
<td>noconst 成员函数</td>
<td style="text-align: center;">no</td>
<td style="text-align: center;">yes</td>
</tr>
</tbody>
</table>
<p>const 成员函数也不要提供修改途径(比如返回引用), 虽然可以通过编译</p>
<p>可以通过 <code>mutable</code> 在 const 函数中改变对象的数据</p>
<h2 id="构造函数-1">构造函数</h2>
<p>在构造函数中赋值相当于先初始化再赋值, 有开销 所以要用初始化列表赋值, 对象成员的初始化是在进入构造函数本体之前</p>
<p>调用构造函数初始化成员</p>
<p>避免编译器自动生成的 copy 构造函数和 copy 运算符, 声明为 private</p>
<h2 id="析构函数">析构函数</h2>
<p>析构函数的运作方式是, 最深层派生(most derived)的那个 class 其虚构函数最先被调用, 然后是调用其每一个 base class 的析构函数</p>
<p><strong>How does the compiler then call the base destructors?</strong></p>
<p>The process of destructing an object takes more operations than those you write inside the body of the destructor. When the compiler generates the code for the destructor, it adds extra code both before and after the user defined code.</p>
<p>Before the first line of a user defined destructor is called, <strong>the compiler injects code that will make the type of the object be that of the destructor being called.</strong> That is, right before <code>~derived</code> is entered, the compiler <strong>adds code that will modify the <code>vptr</code> to refer to the <code>vtable</code> of <code>derived</code>,</strong> so that effectively, the runtime type of the object <em>becomes</em> <code>derived</code> (*).</p>
<p>After the last line of your user defined code, <strong>the compiler injects calls to the member destructors as well as base destructor(s)</strong>. This is performed <strong><em>disabling</em> dynamic dispatch</strong>, which means that it will no longer come all the way down to the just executed destructor. <strong>It is the equivalent of adding <code>this-&gt;~mybase();</code></strong> for each base of the object (in reverse order of declaration of the bases) at the end of the destructor.</p>
<p>With virtual inheritance, things get a bit more complex, but overall they follow this pattern.</p>
<p><em>EDIT</em> (forgot the (<em>)): (</em>) The standard mandates in §12/3:</p>
<blockquote>
<p>When a virtual function is called directly or indirectly from a constructor (including from the mem-initializer for a data member) or from a destructor, and the object to which the call applies is the object under construction or destruction, the function called is the one defined in the constructor or destructor’s own class or in one of its bases, but not a function overriding it in a class derived from the constructor or destructor’s class, or overriding it in one of the other base classes of the most derived object.</p>
</blockquote>
<p>That requirement implies that the runtime type of the object is that of the class being constructed/destructed at this time, even if the original object that is being constructed/destructed is of a derived type. A simple test to verify this implementation can be:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">base</span> &#123;</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">base</span>() &#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;base&quot;</span>; &#125;</span><br><span class="line">  <span class="comment">//call to virtual method &quot;base::f&quot; during destruction bypasses virtual dispatch</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">derived</span> : base &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;derived&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   base * p = <span class="keyword">new</span> derived;</span><br><span class="line">   <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: base</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符">运算符</h2>
<p>调用 base 的运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base::<span class="keyword">operator</span> = (target);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2022/01/45f494d95337.html">https://sinos_wei.gitee.io/2022/01/45f494d95337.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cppreference/">cppreference</a><a class="post-meta__tags" href="/tags/int/">int</a><a class="post-meta__tags" href="/tags/std/">std</a><a class="post-meta__tags" href="/tags/template/">template</a><a class="post-meta__tags" href="/tags/const/">const</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/00000014.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/87d43a06543c.html" title="leetcode"><img class="cover" src="/img/cover/0018.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">leetcode</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/fa447478d9bd.html" title="面经"><img class="cover" src="/img/cover/000000052.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">面经</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/09/84cc1427d0ce.html" title="effective_cpp读书笔记"><img class="cover" src="/img/cover/00000050.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">effective_cpp读书笔记</div></div></a></div><div><a href="/2023/02/0c6f4ca91eef.html" title="cppdoc"><img class="cover" src="/img/cover/IMG_2433.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">cppdoc</div></div></a></div><div><a href="/2020/01/c283701d8e64.html" title="java"><img class="cover" src="/img/cover/00000071.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">java</div></div></a></div><div><a href="/2022/01/87d43a06543c.html" title="leetcode"><img class="cover" src="/img/cover/0018.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">leetcode</div></div></a></div><div><a href="/2023/05/f05961026253.html" title="数据结构"><img class="cover" src="/img/cover/00000090.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-11</div><div class="title">数据结构</div></div></a></div><div><a href="/2022/06/b17e0aa0b323.html" title="OS3pieces读书笔记"><img class="cover" src="/img/cover/IMG_4070.PNG" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">OS3pieces读书笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://8.130.42.149:5230" target="_blank" title="memo"><i class="fab fa-heart"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#inline"><span class="toc-number">1.</span> <span class="toc-text">inline</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2%E6%8F%90%E5%8D%87-integer-promotions"><span class="toc-number">2.</span> <span class="toc-text">整形提升 Integer Promotions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#thread"><span class="toc-number">3.</span> <span class="toc-text">thread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stdthread%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1.std::thread介绍及示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stdthread%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%E6%A2%B3%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">2.std::thread重要函数梳理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread%E4%B8%AD%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.thread中几个重要的成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">4.thread中的互斥量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#virtual-function-in-compiling"><span class="toc-number">4.</span> <span class="toc-text">virtual function in compiling</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%A3%B0%E6%98%8E"><span class="toc-number">5.</span> <span class="toc-text">连续声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class-and-typename"><span class="toc-number">6.</span> <span class="toc-text">class and typename</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class-memory-layout"><span class="toc-number">7.</span> <span class="toc-text">class memory layout</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#single-class"><span class="toc-number">7.1.</span> <span class="toc-text">Single class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#single-inheritance"><span class="toc-number">7.2.</span> <span class="toc-text">Single inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiple-inheritan"><span class="toc-number">7.3.</span> <span class="toc-text">Multiple inheritan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inheritance-with-a-depth-of-2"><span class="toc-number">7.4.</span> <span class="toc-text">Inheritance with a depth of 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#repeated-inheritance"><span class="toc-number">7.5.</span> <span class="toc-text">Repeated inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#single-virtual-inheritance"><span class="toc-number">7.6.</span> <span class="toc-text">Single virtual inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#the-diamond-problemwhat-is-virtual-inheritance"><span class="toc-number">7.6.1.</span> <span class="toc-text">The diamond problem(what is virtual inheritance)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiple-virtual-inheritance"><span class="toc-number">7.7.</span> <span class="toc-text">Multiple virtual inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diamond-virtual-multiple-inheritance"><span class="toc-number">7.8.</span> <span class="toc-text">Diamond virtual multiple inheritance</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sizeof"><span class="toc-number">8.</span> <span class="toc-text">sizeof</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#uml"><span class="toc-number">9.</span> <span class="toc-text">uml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#initialization"><span class="toc-number">10.</span> <span class="toc-text">initialization</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#types-in-cpp"><span class="toc-number">11.</span> <span class="toc-text">types in cpp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#aggregates-and-podplain-old-data"><span class="toc-number">12.</span> <span class="toc-text">aggregates and POD(plain old data)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c03"><span class="toc-number">12.1.</span> <span class="toc-text">c++03</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c11"><span class="toc-number">12.2.</span> <span class="toc-text">c++11</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#const-in-function"><span class="toc-number">13.</span> <span class="toc-text">const in function</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#const-in-pointer"><span class="toc-number">14.</span> <span class="toc-text">const in pointer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#traits"><span class="toc-number">15.</span> <span class="toc-text">traits</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typedef-in-stl"><span class="toc-number">16.</span> <span class="toc-text">typedef in stl</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#adl-argument-dependent-lookup"><span class="toc-number">17.</span> <span class="toc-text">ADL argument-dependent lookup</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dependent-name-name-binding"><span class="toc-number">18.</span> <span class="toc-text">dependent name &amp; name binding</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qualified-name"><span class="toc-number">19.</span> <span class="toc-text">qualified name</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nested-class"><span class="toc-number">20.</span> <span class="toc-text">nested class</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typename"><span class="toc-number">21.</span> <span class="toc-text">typename</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#the-typename-keyword"><span class="toc-number">22.</span> <span class="toc-text">The &quot;typename&quot; keyword</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#the-template-keyword"><span class="toc-number">23.</span> <span class="toc-text">The &quot;template&quot; keyword</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dependencies"><span class="toc-number">24.</span> <span class="toc-text">Dependencies</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dependent-names"><span class="toc-number">25.</span> <span class="toc-text">Dependent names</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dependent-function-names"><span class="toc-number">26.</span> <span class="toc-text">Dependent function names</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#additional-notes-and-examples"><span class="toc-number">27.</span> <span class="toc-text">Additional notes and examples</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#size_t"><span class="toc-number">28.</span> <span class="toc-text">size_t</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#compiler-default"><span class="toc-number">29.</span> <span class="toc-text">compiler default</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#default-constructor"><span class="toc-number">29.1.</span> <span class="toc-text">default constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#destructor"><span class="toc-number">29.2.</span> <span class="toc-text">destructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-constructor"><span class="toc-number">29.3.</span> <span class="toc-text">copy constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-assignment"><span class="toc-number">29.4.</span> <span class="toc-text">copy assignment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#move-assignment"><span class="toc-number">29.5.</span> <span class="toc-text">move assignment</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unix-linux-gnu"><span class="toc-number">30.</span> <span class="toc-text">UNIX Linux GNU</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-operator-overload"><span class="toc-number">31.</span> <span class="toc-text">运算符重载 operator overload</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%BC%95%E7%94%A8-this"><span class="toc-number">32.</span> <span class="toc-text">自引用 this</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#explicit"><span class="toc-number">33.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#internal-linkage"><span class="toc-number">34.</span> <span class="toc-text">internal linkage</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">35.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">36.</span> <span class="toc-text">对象与引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">36.1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">36.1.1.</span> <span class="toc-text">临时对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1"><span class="toc-number">36.1.2.</span> <span class="toc-text">普通对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">36.2.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">36.2.1.</span> <span class="toc-text">左值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">36.2.2.</span> <span class="toc-text">右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">36.3.</span> <span class="toc-text">左值右值引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#why-rvalue-is-allowed-to-passed-by-const-reference"><span class="toc-number">37.</span> <span class="toc-text">why rvalue is allowed to passed by const reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">38.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#raw-string"><span class="toc-number">39.</span> <span class="toc-text">raw string</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E7%B1%BB%E5%9E%8B"><span class="toc-number">40.</span> <span class="toc-text">变量与类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%87%BD%E5%AD%90"><span class="toc-number">41.</span> <span class="toc-text">函数对象(函子)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-template"><span class="toc-number">42.</span> <span class="toc-text">模板 template</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#enum"><span class="toc-number">43.</span> <span class="toc-text">enum</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#literal-type"><span class="toc-number">44.</span> <span class="toc-text">literal type</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#constexpr"><span class="toc-number">45.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-v-qualified-class"><span class="toc-number">46.</span> <span class="toc-text">c-v qualified class</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#accumulation"><span class="toc-number">47.</span> <span class="toc-text">accumulation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c11-vscode"><span class="toc-number">48.</span> <span class="toc-text">c++11 vscode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mid"><span class="toc-number">49.</span> <span class="toc-text">mid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stdvectorbool"><span class="toc-number">50.</span> <span class="toc-text">std::vector&lt;bool&gt;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">51.</span> <span class="toc-text">for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#varient-type-in-for-range-loop"><span class="toc-number">51.1.</span> <span class="toc-text">varient type in for range loop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const-auto-dont-use"><span class="toc-number">51.1.1.</span> <span class="toc-text">const auto (dont use)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">51.1.2.</span> <span class="toc-text">auto&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-auto-read-only"><span class="toc-number">51.1.3.</span> <span class="toc-text">const auto&amp; (read only)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-1"><span class="toc-number">51.1.4.</span> <span class="toc-text">auto&amp;&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-autodont-use"><span class="toc-number">51.1.5.</span> <span class="toc-text">const auto&amp;&amp;(dont use)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltypeauto"><span class="toc-number">51.1.6.</span> <span class="toc-text">decltype(auto)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#summary"><span class="toc-number">51.1.7.</span> <span class="toc-text">Summary</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#decltype"><span class="toc-number">52.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reverse-iterator"><span class="toc-number">53.</span> <span class="toc-text">reverse iterator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c.h%E6%96%87%E4%BB%B6-.h%E6%96%87%E4%BB%B6%E9%87%8C%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E"><span class="toc-number">54.</span> <span class="toc-text">.c&amp;.h文件 .h文件里不要定义变量，可以声明！！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-number">55.</span> <span class="toc-text">内置变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#extern"><span class="toc-number">56.</span> <span class="toc-text">Extern</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82"><span class="toc-number">57.</span> <span class="toc-text">传参</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">58.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">59.</span> <span class="toc-text">虚函数 虚基类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">59.1.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">59.2.</span> <span class="toc-text">虚基类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-%E5%AE%9A%E4%B9%89"><span class="toc-number">60.</span> <span class="toc-text">声明 定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#strcut%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">61.</span> <span class="toc-text">strcut和class的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#namespace"><span class="toc-number">62.</span> <span class="toc-text">namespace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#explicit-implicit"><span class="toc-number">63.</span> <span class="toc-text">explicit implicit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#friend-%E5%8F%8B%E5%85%83"><span class="toc-number">64.</span> <span class="toc-text">friend 友元</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#public-protect-private-%E7%BB%A7%E6%89%BF"><span class="toc-number">65.</span> <span class="toc-text">public protect private 继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">66.</span> <span class="toc-text">隐式转换和显式转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8"><span class="toc-number">67.</span> <span class="toc-text">返回引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">68.</span> <span class="toc-text">静态数据成员</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">69.</span> <span class="toc-text">缺省参数 (默认参数)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">70.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">71.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number">72.</span> <span class="toc-text">成员指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88"><span class="toc-number">73.</span> <span class="toc-text">堆与栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">73.1.</span> <span class="toc-text">预备知识—程序的内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-number">73.2.</span> <span class="toc-text">堆和栈的理论知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">73.2.1.</span> <span class="toc-text">申请方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%90%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">73.2.2.</span> <span class="toc-text">申请后系统的响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">73.2.3.</span> <span class="toc-text">申请大小的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E6%95%88%E7%8E%87%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">73.2.4.</span> <span class="toc-text">申请效率的比较：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9"><span class="toc-number">73.2.5.</span> <span class="toc-text">堆和栈中的存储内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E6%95%88%E7%8E%87%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">73.2.6.</span> <span class="toc-text">存取效率的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E8%87%AA%E4%BC%98%E7%82%B9"><span class="toc-number">73.3.</span> <span class="toc-text">各自优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86heap"><span class="toc-number">73.3.1.</span> <span class="toc-text">堆（heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88stack"><span class="toc-number">73.3.2.</span> <span class="toc-text">栈（stack）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">74.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">74.1.</span> <span class="toc-text">C风格的强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">74.2.</span> <span class="toc-text">C++ 四种强制转换类型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const_cast"><span class="toc-number">74.2.1.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static_cast"><span class="toc-number">74.2.2.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic_cast"><span class="toc-number">74.2.3.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret_cast"><span class="toc-number">74.2.4.</span> <span class="toc-text">reinterpret_cast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE"><span class="toc-number">74.3.</span> <span class="toc-text">结尾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#effective-c"><span class="toc-number">75.</span> <span class="toc-text">Effective c++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">75.1.</span> <span class="toc-text">绪论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">75.2.</span> <span class="toc-text">const 成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">75.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">75.4.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">75.5.</span> <span class="toc-text">运算符</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/a6f2ba33bf73.html" title="ts js html"><img src="/img/cover/00000197.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts js html"/></a><div class="content"><a class="title" href="/2023/07/a6f2ba33bf73.html" title="ts js html">ts js html</a><time datetime="2024-01-28T12:41:26.652Z" title="Updated 2024-01-28 20:41:26">2024-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/e6a15612f4ba.html" title="react"><img src="/img/cover/00000093.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react"/></a><div class="content"><a class="title" href="/2024/01/e6a15612f4ba.html" title="react">react</a><time datetime="2024-01-24T02:56:27.097Z" title="Updated 2024-01-24 10:56:27">2024-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/528ebafedd20.html" title="rfc笔记"><img src="/img/cover/20220911203537_1.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rfc笔记"/></a><div class="content"><a class="title" href="/2024/01/528ebafedd20.html" title="rfc笔记">rfc笔记</a><time datetime="2024-01-23T13:14:47.106Z" title="Updated 2024-01-23 21:14:47">2024-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/149566d76407.html" title="为什么这么设计"><img src="/img/cover/00000071.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为什么这么设计"/></a><div class="content"><a class="title" href="/2023/12/149566d76407.html" title="为什么这么设计">为什么这么设计</a><time datetime="2024-01-23T12:24:26.502Z" title="Updated 2024-01-23 20:24:26">2024-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/4df836237f4a.html" title="计算机网络总结"><img src="/img/cover/00000051.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络总结"/></a><div class="content"><a class="title" href="/2020/09/4df836237f4a.html" title="计算机网络总结">计算机网络总结</a><time datetime="2024-01-11T12:29:15.372Z" title="Updated 2024-01-11 20:29:15">2024-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>