
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>计算机组成原理 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="
简介



计算机组成原理实验实验 1 数据表示实验汉字编码实验机内码 计算机内存储字符时使用的编码， 如 ascii，gb2312
区位码 4 位10 进制 gb2312 汉字机内码=区位码+0,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/hb.jpg"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://sinos_wei.gitee.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">计算机组成原理</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">计算机组成原理</h1>
        <div class="stuff">
            <span>九月 12, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Organization/" rel="tag">Organization</a></li></ul>


        </div>
        <div class="content markdown">
            <blockquote>
<p>简介</p>
</blockquote>
<span id="more"></span>

<h1 id="计算机组成原理实验"><a href="#计算机组成原理实验" class="headerlink" title="计算机组成原理实验"></a>计算机组成原理实验</h1><h2 id="实验-1-数据表示实验"><a href="#实验-1-数据表示实验" class="headerlink" title="实验 1 数据表示实验"></a>实验 1 数据表示实验</h2><h3 id="汉字编码实验"><a href="#汉字编码实验" class="headerlink" title="汉字编码实验"></a>汉字编码实验</h3><p>机内码 计算机内存储字符时使用的编码， 如 ascii，gb2312</p>
<p>区位码 4 位10 进制 <code>gb2312 汉字机内码=区位码+0xA0A0</code></p>
<p>字形码</p>
<p>偶校验: 如果一组给定数据位中1的个数是奇数，补一个bit为1，使得总的1的个数是偶数。例：0000001, 补一个bit为1, 0000001<strong>1</strong></p>
<p>奇校验同理</p>
<h2 id="实验-2"><a href="#实验-2" class="headerlink" title="实验 2"></a>实验 2</h2><p>gsp  c4 c3</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk3z8s4incj31gm0pgnid.jpg" alt="截屏2020-10-27 下午4.35.03"></p>
<h2 id="实验-4"><a href="#实验-4" class="headerlink" title="实验 4"></a>实验 4</h2><h3 id="中断处理机制"><a href="#中断处理机制" class="headerlink" title="中断处理机制"></a>中断处理机制</h3><ul>
<li><p> 异常与中断概念</p>
</li>
<li><p>内部异常</p>
<ul>
<li><p>CPU内部引起的异常事件，也称内部中断</p>
</li>
<li><p>分类</p>
<ul>
<li><p>故障（Fault）</p>
<ul>
<li><p>指令执行引起，未定义指令、除数为零、缺页等</p>
</li>
<li><p>可恢复的故障，指令需恢复执行</p>
</li>
<li><p>不可恢复故障，进程被终止</p>
</li>
</ul>
</li>
<li><p>自陷（trap）</p>
<ul>
<li>系统调用、条件陷阱，位置固定，类似函数调用</li>
</ul>
</li>
<li><p>终止（Abort）</p>
<ul>
<li>随机出现的使得 CPU 无法继续执行的硬件故障，和具体指令无关。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部中断</p>
<ul>
<li><p>由外部设备向 CPU 发出的中断请求（如鼠标点击、按键动作）</p>
</li>
<li><p> CPU 暂时中断当前正在执行的程序，转去执行为某外设事件服务的中断服务程序，处理完毕后再返回断点继续执行</p>
</li>
<li><p>可屏蔽中断，非可屏蔽中断</p>
</li>
</ul>
</li>
<li><p>外部中断处理过程</p>
<ul>
<li><p>中断时机？</p>
<ul>
<li>指令执行周期最后一拍，如有中断请求则进入中断响应周期</li>
</ul>
</li>
<li><p>中断判别？</p>
<ul>
<li>外部中断会通过中断请求IntR信号发送给CPU</li>
</ul>
</li>
<li><p>完整中断流程</p>
<ul>
<li><p>中断响应</p>
<ul>
<li><p>实现中断函数的调用</p>
</li>
<li><p>中断隐指令完成的数据通路</p>
<ul>
<li><p>关中断</p>
<ul>
<li><p>清除中断使能寄存器IE</p>
</li>
<li><p>IE与中断请求逻辑与后送控制器</p>
</li>
<li><p>关中断后控制器无法接收新的中断请求</p>
</li>
</ul>
</li>
<li><p>保存断点</p>
<ul>
<li>保存PC值，X86进堆栈，MIPS送EPC</li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li>识别中断源，并将对应中断服务程序入口地址送PC</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU执行中断服务程序</p>
</li>
<li><p>中断返回</p>
<ul>
<li><p>中断服务程序最后一条指令为中断返回指令</p>
</li>
<li><p>MIPS：eret     X86：iret</p>
</li>
<li><p>单级中断中该指令开中断同时将断点地址送PC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>支持中断的CPU设计</p>
<ul>
<li><p>硬件支持</p>
<ul>
<li><p>增加中断响应周期</p>
<ul>
<li><p>修改指令执行状态机</p>
</li>
<li><p>所有指令的最后一个状态需要进行中断请求判断</p>
</li>
<li><p>有中断进入中断响应周期</p>
</li>
<li><p>中断响应周期结束进入取指令公操作</p>
</li>
</ul>
</li>
<li><p>相关硬件与数据通路</p>
<ul>
<li><p>开关中断</p>
<ul>
<li><p>增加IE寄存器，用于屏蔽中断请求，为0时关中断，为1时开中断</p>
</li>
<li><p>开中断，关中断信号分别连接置位和复位信号</p>
</li>
<li><p>默认开中断，可以连接寄存器的~Q端</p>
</li>
</ul>
</li>
<li><p>保存断点</p>
<ul>
<li><p>增加EPC寄存器/堆栈</p>
</li>
<li><p>增加EPC与PC之间的通路</p>
</li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li><p>增加中断控制逻辑</p>
</li>
<li><p>能识别中断源，产生中断请求和中断号</p>
</li>
<li><p>能根据中断号自动获取中断入口地址送PC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软件支持</p>
<ul>
<li><p>中断返回指令支持</p>
</li>
<li><p>编写中断服务程序</p>
<ul>
<li><p>保护现场</p>
<ul>
<li><p>压栈方式保护</p>
</li>
<li><p>所有在中断服务程序中被改写的通用寄存器都需要压栈</p>
</li>
<li><p>EPC，中断屏蔽字等</p>
</li>
</ul>
</li>
<li><p>中断服务</p>
</li>
<li><p>恢复现场</p>
</li>
<li><p>中断返回</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>控制器实现</p>
<ul>
<li><p>在原有状态机中增加中断响应周期路径和eret指令路径</p>
</li>
<li><p>微程序</p>
<ul>
<li><p>控制字段增加与中断相关的控制信号</p>
</li>
<li><p>判别测试字段增加Pend位，表示当前微指令为微程序的最后一条微指令，需要根据中断请求信号Intr的值进行中断判别</p>
</li>
<li><p>注意中断响应周期最后一个状态也需要设置Pend</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="mooc"><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h1><h2 id="1-计算机系统概论"><a href="#1-计算机系统概论" class="headerlink" title="1. 计算机系统概论"></a>1. 计算机系统概论</h2><ul>
<li><p>冯诺依曼结构计算的工作原理: 存储程序 程序控制</p>
<p>对应硬件: 主机(CPU(运算器, 控制器), 内存), 外设(io, 外存储器), 总线(地址线, 数据线, 控制线)</p>
<ul>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3y3el1vvj30z60imtox.jpg" alt="截屏2020-09-26 下午12.34.11"></li>
</ul>
</li>
<li><p>系统性能评价</p>
<ul>
<li><p>非时间指标: 机器字长, 总线宽度, 主存容量与存储带宽(与总线宽度和传输速度相关)</p>
</li>
<li><p>时间指标: </p>
<ul>
<li><p>主频(1/时间周期) 主频 = 外频 * 倍频</p>
</li>
<li><p>CPI(clock cycles per instruction) (加权平均)</p>
<p>CPI = 指令周期之和/指令总数</p>
</li>
<li><p>MPIS 百万为单位</p>
<p>全性能公式: MPIS = (f/CPI) * 10 ^-6^</p>
</li>
<li><p>cpu时间 = 所有指令时钟周期之和 * T</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机性能测试 几款软件</p>
</li>
</ul>
<h2 id="2-数据表示"><a href="#2-数据表示" class="headerlink" title="2. 数据表示"></a>2. 数据表示</h2><ul>
<li><p>机器数及其特点</p>
<p>反码最高位进位加到最低位</p>
</li>
<li><p>定点数与浮点数</p>
</li>
<li><p>数据校验</p>
<p>码距, 校验码增加的冗余就是为了增大码距</p>
<p>码距与纠错能力</p>
<ul>
<li>码距&gt;=e+1, 可检测 e 个错误</li>
<li>码距&gt;=2t+1, 可纠正 t 个错误</li>
<li>码距&gt;=e+t+1, 可纠正 t 个错误, 同时检测 e 个错误(e&gt;=t)</li>
</ul>
</li>
<li><p>奇偶校验</p>
<p>偶校验: 使得 1 的个数为偶数个, 所有位异或可得偶校验码, G = 传输来的所有位异或, G = 0 则无错误</p>
<p>奇校验: 所有位异或后取非, G = 传输来的所有位异或后取非, G = 0 则无错误</p>
<p>特点: 只能检测一位错误, 无错信息不可靠, 不能纠错</p>
<p>码距: 2</p>
<p>双向奇偶校验: 在传统基础上加一个垂直的校验, (右下角应该是横向的校验吧)</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj43jinnhsj30780863zv.jpg" alt="截屏2020-09-26 下午3.42.48"></p>
</li>
<li><p>crc 校验</p>
<p>N = k + r &lt;= 2^r^ - 1 k有效信息, r 校验位</p>
<p>查表得生成多项式 G(x) 然后用 G(x)进行模 2 运算(异或)得到余数, 原数据+余数组成数据发送出去, 接收方把得到的数用 G(x)进行模 2 运算, 余数为 0 则正确, 而如果余数不为 0, 余数和出错位有一个对应关系, 与 G(x)有关, 与数据无关, 要查表</p>
</li>
<li><p>海明码</p>
<p>N = k + r &lt;= 2^r^ - 1</p>
<p>设从左到右为 1 ~ k+r 位, 数据位 D, 校验位 P</p>
<p>P 在 2^n^位置</p>
<p>D<del>i</del> 中的 i 决定参与哪些 P 的校验, P = D<del>xxx</del> ^ D<del>xxx</del> ^ …</p>
<p>指错字 G<del>i</del> = P<del>i</del> ^ D<del>xxx</del> ^ D<del>xxx</del> ^ …</p>
<p>G<del>4</del>G<del>3</del>G<del>2</del>G<del>1</del> 就是出错位, 都为 0 时表示无错</p>
<p>特点: 指错字为 0 不一定无错, 一位出错和两位出错不能由指错字区分(配合奇偶校验可以区分)</p>
</li>
</ul>
<h2 id="3-运算方法与运算器"><a href="#3-运算方法与运算器" class="headerlink" title="3. 运算方法与运算器"></a>3. 运算方法与运算器</h2><ul>
<li><p>定点数运算和溢出, 定点数补码加减运算器设计</p>
<p>补码运算, 已知 Y 的补码, 求 -Y 的补码: 可从右向左扫描, 在遇到 1 及以前, 直接输出, 之后取反输出, 得到 -Y 补码/所有位取反再最后加一</p>
<p>判断溢出的三种方法</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj44y5bauwj30u012t15m.jpg" alt="深入理解计算机系统（第三版文字版）-60"></p>
<ul>
<li><p>四位串行加法器(简单)</p>
<p>实现减法?取反加一</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk3vo6mblzj30te0j6q9z.jpg" alt="截屏2020-10-27 下午2.31.44"></p>
<p>溢出检测, 第二种最简单</p>
</li>
<li><p>并行(先行)加法运算器</p>
<p>Gi=XiYi</p>
<p>Pi=Xi^Yi</p>
<p>C4 = G4+G3P4+G2P4P3+G1P4P3P2+C0P4P3P2P1</p>
<p>C3 = G3+G2P3+G1P3P2+C0P3P2P1</p>
<p>…</p>
</li>
</ul>
</li>
<li><p>原码一位乘法</p>
<p>符号位单独运算</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj45ru9yx9j311w0l4dx6.jpg" alt="截屏2020-09-26 下午4.59.45"></p>
</li>
<li><p>补码一位乘法</p>
<p>[x*y]<del>补</del> = [x]<del>补</del> * Σ(y<del>i+1</del> - y<del>i</del>) * 2^-i^</p>
<p><strong>算数右移</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj45wuj1ekj30rc0d0n6c.jpg" alt="截屏2020-09-26 下午5.04.39"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj45ywwml4j30rq08e79y.jpg" alt="截屏2020-09-26 下午5.06.47"></p>
</li>
<li><p>乘法运算器的设计</p>
<p>原码阵列乘法器</p>
<p>补码阵列乘法器</p>
</li>
<li><p>定点数除法</p>
</li>
</ul>
<h2 id="4-存储系统"><a href="#4-存储系统" class="headerlink" title="4. 存储系统"></a>4. 存储系统</h2><h3 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h3><blockquote>
<p>cache</p>
<p>cpu -&gt; cache -&gt; 主存 -&gt; 辅存</p>
</blockquote>
<p>L1 cache 集成在 CPU 中, 分数据 cache(D-Cache)和指令 cache(I-Cache)</p>
<p>L2 cahce 在主板上或与 cpu 集成在同一电路板上, 随着工艺提高 L2cahce 被集成在 cpu 内核中, 不分 d-cahce 和 i-cache</p>
<p>局部性原理:</p>
<ul>
<li><p>时间局部性</p>
<p>现在访问的信息在不久以后还会被访问</p>
</li>
<li><p>空间局部性</p>
<p>下一次访问的信息在这次访问的附近</p>
</li>
</ul>
<h3 id="主存中的数据组织"><a href="#主存中的数据组织" class="headerlink" title="主存中的数据组织"></a>主存中的数据组织</h3><ul>
<li>存储字长: 主存中一个存储单元所包含的二进制位数</li>
<li>ISA 设计时要考虑的两个问题<ul>
<li>如何根据字节地址读取一个 32 位的字 字的存放问题</li>
<li>一个字能否存放在主存的任何字节边界 字的边界对齐问题</li>
</ul>
</li>
<li>大端 高字节地址是数据的地址</li>
<li>小端 低字节地址是数据的地址</li>
</ul>
<h3 id="静态存储器的工作原理"><a href="#静态存储器的工作原理" class="headerlink" title="静态存储器的工作原理"></a>静态存储器的工作原理</h3><ul>
<li><p>SRAM 存储单元结构</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb7np7zrnj30c40gk78l.jpg" alt="截屏2020-11-02 下午10.45.20" style="zoom:33%;" />

<ul>
<li><p>工作管: t1, t2(保存数据)</p>
</li>
<li><p>负载管: t3 t4(补充电荷)</p>
</li>
<li><p>门控管: t5 t6 t7 t8(开关作用)</p>
</li>
<li><p>写操作 </p>
<p>x 有效, t5 t6 通, a 与 i/o 连通</p>
<p>y 有效, t7 t8 通, b 与 !i/o 连通</p>
<p>i/o = 1 -&gt; A = 1 -&gt; T2 通 -&gt; B = 0 -&gt; T1 截止</p>
<p>!i/o = 0 -&gt; B = 0 -&gt; T1 截止 -&gt; A = 1 -&gt; T2 通</p>
<p>此时 T1 T2形成了稳态, A = 1, B = 0</p>
<p>此时写 1</p>
<p>相反写 0</p>
</li>
<li><p>读操作</p>
<p>x 有效, t5 t6 通, a 与 i/o 连通</p>
<p>y 有效, t7 t8 通, b 与 !i/o 连通</p>
<p>读 1 的时候, A = 1, B = 0</p>
<p>通过外接于 i/o 和!i/o 之间的电流放大器中的电流方向可以判断出读的是 1 还是 0</p>
</li>
<li><p>无论读写, xy 译码线都要有效</p>
</li>
<li><p>保持: xy 撤销后, 由 t3t4 为 t1t2 提供工作电流, 保持其稳定互锁状态不变</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb825f5zuj30zs0ieh1b.jpg" alt="截屏2020-11-02 下午10.59.16"></p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb851v7z3j30rc0eq45p.jpg" alt="截屏2020-11-02 下午11.02.05"></p>
</li>
</ul>
</li>
</ul>
<h3 id="动态存储器的工作原理"><a href="#动态存储器的工作原理" class="headerlink" title="动态存储器的工作原理"></a>动态存储器的工作原理</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8bnovhcj30ys0hedwb.jpg" alt="截屏2020-11-02 下午11.08.22"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8esl6d9j30xw0is1ck.jpg" alt="截屏2020-11-02 下午11.11.27"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8j4w095j30yy0d6wpl.jpg" alt="截屏2020-11-02 下午11.15.37"></p>
<ul>
<li>集中刷新</li>
<li>分散刷新</li>
<li>异步刷新</li>
</ul>
<h3 id="存储扩展"><a href="#存储扩展" class="headerlink" title="存储扩展"></a>存储扩展</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8oqsco8j30xy0ee15g.jpg" alt="截屏2020-11-02 下午11.21.01"></p>
<p>Mk*N M:容量, N:位长</p>
<p>字扩展和位扩展</p>
<h3 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h3><p>高位多体交叉存储器: 类似字扩展</p>
<p>低位多体交叉存储器: 相邻地址存在不同存储器中, 可以并行访问, 每个单体都有单独的地址寄存器</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gki99w81cfj30vc0j6ar8.jpg" alt="截屏2020-11-09 上午1.00.10"></p>
<h3 id="cache-基本原理"><a href="#cache-基本原理" class="headerlink" title="cache 基本原理"></a>cache 基本原理</h3><p>写: 写穿策略, 写回策略</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gki9fg07sij30p60icjx1.jpg" alt="image-20201109010537809"></p>
<p>cache 结构</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gki9gnevk3j30y40ie14e.jpg" alt="截屏2020-11-09 上午1.06.33"></p>
<h3 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h3><p>相联存储器作用: 判断 cpu 要访问的内容是否在cache 中</p>
<p>贮存地址-&gt;查找依据</p>
<p>![截屏2020-11-09 上午1.14.27](../../../../Library/Application Support/typora-user-images/截屏2020-11-09 上午1.14.27.png)</p>
<h3 id="cache-地址映射和变换方法"><a href="#cache-地址映射和变换方法" class="headerlink" title="cache 地址映射和变换方法"></a>cache 地址映射和变换方法</h3><ul>
<li><p>全相联</p>
<p>主存分块, cache 分行, 大小一致, 将主存的地址变为二维地址(块地址tag+块内序号 (字))</p>
<p>![image-20201109012214178](../../../../Library/Application Support/typora-user-images/image-20201109012214178.png)</p>
<p>cache 所有空间都可以利用, 但是比对过程复杂, 适用于小容量 cache</p>
</li>
<li><p>直接相联</p>
<p>主存分块, cache 分行, 大小一致</p>
<p>主存地址分为三部分, tag index offset</p>
<p>tag 就是 tag, index 为 cache 的哪一行, offset 为第几个字, 形成一个三维结构</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkia2k5rnqj31240fsanl.jpg" alt="截屏2020-11-09 上午1.27.33"></p>
<p>cache 利用率低, 容易冲突, 但是淘汰算法简单, 适用于大容量 cache</p>
</li>
<li><p>组相联</p>
<p>主存分块, cache 分行, 大小一致</p>
<p>cache 分组, 每组含 k 行, 以组队内存进行划分</p>
<p>主存地址分为: tag, 组号, index 第几组, offset 第几个字</p>
</li>
</ul>
<h3 id="替换算法-淘汰算法"><a href="#替换算法-淘汰算法" class="headerlink" title="替换算法(淘汰算法)"></a>替换算法(淘汰算法)</h3><ul>
<li>先进先出算法FIFO 维持一个计数器, 先进来的先被替换</li>
<li>最不经常使用算法LFU 维持一个计数器, 命中++, 把命中的最少的淘汰掉</li>
<li>近期最少使用LRU 维持一个计数器, 把访问间隔时间最长的替换掉</li>
<li>随机替换法 </li>
</ul>
<h3 id="高速缓冲存储器例题"><a href="#高速缓冲存储器例题" class="headerlink" title="高速缓冲存储器例题"></a>高速缓冲存储器例题</h3><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>解决主存不足的问题</p>
<p>处于主存-辅存层次</p>
<p>页式虚拟存储器</p>
<p>MMU(memery management unit)管理虚拟存储器和物理存储器 </p>
<p>虚拟地址: 虚页号+页偏移量</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4nbq8cej30ti0f4n4q.jpg" alt="截屏2020-11-09 下午7.05.43"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4p8qm7kj30rw0icdlv.jpg" alt="截屏2020-11-09 下午7.07.37"></p>
<h3 id="TLB-translation-lookaside-buffer"><a href="#TLB-translation-lookaside-buffer" class="headerlink" title="TLB(translation lookaside buffer)"></a>TLB(translation lookaside buffer)</h3><p>虚拟地址的转换 PTE 页表项</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4tuy6pij30u00dgwkx.jpg" alt="截屏2020-11-09 下午7.12.02"></p>
<p> <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4vv63evj31340hen7i.jpg" alt="截屏2020-11-09 下午7.13.58"></p>
<p>TLB: 增加一个小容量, 高速存储部件存放当前访问页表地址变换条目</p>
<p>基于 TLB 的虚实地址转换</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj504t8jcj31060pg154.jpg" alt="截屏2020-11-09 下午7.18.04"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj5493tzzj30vu0ky7c0.jpg" alt="截屏2020-11-09 下午7.22.02"></p>
<h3 id="RAID-redundant-arrays-of-inexpensive-disks-gt"><a href="#RAID-redundant-arrays-of-inexpensive-disks-gt" class="headerlink" title="RAID(redundant arrays of inexpensive disks-&gt;"></a>RAID(redundant arrays of inexpensive disks-&gt;</h3><h3 id="redundant-arrays-of-independent-disks"><a href="#redundant-arrays-of-independent-disks" class="headerlink" title="redundant arrays of independent disks)"></a>redundant arrays of independent disks)</h3><p>核心技术: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1^0&#x3D;1 1&#x3D;0^1</span><br><span class="line">1^1&#x3D;0 1&#x3D;1^0</span><br><span class="line">0^0&#x3D;0 0&#x3D;0^0</span><br></pre></td></tr></table></figure>

<p>有一个磁盘坏了, 可以通过异或得到原来的数据</p>
<ul>
<li><p>RAID0 没有冗余</p>
<p>数据以条带方式均匀分布在各个磁盘(并行)</p>
<p>优点: 磁盘读写效率高</p>
<p>缺点: 无冗余</p>
</li>
<li><p>RAID1</p>
<p>数据采用镜像的冗余方式, 一个数据有多分拷贝</p>
<p>优点: 100%数据冗余, 理论上可以实现两倍读取速率</p>
<p>缺点: 空间利用率只有 1/2 </p>
</li>
<li><p>RAID3 RAID4</p>
<p>数据按位(3)/条(4)并行传输到多个磁盘上, 同时校验数据存放到专用校验盘上</p>
<p>优点: 磁盘利用率=(N-1)/N</p>
<p>缺点: 控制器复杂, 校验磁盘的写性能有瓶颈</p>
</li>
<li><p>RAID5</p>
<p>数据按条分布在不同的磁盘上, 但校验信息被均匀的分散到各个磁盘上 </p>
</li>
<li><p>RAID10</p>
<p>结合 RAID0 和 RAID1, 先镜像, 再条带化</p>
</li>
<li><p>RAID01</p>
<p>结合 RAID0 和 RAID1, 先条带化, 再镜像</p>
</li>
</ul>
<h2 id="5-指令系统"><a href="#5-指令系统" class="headerlink" title="5. 指令系统"></a>5. 指令系统</h2><h3 id="指令系统概述和指令格式"><a href="#指令系统概述和指令格式" class="headerlink" title="指令系统概述和指令格式"></a>指令系统概述和指令格式</h3><p>指令系统: 一台计算机中所有机器指令的集合</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkjbtdzm8oj318y0bctin.jpg" alt="截屏2020-11-09 下午11.13.47"></p>
<p>指令分类</p>
<ul>
<li>地址码字段的分类<ul>
<li>三地址</li>
<li>二地址</li>
<li>一地址</li>
<li>零地址</li>
</ul>
</li>
<li>操作数的物理位置<ul>
<li>存储器, 存储器 SS</li>
<li>寄存器, 寄存器 RR</li>
<li>寄存器, 存储器 RS</li>
</ul>
</li>
<li>功能</li>
</ul>
<p>指令格式</p>
<p>操作码字段+寻址方式+地址码字段</p>
<h3 id="寻址方式-指令寻址"><a href="#寻址方式-指令寻址" class="headerlink" title="寻址方式 指令寻址"></a>寻址方式 指令寻址</h3><ul>
<li><p>指令寻址</p>
<ul>
<li><p>顺序寻址</p>
<p>指令序列在主存中顺序存放, 逐条执行</p>
<p>CPU 中设置 PC 程序计数器</p>
</li>
<li><p>跳跃寻址</p>
<p><code>JMP</code> </p>
</li>
</ul>
</li>
</ul>
<h3 id="操作数寻址"><a href="#操作数寻址" class="headerlink" title="操作数寻址"></a>操作数寻址</h3><ul>
<li><p>立即数寻址 <code>mov ax, 200h</code></p>
</li>
<li><p>寄存器寻址 <code>mov ax, bx</code></p>
</li>
<li><p>直接寻址 <code>mov ax, [200h]</code></p>
</li>
<li><p>间接寻址 <code>mov ax, i[200h]</code> 访问两次内存, 第一次访问主存得到地址, 再访问主存得到数据</p>
</li>
<li><p>寄存器间接寻址 <code>mov ax, [bx]</code> 访问一次主存</p>
</li>
<li><p>相对寻址 注意 pc 值在跳转过程的变化(+1)</p>
<p>从 2003h-&gt;200Ah : 200Ah-(2003h+2) = 5</p>
</li>
<li><p>基址寻址 <code>mov ax, 32[b]</code></p>
</li>
<li><p>变址寻址 <code>mov ax, 32[si]</code> 可循环</p>
</li>
</ul>
<h3 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h3><p><strong>操作码字段 寻址方式 地址码字段</strong></p>
<h3 id="MIPS-32-指令概述"><a href="#MIPS-32-指令概述" class="headerlink" title="MIPS(32) 指令概述"></a>MIPS(32) 指令概述</h3><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p><img src="http://tva1.sinaimg.cn/large/0081Kckwgy1gl54xmkf0uj314o0o4x0u.jpg" alt="截屏2020-11-28 下午7.58.05"></p>
<h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ul>
<li>立即数寻址</li>
<li>寄存器直接寻址</li>
<li>基址寻址</li>
<li>相对寻址</li>
<li>伪直接寻址</li>
</ul>
<h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4><h2 id="6-cpu"><a href="#6-cpu" class="headerlink" title="6. cpu"></a>6. cpu</h2><ul>
<li><p>6.1      中央处理器概述</p>
<ul>
<li><p>6.1.1       中央处理器的功能</p>
<ul>
<li><p>循环取指令执行指令</p>
<ul>
<li><p>程序控制</p>
<ul>
<li>控制程序中指令执行的顺序</li>
</ul>
</li>
<li><p>操作控制</p>
<ul>
<li>产生指令执行过程中所需要的操作控制信号</li>
</ul>
</li>
<li><p> 时序控制</p>
</li>
<li><p>对每个操作控制信号进行定时，严格控制每个操作控制信号的开始时间和持续时间</p>
</li>
<li><p> 数据加工</p>
</li>
<li><p>即对数据进行算术、逻辑运算，或将数据在相关部件之间传送。</p>
</li>
<li><p>中断处理</p>
<ul>
<li>CPU 应能及时响应内部异常和外部中断请求</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.1.2       中央处理器的组成</p>
<ul>
<li><p>控制器</p>
<ul>
<li>时序发生器、操作控制器</li>
</ul>
</li>
<li><p>运算器</p>
<ul>
<li>ALU、寄存器文件</li>
</ul>
</li>
<li><p>常用寄存器</p>
<ul>
<li><p>PC (Program Counter)——程序计数器     </p>
<ul>
<li>X86：EIP  MIPS：PC</li>
</ul>
</li>
<li><p>IR (Instruction Register)——指令寄存器                      [可选]</p>
</li>
<li><p>AR (Address Register)——地址寄存器      MAR           [可选]</p>
</li>
<li><p>DR (Data Register)——数据缓冲寄存器     MDR          [可选]</p>
</li>
<li><p>AC (Accumulate Count)——累加寄存器                      [可选]</p>
<ul>
<li>常见于早期计算机</li>
</ul>
</li>
<li><p>PSW (Program Status Word)——程序状态字               [可选]</p>
<ul>
<li>X86： EFLAGS   MIPS：无</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.2      指令周期</p>
<ul>
<li><p>6.2.1       指令执行的一般流程</p>
<ul>
<li>图解<img src="https://api2.mubu.com/v3/document_image/50029e8b-b45f-4abd-8a5f-83a16b879dde-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>6.2.2       指令周期的基本概念</p>
<ul>
<li><p>通常将一条指令从取出到执行完成所需要的时间称为指令周期</p>
<ul>
<li><p>若干机器周期</p>
<ul>
<li><p>机器周期：取指令所需要的最短时间，指令cache命中时最短</p>
</li>
<li><p>一个机器周期又包括若干时钟周期，可以进行一系列复杂的操作</p>
</li>
<li><p>一个时钟周期只能进行简单的微操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最简单的划分：取指周期+执行周期+中断周期</p>
<ul>
<li>执行周期还可以进一步细分，如间址周期</li>
</ul>
</li>
<li><p>不同的寻址方式，不同的设计指令周期划分是不确定的</p>
</li>
</ul>
</li>
<li><p>6.2.3       寄存器传送语言</p>
<ul>
<li>用于描述指令执行过程中的数据通路</li>
</ul>
</li>
</ul>
</li>
<li><p>6.3      数据通路及指令操作流程</p>
<ul>
<li><p>6.3.1       数据通路模型与定时</p>
<ul>
<li><p>常见数据图解<img src="https://api2.mubu.com/v3/document_image/1a4635b4-ff95-4071-a099-6fa8ca5be453-329792.jpg" alt="img"></p>
</li>
<li><p>数据通路的时钟频率取决于数据处理单元的关键延迟</p>
</li>
</ul>
</li>
<li><p>6.3.2       基于单总线结构的数据通路</p>
<ul>
<li><p>基本特征</p>
<ul>
<li><p>CPU 中的运算器、控制器、寄存器堆等核心部件均通过一条内部的公共总线连接起来</p>
</li>
<li><p>同一时刻只有一个部件向总线输出数据</p>
</li>
<li><p>数据传输只能分时使用总线</p>
</li>
</ul>
</li>
<li><p>数据通路图解</p>
<ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/de297a77-e1a7-4624-ab32-74542bf0bc8e-329792.jpg" alt="img"></p>
</li>
<li><p>指令周期图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/b837e953-d556-493b-a5bd-2bf1efee0fbe-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.3.3       基于专用通路结构的数据通路</p>
<ul>
<li><p>基本特征</p>
<ul>
<li><p>各功能部件之间均基于专用的数据传输通路连接</p>
</li>
<li><p>各通路中的数据可并行传输，控制较总线结构要简单</p>
</li>
</ul>
</li>
<li><p>单周期MIPS</p>
<ul>
<li><p>所有指令一个时钟周期完成，CPI=1，但时钟频率取决于最慢的LW指令</p>
</li>
<li><p>数据、指令分开存放保证取指令和取操作数并行</p>
</li>
<li><p>运算PC、运算分支地址、运算数据所需的ALU分别设置，成本较高</p>
</li>
<li><p>控制器为组合逻辑，不同指令产生不同的控制信号组合，形成对应的数据通路</p>
</li>
</ul>
</li>
<li><p>多周期MIPS（不考）</p>
<ul>
<li><p>不再区分指令存储器和数据存储器，指令和数据保存在同一存储器中。</p>
</li>
<li><p> 部分功能单元，如 A</p>
</li>
<li><p>LU可在一条指令执行过程的不同时钟周期中多次使用，不需要额外设置ALU或加法器。</p>
</li>
<li><p>主要功能单元输出端都增加了一些附加寄存器，方便暂存当前时钟周期加工处理的数据给后续时钟周期使用</p>
<ul>
<li><p>DR、IR</p>
</li>
<li><p>A、B  缓存寄存器操作数</p>
</li>
<li><p>C 缓存分支地址或ALU运算结果</p>
</li>
<li><p>增加和扩展了部分多路选择器</p>
</li>
<li><p>增加了ALU控制器</p>
<ul>
<li><p>专门负责产生 ALU 的运算选择控制信号 AluOP</p>
</li>
<li><p>方便合并R型运算指令以及I型指令的状态机</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>指令周期图解</p>
<ul>
<li><p>注意S2，S5状态可以合并，R型运算指令共享S8<del>S9路径，I型运算共享S10</del>S11路径<img src="https://api2.mubu.com/v3/document_image/b5c00733-af77-4711-9c26-dc5f7f220ed0-329792.jpg" alt="img"></p>
</li>
<li><p>控制器是时序逻辑，需要实现尚需状态机，每一个圆圈一个时钟周期</p>
</li>
<li><p>不同指令时钟周期数不一样</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.4      时序与控制</p>
<ul>
<li><p>6.4.1       中央处理器的时序</p>
<ul>
<li><p>传统三级时序</p>
<ul>
<li><p>机器周期电位、节拍电位、节拍脉冲</p>
</li>
<li><p>时序图</p>
<ul>
<li><p>一条指令包括x个机器周期，一个机器周期包括y个节拍，一个节拍包括z个脉冲<img src="https://api2.mubu.com/v3/document_image/a33be99e-bc66-4436-998e-bca2a2fb81f4-329792.jpg" alt="img"></p>
</li>
<li><p>x，y，z的值与指令寻址方式，CPU设计等有关，可固定，也可以变化</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>现代时序：只有时钟周期，指令执行过程是时钟驱动的状态机</p>
</li>
</ul>
</li>
<li><p>6.4.2       控制方式</p>
<ul>
<li><p>同步控制</p>
<ul>
<li><p>指令周期定长</p>
</li>
<li><p>机器周期数固定</p>
</li>
</ul>
</li>
<li><p>异步控制</p>
<ul>
<li><p>按需分配时钟</p>
</li>
<li><p>指令周期可变，机器周期可变</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.4.3       时序发生器</p>
<ul>
<li><p>输入时钟脉冲信号，指令译码信号、反馈信号持续不断的产生状态周期电位和节拍电位，操作控制器利用这些周期、节拍电位信号对操作控制信号进行时序的调制，生成控制信号序列。</p>
</li>
<li><p>输入：clk，指令译码、反馈信号</p>
</li>
<li><p>输出：状态周期电位，节拍电位</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/1abe4764-4514-435f-b534-2407d3e520fb-329792.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/f512c9fb-8f50-4b21-a49e-7814f5249688-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>设计思路</p>
<ul>
<li><p>利用数字逻辑同步时序电路设计方法进行构造，根据状态机进行实现</p>
</li>
<li><p>定长指令周期状态机</p>
<ul>
<li>状态切换只与时钟信号有关<img src="https://api2.mubu.com/v3/document_image/7cfd71a3-b48c-4735-a505-4e6460e37ea0-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>变长指令周期状态机</p>
<ul>
<li>状态切换还与指令译码有关<img src="https://api2.mubu.com/v3/document_image/47faac3c-6d3b-44df-bf74-13495098dc50-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.5      硬布线控制器</p>
<ul>
<li><p>6.5.1       三级时序硬布线控制器</p>
<ul>
<li><p>硬布线控制器是组合逻辑</p>
<ul>
<li><p>输入：指令译码、状态周期电位、节拍电位、反馈信号</p>
</li>
<li><p>输出Cn：微操作控制器信号序列</p>
</li>
<li><p>逻辑函数<img src="https://api2.mubu.com/v3/document_image/ebded0fa-35ac-4d6c-a252-ae2c43a47c31-329792.jpg" alt="img"></p>
</li>
<li><p>例子<img src="https://api2.mubu.com/v3/document_image/dd7dd982-93ff-4bf9-9e4b-cdb4c451e462-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>图例<img src="https://api2.mubu.com/v3/document_image/7f324698-97c6-4832-8ad7-4c929cbd40f2-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>6.5.2       三级时序硬布线控制器设计</p>
<ul>
<li><p>设计流程</p>
<ul>
<li><p>分析指令执行的数据通路，列出各指令执行操作流程每一步所需要的控制信号</p>
</li>
<li><p> 对指令的操作流程进行细化，将每条指令的每个微操作分配到具体机器周期的具体时间节拍信号上，即对操作控制信号进行同步控制</p>
</li>
<li><p> 根据控制信号同步控制方式构造合适的时序发生器</p>
</li>
<li><p> 对每一个控制信号进行逻辑综合，得到每个控制信号的逻辑表达式</p>
</li>
<li><p> 最后采用逻辑门或 PLA 或 ROM 实现逻辑表达式的功能</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.5.3       现代时序硬布线控制器</p>
<ul>
<li><p>核心是有限状态机</p>
</li>
<li><p>控制信号是现态的函数</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/0daf4262-d213-490b-b1b0-231b30a6dcab-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>6.5.4       现代时序硬布线控制器设计</p>
<ul>
<li><p>设计流程</p>
<ul>
<li><p>分析指令执行的数据通路，列出每条指令执行操作流程每一步所需要的控制信号</p>
</li>
<li><p> 对指令的操作流程进行细化，将每条指令的每个微操作分配到具体时钟节拍上</p>
</li>
<li><p> 以时钟周期为单位构建指令执行状态图，生成状态转换表，实现有限状态机</p>
</li>
<li><p> 收集每一个控制信号产生的所有状态条件，得到每个控制信号的逻辑表达式。</p>
</li>
<li><p> 最后采用逻辑门或 PLA 或 ROM 实现硬布线控制器逻辑</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.6      微程序控制器</p>
<ul>
<li><p>6.6.1       微程序控制的基本概念</p>
<ul>
<li><p>存储逻辑：控制信号序列不由硬件产生，而是像程序一样存储起来</p>
<ul>
<li><p>控制信号序列分解为若干时钟节拍</p>
</li>
<li><p>一个节拍的控制信号编成一条微指令</p>
</li>
<li><p>一条指令有多少节拍就对应多少条微指令，形成一段微程序</p>
</li>
<li><p>取指令过程是公操作，取指令过程对应取指微程序，取指微程序为所有指令共享</p>
</li>
<li><p>控存中的微程序图解<img src="https://api2.mubu.com/v3/document_image/98eb7b3b-ac19-4da5-9c90-fdefe3009d46-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>软时序：依序执行微指令即可生成控制信号序列</p>
<ul>
<li><p>执行一条微指令，给出对应的控制信号</p>
</li>
<li><p>微指令周期就是一个时钟周期，控制器信号的时间长度就是一个节拍</p>
</li>
<li><p>软时序：按顺序执行微指令，就是按顺序给出控制信号</p>
</li>
<li><p>指令取指执行→微程序执行→ 微指令执行→生成控制信号序列</p>
</li>
</ul>
</li>
<li><p>微指令格式</p>
<ul>
<li><p>操作控制字段：存储微操作控制信号</p>
<ul>
<li>每一位对应一个控制信号，也称微命令，可同时给出多个操作信号</li>
</ul>
</li>
<li><p>顺序控制字段：控制微程序执行顺序</p>
<ul>
<li><p>判别测试位：如果为1，要约定条件生成下一条微指令地址</p>
</li>
<li><p>下址字段：判别测试条件为0时下一条微指令的地址</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>图解<img src="https://api2.mubu.com/v3/document_image/6e825efb-3223-4ea2-8bdf-43f4cf234cb7-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>6.6.2       微程序控制器组成原理</p>
<ul>
<li><p>初始化，微地址寄存器为0,控存0号单元为取指令微程序入口</p>
</li>
<li><p>下址字段法<img src="https://api2.mubu.com/v3/document_image/5ce99f63-5b98-48ce-a0a3-e3ec53b02d3a-329792.jpg" alt="img"></p>
</li>
<li><p>计数器法</p>
<ul>
<li>增加一个Pend，表示最后一条微指令，下一条微指令应该返回取指微程序<img src="https://api2.mubu.com/v3/document_image/2b6dd194-5a6b-406e-8a9f-5846ae257b5f-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>6.6.3       微程序控制器设计</p>
<ul>
<li><p>分析指令执行的数据通路，给出控制信号序列，根据控制信号设计微指令控制字段</p>
</li>
<li><p> 以时钟周期为单位构建指令执行状态图。</p>
</li>
<li><p>一个状态对应一条微指令</p>
</li>
<li><p>根据状态机设计微指令，安排微程序，状态字等价于微地址</p>
</li>
<li><p>根据状态机分支情况设置判别测试位</p>
</li>
<li><p>根据控存中微程序存放组织方式构建微程序控制器中的地址转移逻辑，微地址寄存器μAR、控存之间的通路，实现微程序控制器</p>
</li>
</ul>
</li>
<li><p>6.6.4       微指令及其编码方法</p>
<ul>
<li><p>微指令编码方法</p>
<ul>
<li><p>直接表示法</p>
<ul>
<li>简单，并行，速度快，微指令字长</li>
</ul>
</li>
<li><p>编码表示法</p>
<ul>
<li>微指令字短、增加译码器延迟</li>
</ul>
</li>
<li><p>混合表示法</p>
</li>
</ul>
</li>
<li><p>微指令格式</p>
<ul>
<li><p>水平微指令</p>
<ul>
<li>编程难，微程序短，并行性高，速度快，控存开销大</li>
</ul>
</li>
<li><p>垂直微指令</p>
<ul>
<li>编程易，微程序长，并行性差，速度慢，控存开销小，已淘汰</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.7      异常与中断处理</p>
<ul>
<li><p> 异常与中断概念</p>
</li>
<li><p>内部异常</p>
<ul>
<li><p>CPU内部引起的异常事件，也称内部中断</p>
</li>
<li><p>分类</p>
<ul>
<li><p>故障（Fault）</p>
<ul>
<li><p>指令执行引起，未定义指令、除数为零、缺页等</p>
</li>
<li><p>可恢复的故障，指令需恢复执行</p>
</li>
<li><p>不可恢复故障，进程被终止</p>
</li>
</ul>
</li>
<li><p>自陷（trap）</p>
<ul>
<li>系统调用、条件陷阱，位置固定，类似函数调用</li>
</ul>
</li>
<li><p>终止（Abort）</p>
<ul>
<li>随机出现的使得 CPU 无法继续执行的硬件故障，和具体指令无关。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部中断</p>
<ul>
<li><p>由外部设备向 CPU 发出的中断请求（如鼠标点击、按键动作）</p>
</li>
<li><p> CPU 暂时中断当前正在执行的程序，转去执行为某外设事件服务的中断服务程序，处理完毕后再返回断点继续执行</p>
</li>
<li><p>可屏蔽中断，非可屏蔽中断</p>
</li>
</ul>
</li>
<li><p>外部中断处理过程</p>
<ul>
<li><p>中断流程</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/3efffa6b-20d3-41d8-82c6-2cfeca1f0cd4-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>中断时机？</p>
<ul>
<li>指令执行周期最后一拍，如有中断请求则进入中断响应周期</li>
</ul>
</li>
<li><p>中断判别？</p>
<ul>
<li>外部中断会通过中断请求IntR信号发送给CPU</li>
</ul>
</li>
<li><p>完整中断流程</p>
<ul>
<li><p>中断响应</p>
<ul>
<li><p>实现中断函数的调用</p>
</li>
<li><p>中断隐指令完成的数据通路</p>
<ul>
<li><p>关中断</p>
<ul>
<li><p>清除中断使能寄存器IE</p>
</li>
<li><p>IE与中断请求逻辑与后送控制器</p>
</li>
<li><p>关中断后控制器无法接收新的中断请求</p>
</li>
</ul>
</li>
<li><p>保存断点</p>
<ul>
<li>保存PC值，X86进堆栈，MIPS送EPC</li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li>识别中断源，并将对应中断服务程序入口地址送PC</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU执行中断服务程序</p>
</li>
<li><p>中断返回</p>
<ul>
<li><p>中断服务程序最后一条指令为中断返回指令</p>
</li>
<li><p>MIPS：eret     X86：iret</p>
</li>
<li><p>单级中断中该指令开中断同时将断点地址送PC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>支持中断的CPU设计</p>
<ul>
<li><p>硬件支持</p>
<ul>
<li><p>增加中断响应周期</p>
<ul>
<li><p>修改指令执行状态机</p>
<ul>
<li>传统时序状态机<ul>
<li><img src="https://api2.mubu.com/v3/document_image/f70b744c-ebf2-46ae-8054-c44a60303ddc-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>现代时序状态机</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/b95070b0-98a5-4551-8da2-8e866e337529-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li><p>所有指令的最后一个状态需要进行中断请求判断</p>
</li>
<li><p>有中断进入中断响应周期</p>
</li>
<li><p>中断响应周期结束进入取指令公操作</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>相关硬件与数据通路</p>
<ul>
<li><p>开关中断</p>
<ul>
<li><p>增加IE寄存器，用于屏蔽中断请求，为0时关中断，为1时开中断</p>
</li>
<li><p>注意初始化时应该默认开中断</p>
</li>
</ul>
</li>
<li><p>开中断，关中断信号分别连接置位和复位信号</p>
<ul>
<li><p>默认开中断，可以连接寄存器的~Q端</p>
</li>
<li><p><img src="https://api2.mubu.com/v3/document_image/04a6d766-3947-4886-afef-9040dc7a5038-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>保存断点</p>
</li>
<li><p>增加EPC寄存器/堆栈</p>
</li>
<li><p>增加EPC与PC之间的通路</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/5db28da8-3982-4382-960c-77912759a36a-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li><p>增加中断控制逻辑</p>
</li>
<li><p>能识别中断源，产生中断请求和中断号</p>
</li>
<li><p>能根据中断号自动获取中断入口地址送PC</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/e7da8ad8-18e6-4141-9472-db00c197f905-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>软件支持</p>
<ul>
<li><p>中断返回指令支持</p>
</li>
<li><p>编写中断服务程序</p>
</li>
<li><p>保护现场</p>
<ul>
<li><p>压栈方式保护</p>
</li>
<li><p>所有在中断服务程序中被改写的通用寄存器都需要压栈</p>
</li>
<li><p>EPC，中断屏蔽字等</p>
</li>
</ul>
</li>
<li><p>中断服务</p>
</li>
<li><p>恢复现场</p>
</li>
<li><p>中断返回</p>
</li>
<li><p>图解</p>
</li>
<li><p><img src="https://api2.mubu.com/v3/document_image/5c589cbf-4251-4b78-8e63-5e82c56975a2-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>控制器实现</p>
<ul>
<li><p>在原有状态机中增加中断响应周期路径和eret指令路径</p>
</li>
<li><p>微程序</p>
</li>
<li><p>控制字段增加与中断相关的控制信号</p>
</li>
<li><p>判别测试字段增加Pend位，表示当前微指令为微程序的最后一条微指令，需要根据中断请求信号Intr的值进行中断判别</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/3e281b8b-61b9-4ed4-b5d6-05fc58c86bc7-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h2><h3 id="程序被翻译为不同的格式"><a href="#程序被翻译为不同的格式" class="headerlink" title="程序被翻译为不同的格式"></a>程序被翻译为不同的格式</h3><p>上下文</p>
<p>hello.c -预处理器(cpp, preprocesser)-&gt; hello.i -编译器(ccl, compiler)-&gt; hello.s -汇编器(as, assembler)-&gt; hello.o -连接器(ld, linker)-&gt; hello</p>
<p>GNU 项目 GNU is not Unix</p>
<p>​    GCC(GNU compiler collection), GDB(GNU debugger) 工具</p>
<h3 id="系统硬件"><a href="#系统硬件" class="headerlink" title="系统硬件"></a>系统硬件</h3><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>字长, bit byte 为国际单位, 字长不是, 字长与机器本身相关</p>
<h4 id="io-设备"><a href="#io-设备" class="headerlink" title="io 设备"></a>io 设备</h4><p>每个 io 设备都通过一个控制器或适配器与 io 总线相连</p>
<p>控制器是io 设备本身或者系统的主印刷电路板上的芯片组</p>
<p>适配器是一块插在主板插槽上的卡</p>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>DRAM(dynamic random access memory)</p>
<h4 id="处理器-CPU"><a href="#处理器-CPU" class="headerlink" title="处理器 CPU"></a>处理器 CPU</h4><p>处理器的核心是一个大小为一个字的存储设备(寄存器), 成为程序计数器(PC), PC 在任何时候都指向主存中的某条机器指令</p>
<p>处理器的</p>
<p>​    指令集架构: 每条机器代码指令的效果</p>
<p>​    微体系结构: 处理器实际上是如何实现的</p>
<h3 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h3><p>由快到慢: 寄存器, L1 高速缓存, L2 高速缓存, L3 高速缓存, DRAM, 本地二级存储(本地硬盘), 远程二级存储(分布式文件系统, web 服务器)</p>
<h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>上下文切换</p>
<p>内核: 内核是操作系统代码常驻主存的部分</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>每个线程都运行在进程的上下文中, 并共享同样的代码和全局数据</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gip88f6ju0j30mh0inths.jpg" alt="IMG_FB723107648D-1"></p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h3 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h3><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><blockquote>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。</p>
<p>所以我认为它们最关键的点就是：是否是『同时』。</p>
<p><strong>转自知乎</strong></p>
</blockquote>
<p><strong>处理器</strong>, 和操作系统课的并发区分! </p>
<p>并发: 指一个同时具有多个活动的系统</p>
<p>并行: 用并发来使一个系统运行的更快</p>
<h5 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h5><p>单处理器</p>
<p>多核处理器</p>
<p>超线程(同时多线程)???</p>
<h5 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h5><p>现代处理器可以同时执行多条指令的属性称为指令级并行</p>
<p>超标量: 如果处理器可以达到比一个周期一条指令更快的执行速率, 就称之为超标量处理器</p>
<h5 id="单指令-多数据并行"><a href="#单指令-多数据并行" class="headerlink" title="单指令, 多数据并行"></a>单指令, 多数据并行</h5><p>允许一条指令产生多个可以并行执行的操作</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><h2 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h2><p>ISO: international organization for standardization</p>
<h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><p>内存 –&gt; 虚拟内存</p>
<p>每个字节 –&gt; 地址</p>
<p>所有可能的地址的集合 –&gt; 虚拟地址空间</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj41qk2i2gj30gv0exafo.jpg" alt="IMG_0A3C8AB125D9-1"></p>
<p>0x12345678</p>
<p>大端 12 34 56 78</p>
<p>小端 78 56 34 12</p>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><ul>
<li><p>检测无符号加法中的溢出</p>
<p>S = x + y - 2^w^</p>
<p>而 x, y &lt; 2^w^</p>
<p>所以 S &lt; x, y</p>
</li>
<li><p>无符号数求反</p>
<p>!x = 2^w^ - x</p>
<p>∵ !x + x = 2^w^</p>
</li>
<li><p>补码加法</p>
<p>x + y = x + y - 2 * 2^w-1^</p>
<p>x + y = x + y</p>
<p>x + y = x + y + 2* 2^w-1^</p>
<p>(符号位的权为 2^w-1^)</p>
</li>
<li><p>补码的溢出</p>
<p>参考补码加法和无符号加法的溢出, 可知 S 与 x, y 符号相反时发生溢出</p>
</li>
<li><p>补码乘法</p>
<p>-2^w-1^&lt;x, y&lt;2^w-1^-1</p>
<p>-2^w-1^ * (2^w-1^-1) &lt; x*y &lt; 2^w-1^ * 2^w-1^</p>
</li>
<li><p>除以 2</p>
<p>x&gt;&gt;k = x/2^k^ 向下取整 (因为右移出去的 1 变成 0 , 值变小)</p>
<p>但是对于负数, 我们希望向 0 舍入, 引入概念偏置</p>
<p>偏置 biasing(b) 移k 位, b = 2^k^-1</p>
<p>对于不需要舍入的, 不会改变值, 对于需要舍入的会进 1 位, 从而实现向上舍入</p>
</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><p>IEEE 754表示</p>
<p>SME 为有效值, sfe 为实际存储中的值</p>
<p>V = (-1)^s^ * M * 2^E^</p>
<p>S sign 符号</p>
<p>M significand 尾数</p>
<p>E exponent 阶码</p>
<p>32 位 S 31 E 30-23 M 22-0</p>
<p>64 位 S 63 E 62-52 M 51-0</p>
<p><strong>分类</strong></p>
<ul>
<li><p>规格化 S = s, E = e - bias, M = f + 1</p>
<p>0&lt;e&lt;2^k^-1</p>
<p>bias = 2^k-1^-1</p>
<p>eg: 对于 32 位, E 的取值为 1-127 ~ 254-127</p>
<p>f+1 是因为有一个隐含的 1(implied leading 1)</p>
</li>
<li><p>非规格化 S = s, E = 1 - bias, M = f</p>
<p>e = 0</p>
<p>注意规格化数和非规格化数之间的平滑转换</p>
</li>
<li><p>特殊值</p>
<p>e = 2^k^-1</p>
<p>s=0 正无穷</p>
<p>s=1 负无穷</p>
<p>f != 0 NaN(not a number)</p>
<p>e =0 f = 0 0</p>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/40571490/answer/746043817?utm_source=qq&utm_medium=social&utm_oi=806118869101088768">CPU 的工作原理是什么 知乎</a></p>
<h1 id="大萝卜提纲"><a href="#大萝卜提纲" class="headerlink" title="大萝卜提纲"></a>大萝卜提纲</h1>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.</span> <span class="toc-text">计算机组成原理实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-1-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.1.</span> <span class="toc-text">实验 1 数据表示实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.1.1.</span> <span class="toc-text">汉字编码实验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-2"><span class="toc-number">1.2.</span> <span class="toc-text">实验 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-4"><span class="toc-number">1.3.</span> <span class="toc-text">实验 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">中断处理机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mooc"><span class="toc-number">2.</span> <span class="toc-text">mooc</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA"><span class="toc-number">2.1.</span> <span class="toc-text">1. 计算机系统概论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.2.</span> <span class="toc-text">2. 数据表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3. 运算方法与运算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4. 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">存储系统的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87"><span class="toc-number">2.4.2.</span> <span class="toc-text">主存中的数据组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.3.</span> <span class="toc-text">静态存储器的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.4.</span> <span class="toc-text">动态存储器的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%89%A9%E5%B1%95"><span class="toc-number">2.4.5.</span> <span class="toc-text">存储扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BD%93%E4%BA%A4%E5%8F%89%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.4.6.</span> <span class="toc-text">多体交叉存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.7.</span> <span class="toc-text">cache 基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E8%81%94%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.4.8.</span> <span class="toc-text">相联存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%92%8C%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.9.</span> <span class="toc-text">cache 地址映射和变换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.10.</span> <span class="toc-text">替换算法(淘汰算法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%E4%BE%8B%E9%A2%98"><span class="toc-number">2.4.11.</span> <span class="toc-text">高速缓冲存储器例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.4.12.</span> <span class="toc-text">虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB-translation-lookaside-buffer"><span class="toc-number">2.4.13.</span> <span class="toc-text">TLB(translation lookaside buffer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-redundant-arrays-of-inexpensive-disks-gt"><span class="toc-number">2.4.14.</span> <span class="toc-text">RAID(redundant arrays of inexpensive disks-&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redundant-arrays-of-independent-disks"><span class="toc-number">2.4.15.</span> <span class="toc-text">redundant arrays of independent disks)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5. 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%92%8C%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">指令系统概述和指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">2.5.2.</span> <span class="toc-text">寻址方式 指令寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="toc-number">2.5.3.</span> <span class="toc-text">操作数寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.5.4.</span> <span class="toc-text">指令格式设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIPS-32-%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.5.</span> <span class="toc-text">MIPS(32) 指令概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">指令格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">指令详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-cpu"><span class="toc-number">2.6.</span> <span class="toc-text">6. cpu</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">深入理解计算机系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text">第一章 计算机系统漫游</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%A2%AB%E7%BF%BB%E8%AF%91%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">程序被翻译为不同的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">系统硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E8%AE%BE%E5%A4%87"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">io 设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">主存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8-CPU"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">处理器 CPU</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.3.</span> <span class="toc-text">存储设备形成层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6"><span class="toc-number">3.1.4.</span> <span class="toc-text">操作系统管理硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.4.4.</span> <span class="toc-text">文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E4%B8%BB%E9%A2%98"><span class="toc-number">3.1.5.</span> <span class="toc-text">重要主题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">并发和并行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%B9%B6%E5%8F%91"><span class="toc-number">3.1.5.1.1.</span> <span class="toc-text">线程级并发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.1.5.1.2.</span> <span class="toc-text">指令级并行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%8C%87%E4%BB%A4-%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.1.5.1.3.</span> <span class="toc-text">单指令, 多数据并行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">抽象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">第二章 信息的表示和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">信息存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.2.</span> <span class="toc-text">整数运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">浮点数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E8%90%9D%E5%8D%9C%E6%8F%90%E7%BA%B2"><span class="toc-number">4.</span> <span class="toc-text">大萝卜提纲</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
