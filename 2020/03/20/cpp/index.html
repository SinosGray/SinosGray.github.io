
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>cpp 从入门到汇编 - Sinos_wei&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="
简介: cpp 简要指北

cpp 指南
简单入门：http://web.archive.org/web/20101209143037/http://www.eetimes.com/discuss,"> 
    <meta name="author" content="Sinos_wei"> 
    <link rel="alternative" href="atom.xml" title="Sinos_wei&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/a33.jpg"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sinos_wei&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://sinos_wei.gitee.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">cpp 从入门到汇编</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">cpp 从入门到汇编</h1>
        <div class="stuff">
            <span>三月 20, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>


        </div>
        <div class="content markdown">
            <blockquote>
<p>简介: cpp 简要指北</p>
</blockquote>
<h1 id="cpp-指南"><a href="#cpp-指南" class="headerlink" title="cpp 指南"></a>cpp 指南</h1><ul>
<li><p>简单入门：<a target="_blank" rel="noopener" href="http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters">http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters</a>?</p>
</li>
<li><p>mac 下的 c++ 头文件位置 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++</p>
<span id="more"></span></li>
</ul>
<h2 id="traits"><a href="#traits" class="headerlink" title="traits"></a><a target="_blank" rel="noopener" href="https://www.internalpointers.com/post/quick-primer-type-traits-modern-cpp">traits</a></h2><p><strong>Type traits</strong> are a clever technique used in C++ template metaprogramming that gives you the ability to inspect and transform the properties of <em>types</em>.</p>
<p>For example, given a generic type <code>T</code> — it could be <code>int</code>, <code>bool</code>, <code>std::vector</code> or whatever you want — with type traits you can ask the compiler some questions: is it an integer? Is it a function? Is it a pointer? Or maybe a class? Does it have a destructor? Can you copy it? Will it throw exceptions? … and so on. This is extremely useful in <strong>conditional compilation</strong>, where you instruct the compiler to pick the right path according to the type in input. We will see an example shortly.</p>
<h2 id="typedef-in-stl"><a href="#typedef-in-stl" class="headerlink" title="typedef in stl"></a>typedef in stl</h2><p>private 底下的那些，主要就是因为原类型名完整写出来太长，于是取个短名字。</p>
<p>public  底下那些，除了名字长以外，通常还有很重要一个原因：就是标准规定实现某种类型（典型的如容器，比如本例的 std::map），需要对外提供这些类型。最典型如图中的“iterator”和“const_iterator”，就是因为STL中的（正经）容器，需要对外提供“迭代器”类型和“常量迭代器”类型。 这样，当有一天你需要遍历一个 容器，比如map时，你才可以方便地这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( std::map&lt;std::string, <span class="keyword">int</span>&gt;::const_iterator it = m.<span class="built_in">cbegin</span>();</span><br><span class="line">              it != m.<span class="built_in">cend</span>();</span><br><span class="line">              ++it)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>那个 const_iterator 哪来的？就是在 map&lt;K, V&gt; 里定义的那个 typedef 。<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/441345616/answer/1699499726">https://www.zhihu.com/question/441345616/answer/1699499726</a></p>
<h2 id="ADL-argument-dependent-lookup"><a href="#ADL-argument-dependent-lookup" class="headerlink" title="ADL argument-dependent lookup"></a>ADL argument-dependent lookup</h2><p>Argument-dependent lookup, also known as ADL, or Koenig lookup [<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/adl#cite_note-1">1]</a>, is the set of rules for looking up the unqualified function names in <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_other">function-call expressions</a>, including implicit function calls to <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operators">overloaded operators</a>. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lookup">unqualified name lookup</a>.</p>
<p>Argument-dependent lookup makes it possible to use operators defined in a different namespace. Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test\n&quot;</span>; <span class="comment">// There is no operator&lt;&lt; in global namespace, but ADL</span></span><br><span class="line">                           <span class="comment">// examines std namespace because the left argument is in</span></span><br><span class="line">                           <span class="comment">// std and finds std::operator&lt;&lt;(std::ostream&amp;, const char*)</span></span><br><span class="line">    <span class="keyword">operator</span>&lt;&lt;(std::cout, <span class="string">&quot;Test\n&quot;</span>); <span class="comment">// same, using function call notation</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// however,</span></span><br><span class="line">    std::cout &lt;&lt; endl; <span class="comment">// Error: &#x27;endl&#x27; is not declared in this namespace.</span></span><br><span class="line">                       <span class="comment">// This is not a function call to endl(), so ADL does not apply</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">endl</span>(std::cout); <span class="comment">// OK: this is a function call: ADL examines std namespace</span></span><br><span class="line">                     <span class="comment">// because the argument of endl is in std, and finds std::endl</span></span><br><span class="line"> </span><br><span class="line">    (endl)(std::cout); <span class="comment">// Error: &#x27;endl&#x27; is not declared in this namespace.</span></span><br><span class="line">                       <span class="comment">// The sub-expression (endl) is not a function call expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dependent-name-amp-name-binding"><a href="#dependent-name-amp-name-binding" class="headerlink" title="dependent name &amp; name binding"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent name</a> &amp; name binding</h2><p>inside the definition of a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/templates">template</a> (both <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template">class template</a> and <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/function_template">function template</a>), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may <strong>depend on types of type template parameters and values of non-type template parameters.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> :</span> B&lt;T&gt; <span class="comment">// &quot;B&lt;T&gt;&quot; is dependent on T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::A* pa; <span class="comment">// &quot;T::A&quot; is dependent on T</span></span><br><span class="line">                       <span class="comment">// (see below for the meaning of this use of &quot;typename&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B&lt;T&gt;* pb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = B&lt;T&gt;::i; <span class="comment">// &quot;B&lt;T&gt;::i&quot; is dependent on T</span></span><br><span class="line">        pb-&gt;j++; <span class="comment">// &quot;pb-&gt;j&quot; is dependent on T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>name binding</p>
<p>为模板显式或隐式使用的每个名字寻找其声明 的过程称为名字绑定</p>
<p>模板中使用的名字分为依赖性名字 dependent name, 非依赖性名字</p>
<ul>
<li><p>dependent name<br>依赖于模板参数的名字, 在实例化点完成绑定<br>默认情况下, 编译器假定 dependent name 不是类型名, 如果需要, 必须用 typename 显式声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fct</span><span class="params">(Container&amp; c)</span></span>&#123;</span><br><span class="line">  Container::value_type v1 = c[<span class="number">7</span>];<span class="comment">//error</span></span><br><span class="line">  <span class="keyword">typename</span> Container::value_type v2 = c[<span class="number">9</span>];<span class="comment">//coorect</span></span><br><span class="line">  <span class="keyword">auto</span> v3 = c[<span class="number">11</span>];<span class="comment">//correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者使用别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Value_type&lt;T&gt; = <span class="keyword">typename</span> T::value_type;</span><br></pre></td></tr></table></figure></li>
<li><p>independent name<br>不依赖于模板参数的名字, 在定义点完成绑定</p>
</li>
</ul>
</li>
</ul>
<h2 id="qualified-name"><a href="#qualified-name" class="headerlink" title="qualified name"></a>qualified name</h2><p>A <em>qualified</em> name is a name that appears on the right hand side of the scope resolution operator <code>::</code> (see also <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/identifiers#Qualified_identifiers">qualified identifiers</a>).</p>
<h2 id="nested-class"><a href="#nested-class" class="headerlink" title="nested class"></a>nested class</h2><p>A nested class is a class which is declared in another enclosing class. A nested class is a member and as such has the same access rights as any other member. </p>
<h2 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords">Where and why do I have to put the “template” and “typename” keywords?</a></p>
<p>(See <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/17579889/4561887">here also for my C++11 answer</a>)</p>
<p>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t * f;</span><br></pre></td></tr></table></figure>

<p>How should this be parsed? For many languages a compiler doesn’t need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what <code>t</code> means. If it’s a type, then it will be a declaration of a pointer <code>f</code>. However if it’s not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</p>
<blockquote>
<p>Some names denote types or templates. In general, <strong>whenever a name is encountered it is necessary to determine whether that name denotes one of these entities</strong> before continuing to parse the program that contains it. The process that determines this is called <strong>name lookup.</strong></p>
</blockquote>
<p>How will the compiler find out what a name <code>t::x</code> refers to, if <code>t</code> refers to a template type parameter? <code>x</code> could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. <strong>If a name has this property - that it can’t be looked up until the actual template arguments are known - then it’s called a *dependent name* (it “depends” on the template parameters).</strong></p>
<p>You might recommend to just wait till the user instantiates the template:</p>
<blockquote>
<p><em>Let’s wait until the user instantiates the template, and then later find out the real meaning of <code>t::x \* f;</code>.</em></p>
</blockquote>
<p>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template’s text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template’s users (poor colleagues!) with errors made by a template’s author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place.</p>
<p>So there has to be a way to tell the compiler that certain names are types and that certain names aren’t.</p>
<h3 id="The-“typename”-keyword"><a href="#The-“typename”-keyword" class="headerlink" title="The “typename” keyword"></a>The “typename” keyword</h3><p>The answer is: <em>We</em> decide how the compiler should parse this. If <code>t::x</code> is a dependent name, then we need to prefix it by <code>typename</code> to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</p>
<blockquote>
<p>A name used in a template declaration or definition and that is dependent on a template-parameter <strong>is assumed not to name a type</strong> unless the applicable name lookup finds a type name or the name is qualified by the keyword typename.</p>
</blockquote>
<p>There are many names for which <code>typename</code> is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with <code>T *f;</code>, when <code>T</code> is a type template parameter. But for <code>t::x * f;</code> to be a declaration, it must be written as <code>typename t::x *f;</code>. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t::x is taken as non-type, but as an expression the following misses an operator between the two names or a semicolon separating them.</span></span><br><span class="line">t::x f;</span><br></pre></td></tr></table></figure>

<p><em>The syntax allows <code>typename</code> only before qualified names</em> - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</p>
<p>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</p>
<h3 id="The-“template”-keyword"><a href="#The-“template”-keyword" class="headerlink" title="The “template” keyword"></a>The “template” keyword</h3><p>Remember the initial quote above and how the Standard requires special handling for templates as well? Let’s take the following innocent-looking example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::function&lt; <span class="built_in"><span class="keyword">int</span></span>() &gt; f;</span><br></pre></td></tr></table></figure>

<p>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of <code>boost::function</code> and <code>f</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost &#123; <span class="keyword">int</span> function = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">  boost::function&lt; <span class="built_in"><span class="keyword">int</span></span>() &gt; f; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s actually a <strong>valid <em>expression</em></strong>! It uses the less-than operator to compare <code>boost::function</code> against zero (<code>int()</code>), and then uses the greater-than operator to compare the resulting <code>bool</code> against <code>f</code>. However as you might well know, <code>boost::function</code> <a target="_blank" rel="noopener" href="http://www.boost.org/doc/libs/1_54_0/doc/html/function.html">in real life</a> is a template, so the compiler knows (14.2/3):</p>
<blockquote>
<p>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &lt;, the &lt; is always taken as the beginning of a template-argument-list and never as a name followed by the less-than operator.</p>
</blockquote>
<p>Now we are back to the same problem as with <code>typename</code>. What if we can’t know yet whether the name is a template when parsing the code? We will need to insert <code>template</code> immediately before the template name, as specified by <code>14.2/4</code>. This looks like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t::<span class="keyword">template</span> f&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// call a function template</span></span><br></pre></td></tr></table></figure>

<p>Template names can not only occur after a  <code>::</code>  but also after a <code>-&gt;</code> or <code>.</code> in a class member access. You need to insert the keyword there too:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="keyword">template</span> f&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// call a function template</span></span><br></pre></td></tr></table></figure>

<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I’ll talk a bit about how this is specified in the Standard.</p>
<p>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to <em>depend</em> on template parameters.</p>
<p>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</p>
<ul>
<li>Dependent types (e.g: a type template parameter <code>T</code>)</li>
<li>Value-dependent expressions (e.g: a non-type template parameter <code>N</code>)</li>
<li>Type-dependent expressions (e.g: a cast to a type template parameter <code>(T)0</code>)</li>
</ul>
<p>Most of the rules are intuitive and are built up recursively: For example, a type constructed as <code>T[N]</code> is a dependent type if <code>N</code> is a value-dependent expression or <code>T</code> is a dependent type. The details of this can be read in section <code>(14.6.2/1</code>) for dependent types, <code>(14.6.2.2)</code> for type-dependent expressions and <code>(14.6.2.3)</code> for value-dependent expressions.</p>
<h3 id="Dependent-names"><a href="#Dependent-names" class="headerlink" title="Dependent names"></a>Dependent names</h3><p>The Standard is a bit unclear about what <em>exactly</em> is a <em>dependent name</em>. On a simple read (you know, the principle of least surprise), all it defines as a <em>dependent name</em> is the special case for function names below. But since clearly <code>T::x</code> also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</p>
<p>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore “dependent names”. A name can take different forms - the Standard says:</p>
<blockquote>
<p>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</p>
</blockquote>
<p>An identifier is just a plain sequence of characters / digits, while the next two are the <code>operator +</code> and <code>operator type</code> form. The last form is <code>template-name &lt;argument list&gt;</code>. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</p>
<p>A value dependent expression <code>1 + N</code> is not a name, but <code>N</code> is. The subset of all dependent constructs that are names is called <em>dependent name</em>. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule.</p>
<h3 id="Dependent-function-names"><a href="#Dependent-function-names" class="headerlink" title="Dependent function names"></a>Dependent function names</h3><p>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example <code>f((T)0)</code>, <code>f</code> is a dependent name. In the Standard, this is specified at <code>(14.6.2/1)</code>.</p>
<h3 id="Additional-notes-and-examples"><a href="#Additional-notes-and-examples" class="headerlink" title="Additional notes and examples"></a>Additional notes and examples</h3><p>In enough cases we need both of <code>typename</code> and <code>template</code>. Your code should look like the following</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionNode</span> :</span> <span class="keyword">public</span> Tail &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">struct</span> <span class="title">inUnion</span> &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Tail::<span class="keyword">template</span> inUnion&lt;U&gt; dummy;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The keyword <code>template</code> doesn’t always have to appear in the last part of a name. It can appear in the middle before a class name that’s used as a scope, like in the following example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> t::<span class="keyword">template</span> iterator&lt;<span class="keyword">int</span>&gt;::value_type v;</span><br></pre></td></tr></table></figure>

<p>In some cases, the keywords are forbidden, as detailed below</p>
<ul>
<li><p>On the name of a dependent base class you are not allowed to write <code>typename</code>. It’s assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">derive_from_Has_type</span> :</span> <span class="comment">/* typename */</span> SomeBase&lt;T&gt;::type </span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>In using-declarations it’s not possible to use <code>template</code> after the last <code>::</code>, and the C++ committee <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109">said</a> not to work on a solution.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">derive_from_Has_type</span> :</span> SomeBase&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">using</span> SomeBase&lt;T&gt;::<span class="keyword">template</span> type; <span class="comment">// error</span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">typename</span> SomeBase&lt;T&gt;::type; <span class="comment">// typename *is* allowed</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    cout&lt;&lt;i.<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">    ++i;</span><br><span class="line">    cout&lt;&lt;i.<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">    i = v.<span class="built_in">end</span>();</span><br><span class="line">    cout&lt;&lt;i.<span class="built_in">base</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;v.<span class="built_in">end</span>()-v.<span class="built_in">begin</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">	0x600000141100</span></span><br><span class="line"><span class="comment">  0x600000141104</span></span><br><span class="line"><span class="comment">  0x600000141114</span></span><br><span class="line"><span class="comment">  5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a><a target="_blank" rel="noopener" href="https://jeremybai.github.io/blog/2014/09/10/size-t">size_t</a></h2><p>每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。</p>
<p>适当地使用size_t还会使你的代码变得如同自带文档。当你看到一个对象声明为size_t类型，你马上就知道它代表字节大小或数组索引，而不是错误代码或者是一个普通的算术值。</p>
<h2 id="compiler-default"><a href="#compiler-default" class="headerlink" title="compiler default"></a>compiler default</h2><h3 id="default-constructor"><a href="#default-constructor" class="headerlink" title="default constructor"></a>default constructor</h3><p>If no user-declared constructors of any kind are provided for a class type (struct, class, or union), the compiler will always declare a default constructor as an <code>inline public</code> member of its class.</p>
<p>it has the same effect as a user-defined constructor with <strong>empty body and empty initializer list.</strong></p>
<h3 id="destructor"><a href="#destructor" class="headerlink" title="destructor"></a>destructor</h3><p>If no user-declared prospective (since C++20)destructor is provided for a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class">class type</a> (struct, class, or union), the compiler will always declare a destructor as an <code>inline public</code> member of its class.</p>
<p>This implicitly-defined destructor has an <strong>empty body.</strong></p>
<h3 id="copy-constructor"><a href="#copy-constructor" class="headerlink" title="copy constructor"></a>copy constructor</h3><p>This implicitly-declared copy constructor has the form T::T(const T&amp;) if all of the following are true:</p>
<ul>
<li>each direct and virtual base <code>B</code> of <code>T</code> has a copy constructor whose parameters are const B&amp; or const volatile B&amp;;</li>
<li>each non-static data member <code>M</code> of <code>T</code> of class type or array of class type has a copy constructor whose parameters are const M&amp; or const volatile M&amp;.</li>
</ul>
<p>For non-union class types (class and struct), the constructor performs full member-wise copy of the object’s <strong>bases and non-static members</strong>, in their initialization order, using direct initialization. </p>
<h3 id="copy-assignment"><a href="#copy-assignment" class="headerlink" title="copy assignment"></a>copy assignment</h3><p>For non-union class types (class and struct), the operator performs member-wise copy assignment of the object’s <strong>bases and non-static members</strong>, in their initialization order, using <strong>built-in assignment for the scalars and copy assignment operator for class types</strong>.</p>
<h3 id="move-assignment"><a href="#move-assignment" class="headerlink" title="move assignment"></a>move assignment</h3><p>For non-union class types (class and struct), the move assignment operator performs full member-wise move assignment of the object’s direct <strong>bases and immediate non-static members</strong>, in their declaration order, using <strong>built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types</strong> (called non-virtually).</p>
<h2 id="UNIX-Linux-GNU"><a href="#UNIX-Linux-GNU" class="headerlink" title="UNIX Linux GNU"></a>UNIX Linux GNU</h2><ul>
<li>UNIX 非开源 AT&amp;T</li>
<li>BSD 为 UNIX 一个开源版本</li>
<li>GNU(GNU is not UNIX) 开源软件项目</li>
<li>Linux Linus 写的内核, 属于类 UNIX, 兼容 POSIX</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operators">运算符重载</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">T</span>(T &amp;t):<span class="built_in">i</span>(t.i), <span class="built_in">s</span>(t.s)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//copy assignment</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; other)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//move assignment</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>=(T&amp;&amp; other)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//stream extraction</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> T&amp; obj);</span><br><span class="line">    <span class="comment">//stream insertion</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, <span class="keyword">const</span> T&amp; obj);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//prefix ++</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span> ++()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//postfix ++</span></span><br><span class="line">    T <span class="keyword">operator</span> ++(<span class="keyword">int</span>)&#123;</span><br><span class="line">        T old = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">operator</span>++();</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> --()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//postfix --</span></span><br><span class="line">    T <span class="keyword">operator</span> --(<span class="keyword">int</span>)&#123;</span><br><span class="line">        T old = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">operator</span>--();</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//+, +=</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp; rhs)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">friend</span> T <span class="keyword">operator</span>+(T lhs, <span class="keyword">const</span> T&amp; rhs)&#123;</span><br><span class="line">        lhs += rhs;</span><br><span class="line">        <span class="keyword">return</span> lhs;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//comparison &lt; first</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)&#123; <span class="comment">/* do actual comparison */</span> &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> rhs &lt; lhs; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> !(lhs &gt; rhs); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> !(lhs &lt; rhs); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)&#123; <span class="comment">/* do actual comparison */</span> &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)&#123; <span class="keyword">return</span> !(lhs == rhs); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function call</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> T&amp; obj)&#123;<span class="keyword">return</span> os;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, <span class="keyword">const</span> T&amp; obj)&#123;<span class="keyword">return</span> is;&#125;</span><br></pre></td></tr></table></figure>

<p>注:</p>
<ul>
<li><p>&lt;&lt; &gt;&gt; 运算符重载</p>
<p>These operators must be overloaded as a global function. And if we want to allow them to access private data members of the class, we must make them friend. </p>
<p><strong>Why these operators must be overloaded as global?</strong><br>In operator overloading, if an operator <strong>is overloaded as a member, then it must be a member of the object on the left side of the operator</strong>. For example, consider the statement “ob1 + ob2” (let ob1 and ob2 be objects of two different classes). To make this statement compile, we must overload ‘+’ in a class of ‘ob1’ or make ‘+’ a global function.<br>The operators ‘&lt;&lt;‘ and ‘&gt;&gt;’ are called like ‘cout &lt;&lt; ob1’ and ‘cin &gt;&gt; ob1’. So if we want to make them a member method, then they must be made members of ostream and istream classes, which is not a good option most of the time. Therefore, these operators are overloaded as global functions with two parameters, cout and object of user-defined class.</p>
</li>
<li><p>public or private?</p>
</li>
<li><p>(+, +=)Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if <code>operator+</code> is a member function of the complex type, then only complex+integer would compile, and not integer+complex).Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:</p>
</li>
<li><p>Standard algorithms such as <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/algorithm/sort">std::sort</a> and containers such as <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/set">std::set</a> expect operator&lt; to be defined, by default</p>
</li>
</ul>
<h2 id="自引用-this"><a href="#自引用-this" class="headerlink" title="自引用 this"></a>自引用 this</h2><p>状态更新函数, 一种很有用的技术是令他们返回已更新对象的返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date&amp; <span class="title">Date::add_year</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(d==<span class="number">29</span> &amp;&amp; m==<span class="number">2</span> &amp;&amp; !<span class="built_in">leapyear</span>(y+n))&#123;</span><br><span class="line">    d=<span class="number">1</span>;</span><br><span class="line">    m=<span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  y+=n;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类 X 的 nonconst 成员函数中, this 的类型时 X*</p>
<p>在类 X 的 const 成员函数中, this 的类型时 const X*</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><code>explicit</code>的作用是用来声明类构造函数是显示调用的，而非隐式调用，所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显示调用的。再加上<code>explicit</code>关键字也没有什么意义。</p>
<h2 id="internal-linkage"><a href="#internal-linkage" class="headerlink" title="internal linkage"></a>internal linkage</h2><p>When you write an implementation file (<code>.cpp</code>, <code>.cxx</code>, etc) your compiler generates a <strong>translation unit</strong>. This is the source file from your implementation plus all the headers you <code>#include</code> in it.</p>
<p><em>Internal linkage</em> refers to everything only <strong>in scope of a translation unit</strong>.</p>
<p><em>External linkage</em> refers to things that exist beyond a particular translation unit. In other words, <strong>accessible through the whole program</strong>, which is the combination of all translation units (or object files).</p>
<p>You can explicitly control the linkage of a symbol by using the <code>extern</code> and <code>static</code> keywords. If the linkage is not specified then the default linkage is <code>extern</code> (external linkage) for non-<code>const</code> symbols and <code>static</code> (internal linkage) for <code>const</code> symbols.</p>
<p>Note that instead of using <code>static</code> (internal linkage), it is better to use <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions"><em>anonymous</em> namespaces</a> into which you can also put <code>class</code>es. Though they allow <code>extern</code> linkage, anonymous namespaces are unreachable from other translation units, making linkage <em>effectively</em> <code>static</code>.</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载解析与函数声明的次序无关</p>
<p>重载解析过程中不考虑函数的返回类型, 独立于上下文</p>
<h2 id="对象与引用"><a href="#对象与引用" class="headerlink" title="对象与引用"></a>对象与引用</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h4><p>除非我们把临时对象绑定到引用上或者用它初始化一个命名对象, 否则大多数时候在临时对象所在的完整表达式末尾, 他就被销毁了</p>
<h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><p>对象(object) –&gt; 一段内存空间</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>有身份的对象的引用</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a><a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">右值引用</a></h4><p>可移动的对象的引用</p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="built_in">f</span>(<span class="number">2</span>) + <span class="built_in">g</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="左值右值引用"><a href="#左值右值引用" class="headerlink" title="左值右值引用"></a>左值右值引用</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxbenbxsxmj30e60323yf.jpg" alt="image-20211212221135490"></p>
<p>有身份 i</p>
<p>可移动 m</p>
<p>The original definition of lvalues and rvalues from the earliest days of C is as follows: An <em>lvalue</em> is an expression <code>e</code> that may appear on the left or on the right hand side of an assignment, whereas an <em>rvalue</em> is an expression that can only appear on the right hand side of an assignment.</p>
<p>An <em>lvalue</em> is an expression that refers to a memory location and allows us to take the address of that memory location via the <code>&amp;</code> operator. An <em>rvalue</em> is an expression that is not an lvalue.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// perhaps use x in various ways</span></span><br><span class="line">x = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>

<p>其中<code>x = foo()</code>包括以下步骤</p>
<ul>
<li>clones the resource from the temporary returned by <code>foo</code>,</li>
<li>destructs the resource held by <code>x</code> and replaces it with the clone,</li>
<li>destructs the temporary and thereby releases its resource.</li>
</ul>
<p>move action is aimed to swap the resource instead of clone it</p>
<p>you can overload in different ways</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X&amp; x)</span></span>; <span class="comment">// lvalue reference overload</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X&amp;&amp; x)</span></span>; <span class="comment">// rvalue reference overload</span></span><br><span class="line"></span><br><span class="line">X x;</span><br><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">foo</span>(x); <span class="comment">// argument is lvalue: calls foo(X&amp;)</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">foobar</span>()); <span class="comment">// argument is rvalue: calls foo(X&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>=(X <span class="keyword">const</span> &amp; rhs); <span class="comment">// classical implementation</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>=(X&amp;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Move semantics: exchange content between this and rhs</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string var &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">string&amp; r1&#123;var&#125;;</span><br><span class="line">string&amp; r2&#123;<span class="built_in">f</span>()&#125;;<span class="comment">//error f() is rvalue</span></span><br><span class="line">string&amp; r3&#123;<span class="string">&quot;hello&quot;</span>&#125;;<span class="comment">//error 不允许绑定到临时变量</span></span><br><span class="line"></span><br><span class="line">string&amp;&amp; rr1&#123;<span class="built_in">f</span>()&#125;;</span><br><span class="line">string&amp;&amp; rr2&#123;var&#125;;<span class="comment">//error var is lvalue</span></span><br><span class="line">string&amp;&amp; rr3&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> string&amp; cr1 &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>除非我们把临时对象绑定到引用上或者用它初始化一个命名对象, 否则大多数时候在临时对象所在的完整表达式末尾, 他就被销毁了</p>
<p>临时量可以用作 const 引用或者命名对象的初始化器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fs</span><span class="params">(string&amp; s1, string&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> string&amp; cs = s1+s2;<span class="comment">//ok</span></span><br><span class="line">    string ss = s1+s2;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    string&amp; s = s1+s2;<span class="comment">//error</span></span><br><span class="line">		<span class="comment">//non-const lvalue reference to type &#x27;basic_string&lt;...&gt;&#x27; cannot bind to a temporary of type &#x27;basic_string&lt;...&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="why-rvalue-is-allowed-to-passed-by-const-reference"><a href="#why-rvalue-is-allowed-to-passed-by-const-reference" class="headerlink" title="why rvalue is allowed to passed by const reference"></a><a target="_blank" rel="noopener" href="https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/">why rvalue is allowed to passed by const reference</a></h2><p>C++ deliberately specifies that binding a temporary object to a reference <em>to const</em> on the stack lengthens the lifetime of the temporary to the lifetime of the reference itself</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 1 legal</span></span><br><span class="line"><span class="function">string <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> string&amp; s = <span class="built_in">f</span>();</span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;    <span class="comment">// can we still use the &quot;temporary&quot; object?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 2 illegal</span></span><br><span class="line"><span class="function">string <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string&amp; s = <span class="built_in">f</span>();       <span class="comment">// still legal?</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 3</span></span><br><span class="line"></span><br><span class="line"><span class="function">Derived <span class="title">factory</span><span class="params">()</span></span>; <span class="comment">// construct a Derived object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Base&amp; b = <span class="built_in">factory</span>(); <span class="comment">// calls Derived::Derived here</span></span><br><span class="line">  <span class="comment">// … use b …</span></span><br><span class="line">&#125; <span class="comment">// calls Derived::~Derived directly here — not Base::~Base + virtual dispatch!</span></span><br></pre></td></tr></table></figure>

<p>only lvalues can be bound to references to non-const.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>使用=进行初始化可能会发生窄化转换, 使用初始化列表不会, 所以推荐使用初始化列表, 但是 auto 不推荐, 因为会得到 list 类型.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X a1 &#123;v&#125;;</span><br><span class="line">X a2 = &#123;v&#125;;</span><br><span class="line">X a3 = v;</span><br><span class="line"><span class="function">X <span class="title">a4</span><span class="params">(v)</span></span>;</span><br></pre></td></tr></table></figure>

<p>缺少初始化容器</p>
<ul>
<li>全局变量, 局部 static 变量, static 成员会执行{} 初始化</li>
<li>局部变量, 堆对象, 除非位于默认构造函数中, 否则不会进行默认初始化</li>
</ul>
<h2 id="raw-string"><a href="#raw-string" class="headerlink" title="raw string"></a>raw string</h2><p>C++11 引入了原始字符串。最基本的用法是<code>R&quot;(...)&quot;</code>，由<code>R</code>开头，双引号内包围着<code>(...)</code>，实际的字符序列是小括号内的内容，小括号是字符序列的定界符。当然，左小括号和右小括号是首位对应的。</p>
<p>“原始”（raw）体现在字符串里的字符一就是一，二就是二，不会给你转义。也就是说，传统的<code>&quot;\\n&quot;</code>除了字符串结尾符，仅包含换行符，而原始字符串<code>R&quot;(\\n)&quot;</code>则包含反斜杠和字符<code>n</code>，这是明显的不同。</p>
<p>从现在来看，貌似已经很好的解决问题了，但如果字符序列里包含<code>)&quot;</code>，如<code>R&quot;(坐标: &quot;(x,y)&quot;)&quot;</code>，此时编译器是懵的，因为<code>&quot;(</code>对应了两个<code>)&quot;</code>。在这种情况下，我们可以选择其他定界符，如，<code>R&quot;&amp;(坐标: &quot;(x,y)&quot;)&amp;&quot;</code>。语法如下：<code>R&quot;delim(...)delim&quot;</code>，<code>delim</code>的选取比较灵活，最长不超过16个字符，且不为小括号、空白、控制字符和反斜杠。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxad138yhzj30rk0igwgr.jpg" alt="image-20211212003002953"></p>
<h2 id="变量与类型"><a href="#变量与类型" class="headerlink" title="变量与类型"></a>变量与类型</h2><ul>
<li>类型 type: 定义一组可能的值以及一组操作</li>
<li>对象 object: 存放某类型的内存空间</li>
<li>值 value: 一组二进制位, 含义由其类型决定</li>
<li>变量 variable: 是一个命名的对象</li>
</ul>
<h2 id="函数对象-函子"><a href="#函数对象-函子" class="headerlink" title="函数对象(函子)"></a>函数对象(函子)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Less_than</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> T val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Less_than</span>(<span class="keyword">const</span> T&amp; v) :<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x&lt;val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function call</span></span><br><span class="line"></span><br><span class="line">Less_than&lt;<span class="keyword">int</span>&gt; lti &#123;<span class="number">42</span>&#125;;</span><br><span class="line"><span class="built_in">lti</span>(<span class="number">36</span>);</span><br></pre></td></tr></table></figure>

<h2 id="模板-template"><a href="#模板-template" class="headerlink" title="模板 template"></a>模板 template</h2><p>模板类声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Vector</span>(<span class="keyword">int</span> s);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板函数声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="keyword">int</span> s)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="enmu"><a href="#enmu" class="headerlink" title="enmu"></a>enmu</h2><p>使用 enum class 定义枚举类型时不能与 int 类型互相转换,  运算只有&gt; &lt; ==, 而且 enum class 的枚举值名字位于 enum 局部作用域内</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Traffic_light</span> &#123;</span>red, yellow, green&#125;;</span><br><span class="line">Traffic_light l = Traffic_light::red;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Warning</span> &#123;</span>green, yellow, orange, red&#125;;</span><br><span class="line">Warning w = green;</span><br></pre></td></tr></table></figure>

<h2 id="literal-type"><a href="#literal-type" class="headerlink" title="literal type"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/LiteralType">literal type</a></h2><p>Literal types are the types of <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code> variables</a> and they can be constructed, manipulated, and returned from <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code> functions</a>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="function"><span class="keyword">constexpr</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>; <span class="keyword">char</span> c; &#125;;  <span class="comment">// A is a literal type</span></span><br><span class="line"><span class="keyword">constexpr</span> A v = std::bit_cast&lt;A&gt;(<span class="string">&#x27;0&#x27;</span>);  <span class="comment">// OK in C++20</span></span><br><span class="line">                                        <span class="comment">// v has literal type and thus can be constexpr</span></span><br></pre></td></tr></table></figure>



<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr</a></h2><p>编译时求值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">func1</span><span class="params">(<span class="keyword">double</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">func2</span><span class="params">(<span class="keyword">double</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>+<span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> I = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">17</span>;</span><br><span class="line"><span class="comment">//    constexpr double x1 = sqrt(I);</span></span><br><span class="line"><span class="comment">//    constexpr double x2 = sqrt(var);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> x3 = <span class="built_in">sqrt</span>(I);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> x4 = <span class="number">17</span>+<span class="number">18</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> x5 = I;</span><br><span class="line"><span class="comment">//    constexpr double x6 = var;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> x7 = <span class="built_in">func1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> x8 = <span class="built_in">func2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> x9 = <span class="built_in">func1</span>(I);</span><br><span class="line"><span class="comment">//    constexpr double x10 = func1(var);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注释掉的代码为错误代码</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">array_size1</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error, constant expression required in array declaration</span></span><br><span class="line"><span class="comment">//???</span></span><br><span class="line"><span class="keyword">int</span> array[<span class="built_in">array_size1</span>(<span class="number">10</span>)];    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">array_size2</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// OK, constexpr functions can be evaluated at compile time</span></span><br><span class="line"><span class="comment">// and used in contexts that require constant expressions. </span></span><br><span class="line"><span class="keyword">int</span> array[<span class="built_in">array_size2</span>(<span class="number">10</span>)];     </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="built_in">S</span>() &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;  <span class="comment">// Error, f must not be virtual.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">55</span>;</span><br><span class="line">  &#125;       </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NL</span> &#123;</span></span><br><span class="line">  ~<span class="built_in">NL</span>() &#123; &#125;  <span class="comment">// The user-provided destructor (even if it is trivial) </span></span><br><span class="line">             <span class="comment">// makes the type a non-literal type.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> NL <span class="title">f1</span><span class="params">()</span> </span>&#123;  <span class="comment">// Error, return type of f1 must be a literal type.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NL</span>();</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(NL)</span> </span>&#123;  <span class="comment">// Error, the parameter type NL is not a literal type.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">55</span>; </span><br><span class="line">&#125;                 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> S <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">S</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> val = <span class="built_in">f3</span>() &#125;;  <span class="comment">// Error, initialization of the return value in f3()</span></span><br><span class="line">                      <span class="comment">// uses a non-constexpr constructor.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">// Error, return type should not be void.</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">f5</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// Error, function body contains more than</span></span><br><span class="line">  <span class="keyword">if</span> (x&lt;<span class="number">0</span>)                <span class="comment">// return statement.</span></span><br><span class="line">    x = -x;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="c-v-qualified-class"><a href="#c-v-qualified-class" class="headerlink" title="c-v qualified class"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/cv">c-v qualified class</a></h2><p>const and volatile class</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non cv_qualified </span></span><br><span class="line"><span class="keyword">int</span> first; </span><br><span class="line"><span class="keyword">char</span> *second; </span><br><span class="line"></span><br><span class="line"><span class="comment">// cv-qualified </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> third; </span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * fourth; </span><br></pre></td></tr></table></figure>

<p>For any type <code>T</code> (including incomplete types), other than <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/functions">function type</a> or <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reference">reference type</a>, there are three more distinct types in the C++ type system: <em>const-qualified</em> <code>T</code>, <em>volatile-qualified</em> <code>T</code>, and <em>const-volatile-qualified</em> <code>T</code>.</p>
<ul>
<li><em><strong>const object</strong></em> - an object whose type is <em>const-qualified</em>, or a non-mutable subobject of a const object. <strong>Such object cannot be modified: attempt to do so directly is a compile-time error</strong>, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.</li>
<li><em><strong>volatile object</strong></em> - an object whose type is <em>volatile-qualified</em>, or a subobject of a volatile object, or a mutable subobject of a const-volatile object. Every access (read or write operation, member function call, etc.) made through a glvalue(A <em>glvalue expression</em> is either lvalue or xvalue.) expression of volatile-qualified type is treated as a visible side-effect for the <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/as_if">purposes of optimization</a> (that is, within a single thread of execution, volatile accesses cannot be optimized out or reordered with another visible side effect that is <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/eval_order">sequenced-before</a> or sequenced-after the volatile access. This makes volatile objects suitable for communication with a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/program/signal">signal handler</a>, but not with another thread of execution, see <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>). Any attempt to refer to a volatile object through a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category#glvalue">glvalue</a> of non-volatile type (e.g. through a reference or pointer to non-volatile type) results in undefined behavior.</li>
<li><em><strong>const volatile object</strong></em> - an object whose type is <em>const-volatile-qualified</em>, a non-mutable subobject of a const volatile object, a const subobject of a volatile object, or a non-mutable volatile subobject of a const object. Behaves as both a const object and as a volatile object.</li>
</ul>
<h2 id="accumulation"><a href="#accumulation" class="headerlink" title="accumulation"></a>accumulation</h2><p><code>#include &lt;numeric&gt;</code></p>
<h2 id="c-11-vscode"><a href="#c-11-vscode" class="headerlink" title="c++11 vscode"></a>c++11 vscode</h2><p>“clang.cxxflags”: [“-std=c++14”]</p>
<p>setting.json</p>
<h2 id="mid"><a href="#mid" class="headerlink" title="mid"></a>mid</h2><p><code>mid = (l+r)/2;</code></p>
<p><code>mid = l+(r-l)/2;</code></p>
<p>防溢出</p>
<h2 id="iterator-second"><a href="#iterator-second" class="headerlink" title="iterator.second"></a>iterator.second</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;X, Y&gt;实际储存了一串std::pair&lt;const X, Y&gt;</span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, int&gt; m &#x3D; &#x2F;* fill it *&#x2F;;</span><br><span class="line">auto it &#x3D; m.begin();</span><br><span class="line"></span><br><span class="line">这里，如果你用*it，那么你将得到map第一个元素的std::pair</span><br><span class="line"></span><br><span class="line">现在你可以接收std::pair的两个元素：</span><br><span class="line"></span><br><span class="line">(*it).first会得到key，</span><br><span class="line"></span><br><span class="line">(*it).second会得到value。</span><br></pre></td></tr></table></figure>

<h2 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse iterator"></a>reverse iterator</h2><h2 id="c-amp-h文件-h文件里不要定义变量，可以声明！！"><a href="#c-amp-h文件-h文件里不要定义变量，可以声明！！" class="headerlink" title=".c&amp;.h文件 .h文件里不要定义变量，可以声明！！"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html">.c&amp;.h文件</a> .h文件里不要定义变量，可以声明！！</h2><ul>
<li><p>一个经典错误。3a222<br>在a.h头文件中定义变量temp并初始化，即显式初始化。int temp = 0；</p>
<p>a.c b.c文件中都包含了a.h头文件，则在编译时会出现：multiple definition of `a’的错误。</p>
<p>a.h中定义变量temp，不初始化为0即为不显示初始化。</p>
<p>不显示初始化不出错原因：<br>—— 不显式的初始化，在C语言中（C++中不是这样的），则先假定为声明，多次声明是没错的，最后才是定义。</p>
</li>
</ul>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool:         所占字节数：1    最大值：1        最小值：0</span><br><span class="line">char:         所占字节数：1    最大值：        最小值：?</span><br><span class="line">signed char:     所占字节数：1    最大值：        最小值：?</span><br><span class="line">unsigned char:     所占字节数：1    最大值：?        最小值：</span><br><span class="line">wchar_t:     所占字节数：4    最大值：2147483647        最小值：-2147483648</span><br><span class="line">short:         所占字节数：2    最大值：32767        最小值：-32768</span><br><span class="line">int:         所占字节数：4    最大值：2147483647    最小值：-2147483648</span><br><span class="line">unsigned:     所占字节数：4    最大值：4294967295    最小值：0</span><br><span class="line">long:         所占字节数：8    最大值：9223372036854775807    最小值：-9223372036854775808</span><br><span class="line">unsigned long:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">double:     所占字节数：8    最大值：1.79769e+308    最小值：2.22507e-308</span><br><span class="line">long double:     所占字节数：16    最大值：1.18973e+4932    最小值：3.3621e-4932</span><br><span class="line">float:         所占字节数：4    最大值：3.40282e+38    最小值：1.17549e-38</span><br><span class="line">size_t:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">string:     所占字节数：24</span><br></pre></td></tr></table></figure>


<h2 id="Extern"><a href="#Extern" class="headerlink" title="Extern"></a>Extern</h2><p>用extern来<strong>声明</strong>在别的文件中已经存在的变量和函数，而且格式必须严格一致（比如数组不等价于指针）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure>

<p>其实相当于只声明, 不定义.</p>
<ul>
<li>static    <strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</li>
</ul>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td>
<td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td>
<td align="left">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td>
<td align="left">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
</tbody></table>
<ul>
<li>参数可以有默认值</li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;return_type&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>每当你定义一个<code>lambda</code>表达式后，编译器会自动生成一个匿名类（这个类当然重载了<code>()</code>运算符），我们称为闭包类型（closure type）。那么在运行时，这个<code>lambda</code>表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的<code>lambda</code>表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为<code>lambda</code>捕捉块。</p>
<p>捕获列表[]: [&amp;]通过引用捕获, [=]通过值捕获, [this]成员通过引用捕获</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> add_x = [x](<span class="keyword">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;  <span class="comment">// 复制捕捉x</span></span><br><span class="line">    <span class="keyword">auto</span> multiply_x = [&amp;x](<span class="keyword">int</span> a) &#123; <span class="keyword">return</span> a * x; &#125;;  <span class="comment">// 引用捕捉x</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_x</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">multiply_x</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出：20 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="keyword">class</span> <span class="title">Oper</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_all</span><span class="params">(C&amp; c, Oper op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:c)</span><br><span class="line">        <span class="built_in">op</span>(*x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vetcor&lt;unique_ptr&lt;Shape&gt;&gt; v;</span><br><span class="line">for_all(v, [](Shape&amp; s)&#123;s.<span class="built_in">draw</span>();&#125;)</span><br><span class="line"></span><br><span class="line">[=]()-&gt;<span class="keyword">int</span>&#123;<span class="keyword">if</span>(y) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回数组，返回类型为指针，返回的数组要定义成静态数组</li>
<li>vector转数组：&amp;vector[0]传参</li>
<li>template &lt;typename&gt; … 模板（泛型编程）</li>
<li>&amp;&amp; r-value reference</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>➢ 编译程序为有虚函数的类创建一个虚函数入口地址表VFT， </p>
<p>➢ 表首地址存放在对象的起始单元中。</p>
<p>➢ 当对象调用虚函数时，通过其起始单元得到VFT首址，</p>
<p>动态绑定到相应的函数成员。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxacrfe7eaj30pa09q75b.jpg" alt="截屏2021-11-12 上午11.43.14"></p>
<p>vtbl (virtual function table) 指明了每个类在运行时应该调用 which 虚函数</p>
<p>每个类有一个自己的vtbl</p>
<p>开销: 每个对象需要一个额外的指针即指向 vtbl 的指针, 每个类需要一个 vtbl</p>
<h2 id="原型-声明-定义"><a href="#原型-声明-定义" class="headerlink" title="原型 声明 定义"></a>原型 声明 定义</h2><p>区分声明与定义</p>
<p><em><strong>*1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。*</strong></em></p>
<p><em><strong>*2、另一种是不需要建立存储空间的。 例如：extern int a 其中变量a是在别的文件中定义的*</strong></em></p>
<p>声明是向编译器介绍名字－－标识符。它告诉编译器“这个函数或变量在某处可找到。</p>
<p>而定义是说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的是函数还是变量，编译器都要为它们在定义点分配存储空间。对于变量，编译器确定变量的大小，然后在内存中开辟空间来保存其数据，对于函数，编译器会生成代码，这些代码最终也要占用一定的内存。</p>
<p><strong>基本类型变量的声明和定义是同时产生的, 对于对象来说则是分开的</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a; <span class="comment">//对象声明</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">//对象定义(初始化)</span></span><br></pre></td></tr></table></figure>

<p>所谓定义就是（编译器）创建一个对象，为这个对象分配一块内存，并给它取上一个名字，这个名字就是就是我们经常所说的变量名或对象名。</p>
<p>声明有2重含义：</p>
<p>（1） 告诉编译器，这个名字已经匹配到一块内存上，下面的代码用到变量或者对象是在别的地方定义的。声明可以出现多次。</p>
<p>（2） 告诉编译器，这个名字已经被预定了，别的地方再也不能用它来作为变量名或对象名。</p>
<p><em><strong>*定义和声明的最重要区别就是：*</strong></em></p>
<p><em><strong>*定义创建对象并为这个对象分配了内存，声明没有分配内存。*</strong></em></p>
<p>函数原型: 在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">计算机编程</a>中，<strong>函数原型</strong>（英语：<strong>Function prototype</strong>）或<strong>函数接口</strong>（英语：<strong>Function interface</strong>）是用于指定函数的名称和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81">类型特征</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0">元数</a>，参数的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B">数据类型</a>和返回值类型）的一种省略了函数体的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">函数</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A3%B0%E6%98%8E&action=edit&redlink=1">声明</a>。</p>
<h2 id="strcut和class的区别"><a href="#strcut和class的区别" class="headerlink" title="strcut和class的区别"></a><a href="(https://www.jianshu.com/p/409f931c17d9)">strcut和class的区别</a></h2><ol>
<li>默认的继承访问权。class默认的是private,strcut默认的是public(union 也是 public)。</li>
<li>默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li>
<li>“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数</li>
<li>class和struct在使用大括号{ }上的区别<br>关于使用大括号初始化<br>1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化<br>2.）如果没有定义构造函数，struct可以用大括号初始化。<br>3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化</li>
</ol>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>类的头文件应该是自己形成一个命名空间, 然后 cpp <strong>文件因为是相当于在类外进行定义</strong>所以要使用命名空间指明函数定义</p>
<h2 id="explicit-implicit"><a href="#explicit-implicit" class="headerlink" title="explicit implicit"></a>explicit implicit</h2><p>上面的代码中, “CxString string2 = 10;” 这句为什么是可以的呢? 在C++中, 如果的<strong>构造函数只有一个参数</strong>时, 那么在编译的时候就会有一个<strong>缺省的转换操作:将该构造函数对应数据类型的数据转换为该类对象.</strong> 也就是说 “CxString string2 = 10;” 这段代码, 编译器自动将整型转换为CxString类对象, 实际上等同于下面的操作:</p>
<p><code>CxString string2(10);</code></p>
<p>即隐式转换</p>
<p>当使用 explicit 关键字修饰构造函数以后, 就能避免这种操作</p>
<p>默认情况下构造函数都是 implicit 的</p>
<h2 id="friend-友元"><a href="#friend-友元" class="headerlink" title="friend 友元"></a>friend 友元</h2><p>原则上, 类的私有（private）和受保护（protected）成员不能从声明它们的同一类外部访问。但是, 此规则不适用于友元 “friends”。</p>
<p>以friend关键字修饰的函数或类称为友元函数或友元类。</p>
<p><strong>友元函数</strong>是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：</p>
<p>  <code> friend 类型 函数名(形式参数);</code></p>
<p><strong>友元类</strong>的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。    </p>
<p>　　当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下：</p>
<p><code>friend class 类名;</code></p>
<p>其中：friend和class是关键字，类名必须是程序中的一个已定义过的类。</p>
<p><strong>使用友元类时注意</strong>：</p>
<p>　　1、友元关系不能被继承。</p>
<p>　　2、友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p>
<p>　　3、友元关系具有非传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</p>
<h2 id="public-protect-private"><a href="#public-protect-private" class="headerlink" title="public protect private"></a>public protect private</h2><p><strong>继承无法访问父变量的 private 成员</strong></p>
<p><strong>访问权限</strong></p>
<p><strong>private</strong>：私有成员</p>
<p>仅可被本类的函数成员访问</p>
<p>不能被派生类、其它类和普通函数访问</p>
<p><strong>protected</strong>：受保护成员</p>
<p>可被本类和派生类的函数成员访问</p>
<p>不能被其它类函数成员和普通函数访问</p>
<p><strong>public</strong>：公有成员</p>
<p>可被任何函数成员和普通函数访问</p>
<p><strong>继承权限</strong><br><strong>public继承</strong><br>派生类通过public继承，基类的各种权限不变 。<br>派生类的成员函数，可以访问基类的public成员、protected成员，但是无法访问基类的private成员。<br>派生类的实例变量，可以访问基类的public成员，但是无法访问protected、private成员，仿佛基类的成员之间加到了派生类一般。<br>可以将public继承看成派生类将基类的public,protected成员囊括到派生类，但是不包括private成员。</p>
<p><strong>protected继承</strong><br> 派生类通过protected继承，基类的public成员在派生类中的权限变成了protected 。protected和private不变。<br>派生类的成员函数，可以访问基类的public成员、protected成员，但是无法访问基类的private成员。<br>派生类的实例变量，无法访问基类的任何成员，因为基类的public成员在派生类中变成了protected。<br>可以将protected继承看成派生类将基类的public,protected成员囊括到派生类，全部作为派生类的protected成员，但是不包括private成员。<br>private成员是基类内部的隐私，除了友元，所有人员都不得窥探。派生类的友元，都不能访问</p>
<p><strong>private继承</strong><br>派生类通过private继承，基类的所有成员在派生类中的权限变成了private。<br>派生类的成员函数，可以访问基类的public成员、protected成员，但是无法访问基类的private成员。<br>派生类的实例变量，无法访问基类的任何成员，因为基类的所有成员在派生类中变成了private。<br>可以将private继承看成派生类将基类的public,protected成员囊括到派生类，全部作为派生类的private成员，但是不包括private成员。<br>private成员是基类内部的隐私，除了友元，所有人员都不得窥探。派生类的友元，都不能访问</p>
<p><strong>总结：继承修饰符，就像是一种筛子，将基类的成员筛到派生类。public、protected、private，就是筛子的眼。</strong><br><strong>通过public继承，所有基类成员（除了private），public、protected都到了派生类里面，public筛眼比较大，不会改变访问权限。</strong><br><strong>通过protected继承，所有基类成员（除了private），public、protected都到了派生类里面，protected筛眼大小适中，所有过来的成员都变成了protected。</strong><br><strong>通过private继承，所有基类成员（除了private），public、protected都到了派生类里面，private筛眼最小，所有过来的成员都变成了private。</strong></p>
<h2 id="隐式转换和显式转换"><a href="#隐式转换和显式转换" class="headerlink" title="隐式转换和显式转换"></a>隐式转换和显式转换</h2><p>隐式转换: 比如 double = int, 或者调用构造函数的那种(见explicit implicit)</p>
<p>显式转换: 又称强制类型转换. 比如 int(), static_cast</p>
<p>保护值不被改变的隐式类型转换称为”提升”, 如整型提升</p>
<p>浮点到整数发生截断, -1.6 → -1</p>
<h2 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h2><p>当返回的值不是引用型时，编译器会专门给返回值分配出一块内存的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">t</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">T x=<span class="built_in">function1</span>();</span><br></pre></td></tr></table></figure>

<p>这里的过程是：<br>1.创建命名对象t<br>2.<strong>拷贝构造一个无名的临时对象，并返回这个临时对象</strong><br>3.由临时对象拷贝构造对象x<br>4.T x=function1();这句语句结束时，析构临时对象<br>这里一共生成了3个对象，一个命名对象t，一个临时对象作为返回值，一个命名对象x。</p>
<p>返回引用, 其实就是返回了一个对象的引用, 新对象 = 返回的引用, 调用了拷贝构造函数</p>
<h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><p>虚继承: 避免继承多次同一个基类</p>
<p>在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，<a target="_blank" rel="noopener" href="http://www.gfgb120.com/">虚基类是间接基类</a>，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的</p>
<p><strong>在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序</strong></p>
<h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>静态成员变量必须?要在类外部定义, 因为要在对象创建之前就分配内存</p>
<h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>带缺省值的参数必须放在参数列表的最后面。因为传参是从右向左的。<br>缺省参数不能同时在函数声明和定义中出现，只能二者留其一。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在构造函数体前初始化：只读成员、引用成员、对象成员, 包括在声明时初始化和在列表中初始化</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>从小到大可以分为五级：</p>
<p>① 作用于表达式内 (常量) </p>
<p>② 作用于函数成员内 (函数参数、局部变量、局部类型) </p>
<p>③ 作用于类或派生类内 (数据/函数/类型 成员) </p>
<p>④ 作用于基类内 (数据/函数/类型 成员) </p>
<p>⑤ 作用于虚基类内 (数据/函数/类型 成员)</p>
<p>虚基类 》基类 》类 /派生类 》成员函数 》表达式内</p>
<h2 id="成员指针"><a href="#成员指针" class="headerlink" title="成员指针"></a>成员指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class Student &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">……</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">xu</span><span class="params">(<span class="number">123</span>,<span class="string">&quot;Xuxiangyang&quot;</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">zhang</span><span class="params">(<span class="number">456</span>,”Zhangsan”,<span class="number">99</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;xu.number; <span class="comment">// p 指向对象 xu中的number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::*q = &amp;Student::number; <span class="comment">// q 数据成员指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int Student::*q; q= &amp;Student::number;</span></span><br><span class="line">cout &lt;&lt; xu.*q&lt;&lt;endl; <span class="comment">// cout &lt;&lt; xu.number &lt;&lt;endl; </span></span><br><span class="line">cout &lt;&lt; zhang.*q &lt;&lt;endl;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;Student::number; <span class="comment">//无法从 Student::* 转换为 int ***</span></span><br></pre></td></tr></table></figure>

<p>对于普通指针变量来说，其值是它所指向的地址，0表示空指针。<br>而对于数据成员指针变量来说，其值是数据成员所在地址相对于对象起始地址的偏移值，空指针用-1表示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE_OF_PTR(p)     (*(long*)&amp;p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X::*p = <span class="number">0</span>;  <span class="comment">// VALUE_OF_PTR(p) == -1</span></span><br><span class="line">    p = &amp;X::a;      <span class="comment">// VALUE_OF_PTR(p) == 0</span></span><br><span class="line">    p = &amp;X::b;      <span class="comment">// VALUE_OF_PTR(p) == 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="–-重载"><a href="#–-重载" class="headerlink" title="++(–)重载"></a>++(–)重载</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/aaqian1/article/details/85954206">https://blog.csdn.net/aaqian1/article/details/85954206</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Three <span class="keyword">operator</span>--();	<span class="comment">//声明自减运算符--重载成员函数(前缀方式)</span></span><br><span class="line">Three <span class="keyword">operator</span>--(<span class="keyword">int</span>); <span class="comment">//声明自减运算符--重载成员函数(后缀方式)</span></span><br></pre></td></tr></table></figure>

<p>++lvalue ⇒ lvalue+=1 ⇒ lvalue = lvalue+1</p>
<p>y=x++ ⇒ y=(t=x, x=x+1, t)</p>
<h1 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/hairetz/article/details/4141043">堆与栈</a></h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/344377490">https://zhuanlan.zhihu.com/p/344377490</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p0;</span><br><span class="line">    <span class="keyword">void</span>* p1;</span><br><span class="line">    <span class="keyword">void</span>* p2;</span><br><span class="line">    <span class="keyword">void</span>* p3;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* p4;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* p5;</span><br><span class="line">    <span class="keyword">void</span>* p6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* pc = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    string* s456 = <span class="keyword">new</span> string&#123;<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">    string s123 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    string s234 &#123;<span class="string">&quot;234&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> string cs123 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> string cs234 = <span class="string">&quot;234&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> string ss456 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p0 = pc;</span><br><span class="line">    p1 = s456;</span><br><span class="line">    p2 = &amp;s123;</span><br><span class="line">    p3 = &amp;s234;</span><br><span class="line">    p4 = &amp;cs123;</span><br><span class="line">    p5 = &amp;cs234;</span><br><span class="line">    p6 = &amp;ss456;</span><br><span class="line">    pi = &amp;i;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;p0&lt;&lt;endl&lt;&lt;p1&lt;&lt;endl&lt;&lt;p2&lt;&lt;endl&lt;&lt;p3&lt;&lt;endl&lt;&lt;p4&lt;&lt;endl&lt;&lt;p5&lt;&lt;endl&lt;&lt;p6&lt;&lt;endl&lt;&lt;pi&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x10b906e21    char* pc = &quot;123&quot;</span></span><br><span class="line"><span class="comment">0x600002b1d120 string* s456 = new string&#123;&quot;456&quot;&#125;</span></span><br><span class="line"><span class="comment">0x7ff7b45fc900 string s123&#123;&quot;123&quot;&#125;</span></span><br><span class="line"><span class="comment">0x7ff7b45fc8e8 string s234&#123;&quot;234&quot;&#125;</span></span><br><span class="line"><span class="comment">0x7ff7b45fc8d0 const string cs123 = &quot;123&quot;</span></span><br><span class="line"><span class="comment">0x7ff7b45fc8b8 const string cs234 = &quot;234&quot;</span></span><br><span class="line"><span class="comment">0x10b9071b8    static string ss456 = &quot;456&quot;</span></span><br><span class="line"><span class="comment">0x7ff7bda118d4 const int i = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">可以看出 <span class="keyword">static</span> 和字符串常量在一个位置</span><br></pre></td></tr></table></figure>



<h2 id="一、预备知识—程序的内存分配"><a href="#一、预备知识—程序的内存分配" class="headerlink" title="一、预备知识—程序的内存分配"></a>一、预备知识—程序的内存分配</h2><p><img src="https://pic1.zhimg.com/80/v2-6b739f63e83c84d07db2b7badcbe472c_1440w.jpg" alt="img"></p>
<p> 一个由C/C++编译的程序占用的内存分为以下几个部分 </p>
<ol>
<li><p><strong>Code Segment（代码区）</strong></p>
<p>也称Text Segment，存放可执行程序的机器码。</p>
<p><strong>Data Segment (数据区）</strong></p>
<p>存放已初始化的全局和静态变量， 常量数据（如<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:344377490%7D">字符串</a>常量）。</p>
<p><strong>BSS（Block started by symbol)</strong></p>
<p>存放未初始化的全局和静态变量。（默认设为0）</p>
<p><strong>Heap（堆）</strong></p>
<p>从低地址向高地址增长。容量大于栈，程序中动态分配的内存在此区域。</p>
<p><strong>Stack（栈）</strong></p>
<p>从高地址向低地址增长。由编译器自动管理分配。程序中的局部变量、函数参数值、返回变量等存在此区域。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp  </span></span><br><span class="line"><span class="keyword">int</span>  a  =  <span class="number">0</span>;  全局初始化区  </span><br><span class="line"><span class="keyword">char</span>  *p1;  全局未初始化区  </span><br><span class="line"><span class="built_in">main</span>()  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">int</span>  b;  栈  </span><br><span class="line">  <span class="keyword">char</span>  s[]  =  <span class="string">&quot;abc&quot;</span>;  栈  </span><br><span class="line">  <span class="keyword">char</span>  *p2;  栈  </span><br><span class="line">  <span class="keyword">char</span>  *p3  =  <span class="string">&quot;123456&quot;</span>;  <span class="number">123456</span>/<span class="number">0</span>在常量区，p3在栈上。  </span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">int</span>  c  =<span class="number">0</span>；  全局（静态）初始化区  </span><br><span class="line">  p1  =  (<span class="keyword">char</span>  *)<span class="built_in">malloc</span>(<span class="number">10</span>);  </span><br><span class="line">  p2  =  (<span class="keyword">char</span>  *)<span class="built_in">malloc</span>(<span class="number">20</span>);  </span><br><span class="line">  <span class="comment">//分配得来得10和20字节的区域就在堆区。  </span></span><br><span class="line">  <span class="built_in">strcpy</span>(p1,  <span class="string">&quot;123456&quot;</span>);  <span class="comment">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="二、堆和栈的理论知识"><a href="#二、堆和栈的理论知识" class="headerlink" title="二、堆和栈的理论知识"></a>二、堆和栈的理论知识</h2><h3 id="2-1申请方式"><a href="#2-1申请方式" class="headerlink" title="2.1申请方式"></a>2.1申请方式</h3><ul>
<li>stack:<br>由系统自动分配。 例如，声明在函数中一个局部变量  int  b;  系统自动在栈中为b开辟空间  </li>
<li>heap:<br>需要程序员自己申请，并指明大小，在c中malloc函数<br>如p1  =  (char  *)malloc(10);<br>在C++中用new运算符<br>如p2  =  new  char[10];<br><strong>但是注意p1、p2本身是在栈中的。</strong>  </li>
</ul>
<h3 id="2-2-申请后系统的响应"><a href="#2-2-申请后系统的响应" class="headerlink" title="2.2  申请后系统的响应"></a>2.2  申请后系统的响应</h3><ul>
<li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢 出。  </li>
<li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。<br>另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部 分重新放入空闲链表中。  </li>
</ul>
<h3 id="2-3申请大小的限制"><a href="#2-3申请大小的限制" class="headerlink" title="2.3申请大小的限制"></a>2.3申请大小的限制</h3><ul>
<li>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。  </li>
<li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。  </li>
</ul>
<h3 id="2-4申请效率的比较："><a href="#2-4申请效率的比较：" class="headerlink" title="2.4申请效率的比较："></a>2.4申请效率的比较：</h3><ul>
<li>栈由系统自动分配，速度较快。但程序员是无法控制的。  </li>
<li>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>另外，在WINDOWS 下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈, 是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 </li>
</ul>
<h3 id="2-5堆和栈中的存储内容"><a href="#2-5堆和栈中的存储内容" class="headerlink" title="2.5堆和栈中的存储内容"></a>2.5堆和栈中的存储内容</h3><ul>
<li>栈：在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。  </li>
<li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。  </li>
</ul>
<h3 id="2-6存取效率的比较"><a href="#2-6存取效率的比较" class="headerlink" title="2.6存取效率的比较"></a>2.6存取效率的比较</h3><p> char  s1[]  =  “aaaaaaaaaaaaaaa”;<br> char  *s2  =  “bbbbbbbbbbbbbbbbb”;<br> aaaaaaaaaaa是在运行时刻赋值的；<br> 而bbbbbbbbbbb是在编译时就确定的；<br> 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。<br> 比如： </p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">   <span class="keyword">char</span>  a  =  <span class="number">1</span>;  </span><br><span class="line">   <span class="keyword">char</span>  c[]  =  <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span>  *p  =<span class="string">&quot;1234567890&quot;</span>; </span><br><span class="line">   a  =  c[<span class="number">1</span>];  </span><br><span class="line">   a  =  p[<span class="number">1</span>];  </span><br><span class="line">   <span class="keyword">return</span>;  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p> 对应的汇编代码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10:  a  &#x3D;  c[1];  </span><br><span class="line">00401067  8A  4D  F1  mov  cl,byte  ptr  [ebp-0Fh]  </span><br><span class="line">0040106A  88  4D  FC  mov  byte  ptr  [ebp-4],cl  </span><br><span class="line">11:  a  &#x3D;  p[1];  </span><br><span class="line">0040106D  8B  55  EC  mov  edx,dword  ptr  [ebp-14h]  </span><br><span class="line">00401070  8A  42  01  mov  al,byte  ptr  [edx+1]  </span><br><span class="line">00401073  88  45  FC  mov  byte  ptr  [ebp-4],al  </span><br></pre></td></tr></table></figure>


<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。  </p>
<h3 id="2-7小结："><a href="#2-7小结：" class="headerlink" title="2.7小结："></a>2.7小结：</h3><p>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。  (经典！) </p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ydar95/article/details/69822540">类型转换</a></h1><blockquote>
<p>const_cast , static_cast , dynamic_cast , reinterpret_cast</p>
</blockquote>
<h2 id="1-C风格的强制转换"><a href="#1-C风格的强制转换" class="headerlink" title="1. C风格的强制转换"></a>1. C风格的强制转换</h2><p>C风格的强制转换(Type Cast)容易理解,不管什么类型的转换都可以使用使用下面的方式.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeName b = (TypeName)a;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当然,C++也是支持C风格的强制转换,但是C风格的强制转换可能带来一些隐患,让一些问题难以察觉.所以C++提供了一组可以用在不同场合的强制转换的函数.</p>
<h2 id="2-C-四种强制转换类型函数"><a href="#2-C-四种强制转换类型函数" class="headerlink" title="2. C++ 四种强制转换类型函数"></a>2. C++ 四种强制转换类型函数</h2><h3 id="2-1-const-cast"><a href="#2-1-const-cast" class="headerlink" title="2.1 const_cast"></a>2.1 const_cast</h3><p>1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；<br>2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；<br>3、const_cast一般用于修改指针。如const char *p形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始数组</span></span><br><span class="line">    <span class="keyword">int</span> ary[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        std::cout &lt;&lt; ary[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量化数组指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>*c_ptr = ary;</span><br><span class="line">    <span class="comment">//c_ptr[1] = 233;   //error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过const_cast&lt;Ty&gt; 去常量</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(c_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        ptr[i] += <span class="number">1</span>;    <span class="comment">//pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印修改后的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        std::cout &lt;&lt; ary[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  out print</span></span><br><span class="line"><span class="comment">    1   2   3   4</span></span><br><span class="line"><span class="comment">    2   3   4   5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意:对于在定义为常量的参数,使用const_cast可能会有不同的效果.类似代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_val = <span class="number">233</span>;  <span class="comment">//声明为常量类型</span></span><br><span class="line">    <span class="keyword">int</span> &amp;use_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(c_val); <span class="comment">//使用去const 引用</span></span><br><span class="line">    <span class="keyword">int</span> *ptr_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;c_val);<span class="comment">//使用去const 指针</span></span><br><span class="line"></span><br><span class="line">    use_val = <span class="number">666</span>;  <span class="comment">//未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; std::endl;</span><br><span class="line">    *ptr_val = <span class="number">110</span>; <span class="comment">//未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在 vs2017 下 输出为</span></span><br><span class="line"><span class="comment">    233 666 666</span></span><br><span class="line"><span class="comment">    233 110 110</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>未定义行为:C++标准对此类行为没有做出明确规定.同一份代码在使用不同的编译器会有不同的效果.在 vs2017 下, 虽然代码中 <em>c_val , use_val , ptr_val</em> 看到的地址是一样的.但是c_val的值并没有改变.有可能在某种编译器实现后,这一份代码的<em>c_val</em> 会被改变.也有可能编译器对这类行为直接 <em>error</em> 或 <em>warning</em>.</p>
<h3 id="2-2-static-cast"><a href="#2-2-static-cast" class="headerlink" title="2.2 static_cast"></a>2.2 static_cast</h3><ol>
<li>static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。</li>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。</li>
<li>static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)</li>
<li>在c++ primer 中说道：c++ 的任何的隐式转换都是使用 <em>static_cast</em> 来实现。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常规的使用方法 */</span></span><br><span class="line"><span class="keyword">float</span> f_pi=<span class="number">3.141592f</span></span><br><span class="line"><span class="keyword">int</span>   i_pi=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f_pi); <span class="comment">/// i_pi 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* class 的上下行转换 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);    </span><br></pre></td></tr></table></figure>

<h3 id="2-3-dynamic-cast"><a href="#2-3-dynamic-cast" class="headerlink" title="2.3 dynamic_cast"></a>2.3 dynamic_cast</h3><p><em>dynamic_cast</em>强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sub-&gt;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Sub * sub = <span class="keyword">new</span> <span class="built_in">Sub</span>();</span><br><span class="line">    sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Base* sub2base = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(sub);</span><br><span class="line">    <span class="keyword">if</span> (sub2base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sub2base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&lt;sub-&gt;base&gt; sub2base val is: &quot;</span> &lt;&lt; sub2base &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Base-&gt;Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Sub  *base2sub = <span class="keyword">dynamic_cast</span>&lt;Sub*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (base2sub != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        base2sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;&lt;base-&gt;sub&gt; base2sub val is: &quot;</span>&lt;&lt; base2sub &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* vs2017 输出为下</span></span><br><span class="line"><span class="comment">Sub-&gt;Base</span></span><br><span class="line"><span class="comment">I&#x27;m Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;sub-&gt;base&gt; sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base-&gt;Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;base-&gt;sub&gt; base2sub val is: 00000000   // VS2017的C++编译器,对此类错误的转换赋值为nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>从上边的代码和输出结果可以看出:<br>对于<em>从子类到基类的指针转换</em> ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果<br>而<em>从基类到子类的转换</em> , dynamic_cast 在转换时也没有报错,但是输出给 <em>base2sub</em> 是一个 <em>nullptr</em> ,说明dynami_cast 在程序运行时对类型转换对<em>“运行期类型信息”（Runtime type information，RTTI）</em>进行了检查.<br>这个检查主要来自<em>虚函数(virtual function)</em> 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。<em>因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数</em></p>
<h3 id="2-4-reinterpret-cast"><a href="#2-4-reinterpret-cast" class="headerlink" title="2.4 reinterpret_cast"></a>2.4 reinterpret_cast</h3><p>reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！<br>他是用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换，在下面的文章中将给出.<br>请看一个简单代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">233</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> ptr_addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(ptr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 的地址: &quot;</span> &lt;&lt; hex &lt;&lt; ptr &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;ptr_addr 的值(hex): &quot;</span> &lt;&lt; hex &lt;&lt; ptr_addr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ptr 的地址: 0061E6D8</span></span><br><span class="line"><span class="comment">ptr_addr 的值(hex): 0061e6d8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上述代码将指针ptr的地址的值转换成了 <em>unsigned int</em> 类型的ptr_addr 的整数值.<br>提供下IBM C++ 对 reinterpret_cast 推荐使用的地方<br>A pointer to any integral type large enough to hold it （指针转向足够大的整数类型）<br>A value of integral or enumeration type to a pointer （从整形或者enum枚举类型转换为指针）<br>A pointer to a function to a pointer to a function of a different type （从指向函数的指针转向另一个不同类型的指向函数的指针）<br>A pointer to an object to a pointer to an object of a different type （从一个指向对象的指针转向另一个不同类型的指向对象的指针）<br>A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types （从一个指向成员的指针转向另一个指向类成员的指针！或者是类型，如果类型的成员和函数都是函数类型或者对象类型）</p>
<p>下面这个例子来自 MSDN 的一个<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/e0w9f63b(VS.80).aspx">哈希函数辅助</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expre_reinterpret_cast_Operator.cpp  </span></span><br><span class="line"><span class="comment">// compile with: /EHsc  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a hash code based on an address  </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">Hash</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">short</span>)(val ^ (val &gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">Hash</span>(a + i) &lt;&lt; endl;</span><br><span class="line">&#125;<span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<h2 id="3-结尾"><a href="#3-结尾" class="headerlink" title="3. 结尾"></a>3. 结尾</h2><p>在使用强制转换的时候,请先考虑清楚我们真的需要使用强制转换和我们应该使用那种强制转换.<br>我这只是简单的介绍这四种强制转换的用途,以上是自己的理解,文章中肯定有各种问题错误,希望大家帮忙指出矫正,本文仅供参考.<br>谢谢阅读.</p>
<h1 id="Effective-c"><a href="#Effective-c" class="headerlink" title="Effective c++"></a>Effective c++</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>声明式: 告诉编译器某个东西的名称和类型</p>
<p>签名式(signature): 每个函数的声明揭示其签名式, 也就是参数和返回类型</p>
<p>定义式: 提供给编译器 一些声明式的细节, 对对象而言, 定义式是编译器为此对象拨发内存的地址; 对函数或者函数模板而言, 定义式提供了代码本体; 对于 class 而言定义式列出他们的成员</p>
<p>copy 构造函数定义了一个对象如何 passed by value</p>
<p>接口: 函数的签名或 class 内可访问的元素</p>
<h2 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h2><p>不会对这个类的对象的数据成员作出任何改变, 即在 const 成员函数中无法赋值</p>
<table>
<thead>
<tr>
<th>可否调用函数</th>
<th align="center">const 对象</th>
<th align="center">noconst 对象</th>
</tr>
</thead>
<tbody><tr>
<td>const 成员函数</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td>noconst 成员函数</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
</tbody></table>
<p>const 成员函数也不要提供修改途径(比如返回引用), 虽然可以通过编译</p>
<p>可以通过 <code>mutable</code> 在 const 函数中改变对象的数据</p>
<h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><p>在构造函数中赋值相当于先初始化再赋值, 有开销<br>所以要用初始化列表赋值, 对象成员的初始化是在进入构造函数本体之前</p>
<p>调用构造函数初始化成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>()&#123;</span><br><span class="line">	:<span class="built_in">Name</span>(),</span><br><span class="line">  :<span class="built_in">Address</span>(),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">在初始化列表中调用构造函数</span><br></pre></td></tr></table></figure>

<p>避免编译器自动生成的 copy 构造函数和 copy 运算符, 声明为 private</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数的运作方式是, 最深层派生(most derived)的那个 class 其虚构函数最先被调用, 然后是调用其每一个 base class 的析构函数</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>调用 base 的运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base::<span class="keyword">operator</span> = (target);</span><br></pre></td></tr></table></figure>




















            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp-%E6%8C%87%E5%8D%97"><span class="toc-number">1.</span> <span class="toc-text">cpp 指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#traits"><span class="toc-number">1.1.</span> <span class="toc-text">traits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef-in-stl"><span class="toc-number">1.2.</span> <span class="toc-text">typedef in stl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADL-argument-dependent-lookup"><span class="toc-number">1.3.</span> <span class="toc-text">ADL argument-dependent lookup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dependent-name-amp-name-binding"><span class="toc-number">1.4.</span> <span class="toc-text">dependent name &amp; name binding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qualified-name"><span class="toc-number">1.5.</span> <span class="toc-text">qualified name</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nested-class"><span class="toc-number">1.6.</span> <span class="toc-text">nested class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typename"><span class="toc-number">1.7.</span> <span class="toc-text">typename</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-%E2%80%9Ctypename%E2%80%9D-keyword"><span class="toc-number">1.7.1.</span> <span class="toc-text">The “typename” keyword</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-%E2%80%9Ctemplate%E2%80%9D-keyword"><span class="toc-number">1.7.2.</span> <span class="toc-text">The “template” keyword</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependencies"><span class="toc-number">1.7.3.</span> <span class="toc-text">Dependencies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependent-names"><span class="toc-number">1.7.4.</span> <span class="toc-text">Dependent names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependent-function-names"><span class="toc-number">1.7.5.</span> <span class="toc-text">Dependent function names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Additional-notes-and-examples"><span class="toc-number">1.7.6.</span> <span class="toc-text">Additional notes and examples</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator"><span class="toc-number">1.8.</span> <span class="toc-text">iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size-t"><span class="toc-number">1.9.</span> <span class="toc-text">size_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compiler-default"><span class="toc-number">1.10.</span> <span class="toc-text">compiler default</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#default-constructor"><span class="toc-number">1.10.1.</span> <span class="toc-text">default constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destructor"><span class="toc-number">1.10.2.</span> <span class="toc-text">destructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-constructor"><span class="toc-number">1.10.3.</span> <span class="toc-text">copy constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-assignment"><span class="toc-number">1.10.4.</span> <span class="toc-text">copy assignment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move-assignment"><span class="toc-number">1.10.5.</span> <span class="toc-text">move assignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UNIX-Linux-GNU"><span class="toc-number">1.11.</span> <span class="toc-text">UNIX Linux GNU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.12.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%BC%95%E7%94%A8-this"><span class="toc-number">1.13.</span> <span class="toc-text">自引用 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-number">1.14.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#internal-linkage"><span class="toc-number">1.15.</span> <span class="toc-text">internal linkage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.16.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">1.17.</span> <span class="toc-text">对象与引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.17.1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.17.1.1.</span> <span class="toc-text">临时对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.17.1.2.</span> <span class="toc-text">普通对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.17.2.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.17.2.1.</span> <span class="toc-text">左值引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.17.2.2.</span> <span class="toc-text">右值引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.18.</span> <span class="toc-text">求值顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.19.</span> <span class="toc-text">左值右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#why-rvalue-is-allowed-to-passed-by-const-reference"><span class="toc-number">1.20.</span> <span class="toc-text">why rvalue is allowed to passed by const reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.21.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raw-string"><span class="toc-number">1.22.</span> <span class="toc-text">raw string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.23.</span> <span class="toc-text">变量与类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-%E5%87%BD%E5%AD%90"><span class="toc-number">1.24.</span> <span class="toc-text">函数对象(函子)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-template"><span class="toc-number">1.25.</span> <span class="toc-text">模板 template</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enmu"><span class="toc-number">1.26.</span> <span class="toc-text">enmu</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#literal-type"><span class="toc-number">1.27.</span> <span class="toc-text">literal type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constexpr"><span class="toc-number">1.28.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-v-qualified-class"><span class="toc-number">1.29.</span> <span class="toc-text">c-v qualified class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#accumulation"><span class="toc-number">1.30.</span> <span class="toc-text">accumulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11-vscode"><span class="toc-number">1.31.</span> <span class="toc-text">c++11 vscode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mid"><span class="toc-number">1.32.</span> <span class="toc-text">mid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator-second"><span class="toc-number">1.33.</span> <span class="toc-text">iterator.second</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reverse-iterator"><span class="toc-number">1.34.</span> <span class="toc-text">reverse iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-amp-h%E6%96%87%E4%BB%B6-h%E6%96%87%E4%BB%B6%E9%87%8C%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%EF%BC%81%EF%BC%81"><span class="toc-number">1.35.</span> <span class="toc-text">.c&amp;.h文件 .h文件里不要定义变量，可以声明！！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-number">1.36.</span> <span class="toc-text">内置变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extern"><span class="toc-number">1.37.</span> <span class="toc-text">Extern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82"><span class="toc-number">1.38.</span> <span class="toc-text">传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.39.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.40.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%A3%B0%E6%98%8E-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.41.</span> <span class="toc-text">原型 声明 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcut%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.42.</span> <span class="toc-text">strcut和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace"><span class="toc-number">1.43.</span> <span class="toc-text">namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit-implicit"><span class="toc-number">1.44.</span> <span class="toc-text">explicit implicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#friend-%E5%8F%8B%E5%85%83"><span class="toc-number">1.45.</span> <span class="toc-text">friend 友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#public-protect-private"><span class="toc-number">1.46.</span> <span class="toc-text">public protect private</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.47.</span> <span class="toc-text">隐式转换和显式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8"><span class="toc-number">1.48.</span> <span class="toc-text">返回引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.49.</span> <span class="toc-text">虚基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.50.</span> <span class="toc-text">静态数据成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="toc-number">1.51.</span> <span class="toc-text">缺省参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.52.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.53.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number">1.54.</span> <span class="toc-text">成员指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%93-%E9%87%8D%E8%BD%BD"><span class="toc-number">1.55.</span> <span class="toc-text">++(–)重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">堆与栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.1.</span> <span class="toc-text">一、预备知识—程序的内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">二、堆和栈的理论知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1申请方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%94%B3%E8%AF%B7%E5%90%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2  申请后系统的响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E7%94%B3%E8%AF%B7%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3申请大小的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E7%94%B3%E8%AF%B7%E6%95%88%E7%8E%87%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4申请效率的比较：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5堆和栈中的存储内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E5%AD%98%E5%8F%96%E6%95%88%E7%8E%87%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.6存取效率的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.7小结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">1. C风格的强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-C-%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">2. C++ 四种强制转换类型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-const-cast"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-static-cast"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-dynamic-cast"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-reinterpret-cast"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 reinterpret_cast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%93%E5%B0%BE"><span class="toc-number">3.3.</span> <span class="toc-text">3. 结尾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-c"><span class="toc-number">4.</span> <span class="toc-text">Effective c++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">4.1.</span> <span class="toc-text">绪论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">const 成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">4.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.5.</span> <span class="toc-text">运算符</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
