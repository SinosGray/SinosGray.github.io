<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Category: 读书笔记 | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="cpp20入门读书笔记">
<meta property="og:url" content="https://sinos_wei.gitee.io/2023/01/804677221633.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/IMG_6227.JPG">
<meta property="article:published_time" content="2023-01-04T04:25:28.000Z">
<meta property="article:modified_time" content="2023-03-17T03:58:22.479Z">
<meta property="article:author" content="Sinos">
<meta property="article:tag" content="std">
<meta property="article:tag" content="cout">
<meta property="article:tag" content="move">
<meta property="article:tag" content="optional">
<meta property="article:tag" content="rvalue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/IMG_6227.JPG"><link rel="shortcut icon" href="/img/icon.JPG"><link rel="canonical" href="https://sinos_wei.gitee.io/2023/01/804677221633"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: 读书笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-17 11:58:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">145</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/IMG_6227.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Sinos_wei's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">cpp20入门读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-04T04:25:28.000Z" title="Created 2023-01-04 12:25:28">2023-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-17T03:58:22.479Z" title="Updated 2023-03-17 11:58:22">2023-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cpp20入门读书笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>

</blockquote>
<span id="more"></span>
<blockquote>
<p>目前编译器对 c++20 只部分支持, 请谨慎使用</p>
</blockquote>
<h1 id="basic-ideas">1. Basic Ideas</h1>
<h1 id="introducing-fundamental-types-of-data">2. Introducing Fundamental Types of Data</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> braced_init &#123;<span class="number">15</span>&#125;;</span><br><span class="line"><span class="comment">//The braced initializer form, however, is slightly safer when it comes to so-called narrowing conversions窄化转换 . A narrowing conversion changes a value to a type with a more limited range of values范围变小. Any such conversion thus has the potential to lose information.</span></span><br><span class="line"><span class="comment">//大括号初始化如果窄化转换,标准编译器会提出 warning, 其他的则不一定</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function_notation</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> assignment_notation = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>Type signed char is always one byte</p>
<p>The signed modifier is mostly optional; if omitted, your type will <strong>be signed by default.</strong> The only <strong>exception to this rule is char</strong>. While the unmodified type char does exist, it is compiler-dependent whether it is signed or unsigned.</p>
<p>Only use variables of the unmodified char type to store letter characters. To store numbers, you should use either signed char or unsigned char. std::byte type to store binary data</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> counter &#123;&#125;; <span class="comment">// counter starts at zero</span></span><br><span class="line"><span class="comment">//Zero initialization works for any fundamental type. For all fundamental numeric types, for instance, an empty braced initializer is always assumed to contain the number zero.</span></span><br></pre></td></tr></table></figure>
<p>Ever since C++14, you can use the single quote character, ', to make numeric literals more readable. Here’s an example: <code>22'333 -1'234LL 12'345ULL</code></p>
<p>there are situations where you do need to add the correct literal suffixes, such as when you initialize a variable with type <strong>auto</strong></p>
<p>Binary literals were introduced by the C++14 standard. You write a binary integer literal as a sequence of binary digits (0 or 1) prefixed by either <strong>0b or 0B</strong>, eg: <code>0b1010101</code></p>
<p><code>import &lt;numbers&gt;;</code> <code>std::numbers::e</code> <code>std::numbers::e_v&lt;float&gt;</code> 特定长度 <code>#include &lt;cmath&gt;</code></p>
<p><strong>implicit conversions</strong> . The way this works is that the variable of a type with the more limited range is converted to the type of the other. order:<strong>signed 优先度低于 unsigned</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="type">double</span></span><br><span class="line"><span class="type">float</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> </span><br><span class="line"><span class="type">long</span> <span class="type">long</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x &#123;<span class="number">20u</span>&#125;;</span><br><span class="line"><span class="type">int</span> y &#123;<span class="number">30</span>&#125;;</span><br><span class="line">x-y <span class="comment">// type is unsigned int</span></span><br></pre></td></tr></table></figure>
<p><code>std::format</code> available in cpp20</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;Pond diameter required for &#123;&#125; fish is &#123;:.2&#125; feet.\n&quot;</span>, fish_count, pond_diameter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[[fill]align][sign][#][0][width][.precision][type]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Default alignment: right for numbers, left otherwise </span></span><br><span class="line">  std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;:7&#125;|&#123;:7&#125;|&#123;:7&#125;|&#123;:7&#125;|&#123;:7&#125;\n&quot;</span>, <span class="number">1</span>, <span class="number">-.2</span>, <span class="string">&quot;str&quot;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="literal">true</span>); </span><br><span class="line">  <span class="comment">//Left and right alignment + custom fill character</span></span><br><span class="line">  std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;:*&lt;7&#125;|&#123;:*&lt;7&#125;|&#123;:*&gt;7&#125;|&#123;:*&gt;7&#125;|&#123;:*&gt;7&#125;\n&quot;</span>, <span class="number">1</span>,<span class="number">-.2</span>,<span class="string">&quot;str&quot;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="literal">true</span>); </span><br><span class="line">  <span class="comment">//Centered alignment + 0 formatting option for numbers </span></span><br><span class="line">  std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;:^07&#125;|&#123;:^07&#125;|&#123;:^7&#125;|&#123;:^7&#125;|&#123;:^7&#125;\n&quot;</span>, <span class="number">1</span>, <span class="number">-.2</span>, <span class="string">&quot;str&quot;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1| -0.2|str |c |true</span></span><br><span class="line"><span class="comment">1******|-0.2***|****str|******c|***true </span></span><br><span class="line"><span class="comment">0000001|-0000.2| str | c | true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;limits&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Maximum value of type double is &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br></pre></td></tr></table></figure>
<p>Type <strong>wchar_t</strong> is a fundamental type intended for character sets where a single character does not fit into one byte. Hence its name: wchar_t derives from wide character , because the character is “wider” than the usual one-byte character. By contrast, type char is referred to as “narrow” because of the limited range of character codes that are available. You define wide-character literals in a similar way to literals of type char, but you prefix them with L. Here’s an example:<code>wchar_t z &#123;L'Z'&#125;;</code> use <strong>char8_t, char16_t, or char32_t</strong> instead. Values of these types are intended to store characters encoded as UTF-8, UTF-16, or UTF-32, their prefix are: u8, u16/u, U</p>
<h2 id="auto">auto</h2>
<p><strong>Caution</strong> You need to be careful when using braced initializers with the auto keyword. For example, suppose you write this (notice the equals sign!):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> m = &#123;<span class="number">10</span>&#125;; </span><br><span class="line"><span class="comment">// m has type std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p>To summarize, if your compiler properly supports <strong>C++17</strong>, you can use braced initialization to initialize any variable with a single value, provided you do not combine it with an assignment. If your compiler is not fully up-to-date yet, however, you should simply never use braced initializers with auto. Instead, either explicitly state the type or use assignment or functional notation.</p>
<h1 id="working-with-fundamental-data-types">3. Working with Fundamental Data Types</h1>
<p>Remember that the lifetime and scope of a variable are different things. Lifetime is the period of execution time over which a variable survives. Scope is the region of program code over which the variable name can be used. It’s important not to get these two ideas confused.</p>
<p>Variables defined outside of all blocks and classes are also called <strong>globals and have global scope</strong> (which is also called global namespace scope). This means they’re accessible in all the functions <strong>in the source file</strong> following the point at which they’re defined. If you define them at the beginning of a source file, they’ll be accessible throughout the file. In Chapter 11, we’ll show how to declare variables that can be used in multiple files.Global variables have static storage duration by default. use <code>::</code>to access</p>
<p>The <strong>using</strong> keyword has many uses:</p>
<ul>
<li><p>It allows you to refer to (specific or all) <strong>enumerators</strong> of scoped enumerations without specifying the enumeration’s name as scope.</p></li>
<li><p>It allows you to refer to (specific or all) types and functions of a <strong>namespace without specifying</strong> the namespace’s name as scope.</p></li>
<li><p>It allows you to define <strong>aliases for other types</strong>. In legacy code, you might still encounter typedef being used for the same purpose.</p></li>
</ul>
<h1 id="making-decisions">4. Making Decisions</h1>
<h1 id="arrays-and-loops">5. Arrays and Loops</h1>
<ul>
<li><p>for range loop</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; i : v) <span class="comment">// access by const reference</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="comment">// access by value, the type of i is int</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : v) <span class="comment">// access by forwarding reference, the type of i is int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; cv = v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : cv) <span class="comment">// access by f-d reference, the type of i is const int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) <span class="comment">// the initializer may be a braced-init-list</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : a) <span class="comment">// the initializer may be an array</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ([[maybe_unused]] <span class="type">int</span> n : a)  </span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// the loop variable need not be used</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n = v.<span class="built_in">size</span>(); <span class="keyword">auto</span> i : v) <span class="comment">// the init-statement (C++20)</span></span><br><span class="line">        std::cout &lt;&lt; --n + i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typedef</span> <span class="keyword">decltype</span>(v)::value_type <span class="type">elem_t</span>; <span class="type">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// typedef declaration as init-statement (C++20)</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">using</span> <span class="type">elem_t</span> = <span class="keyword">decltype</span>(v)::value_type; <span class="type">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// alias declaration as init-statement (C++23)</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="pointers-and-references">6. Pointers and References</h1>
<blockquote>
<p>Low-level dynamic memory manipulation is synonymous for a wide range of serious hazards such as dangling pointers, multiple deallocations, deallocation mismatches, memory leaks, and so on. Our golden rule is therefore this: never use the low-level new/new[] and delete/delete[] operators directly. Containers (and std::vector&lt;&gt; in particular) and smart pointers are nearly always the better choice!</p>
</blockquote>
<p><code>float const * const pvalue &#123;&amp;value&#125;;</code> read from right to left, * means "pointer to"</p>
<h2 id="new-delete">new delete</h2>
<p>It is perfectly <strong>safe to apply delete on a pointer variable that holds the value nullptr</strong>. The statement then has no effect at all. Using if tests such as the following is therefore not necessary</p>
<p>Note that the <strong>delete operator frees the memory but does not change the pointer</strong>. After the previous statement has executed, pvalue still contains the address of the memory that was allocated, but the memory is now free and may be allocated immediately to something else. A pointer that contains such a spurious address is sometimes called a <strong>dangling pointer.</strong> always resetting a pointer when you release the memory to which it points, like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pvalue; <span class="comment">// Release memory pointed to by pvalue </span></span><br><span class="line">pvalue = <span class="literal">nullptr</span>; <span class="comment">// Reset the pointer</span></span><br></pre></td></tr></table></figure>
<p>如果二次 delete 会报错捏</p>
<h2 id="smart-pointer">smart pointer</h2>
<p>Smart pointers are normally used only to store the address of memory allocated in the free store.</p>
<p>By far the most notable feature of a smart pointer is that you <strong>don’t have to worry about using the delete or delete[] operator to free the memory</strong>. It will be released automatically when it is no longer needed. This means that multiple deallocations, allocation/deallocation mismatches, and memory leaks will no longer be possible. If you consistently use smart pointers, dangling pointers will be a thing of the past as well.</p>
<p>Smart pointer types are defined by templates inside the<code>&lt;memory&gt;</code>module of the Standard Library</p>
<ul>
<li><p><code>unique_ptr&lt;T&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata &#123; std::<span class="built_in">make_unique</span>&lt;<span class="type">double</span>&gt;(<span class="number">999.0</span>) &#125;;</span><br><span class="line">cout &lt;&lt; pdata &lt;&lt; endl;<span class="comment">//指针地址</span></span><br><span class="line">cout &lt;&lt; *pdata &lt;&lt; endl;<span class="comment">//指向的值 999.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pdata&#123;std::<span class="built_in">make_unique</span>&lt;Foo&gt;(Foo&#123;<span class="number">1</span>&#125;)&#125;;</span><br><span class="line">cout &lt;&lt; pdata &lt;&lt; endl;  <span class="comment">// 指针地址</span></span><br><span class="line">cout &lt;&lt; pdata.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">// 指针地址, 注意是.get()</span></span><br><span class="line">pdata.<span class="built_in">reset</span>(<span class="keyword">new</span> Foo&#123;<span class="number">2</span>&#125;);</span><br><span class="line">Foo* p_foo &#123;pdata.<span class="built_in">release</span>()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pvalues&#123; std::<span class="built_in">make_unique</span>&lt;<span class="type">double</span>[]&gt;(n) &#125;;</span><br></pre></td></tr></table></figure>
<p>In other words, there can never be two or more unique_ptr&lt;T&gt; objects pointing to the same memory address at the same time. A unique_ptr&lt;&gt; object is said to own what it points to exclusively.</p></li>
<li><p><code>shared_ptr&lt;T&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata&#123; std::<span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">999.0</span>) &#125;</span><br><span class="line">std::shared_ptr&lt;<span class="type">double</span>&gt; pdata2 &#123;pdata&#125;;</span><br></pre></td></tr></table></figure>
<p>there can be any number of shared_ptr<T> objects that contain—or, share—the same address. The <strong>reference count</strong> for a shared_ptr&lt;&gt; containing a given free store address is incremented each time a new shared_ptr&lt;&gt; object is created containing that address, and it’s decremented when a shared_ptr&lt;&gt; containing the address is destroyed or assigned to point to a different address. All shared_ptr&lt;&gt; objects that <strong>point to the same address</strong> have access to the count of how many there are.</p></li>
<li><p><code>weak_ptr&lt;T&gt;</code></p>
<p>A weak_ptr&lt;T&gt; is linked to a shared_ptr&lt;T&gt; and contains the same address. Creating a weak_ptr&lt;&gt; does not increment the reference count associated with the linked shared_ptr&lt;&gt; object, though, so a weak_ptr&lt;&gt; does not prevent the object pointed to from being destroyed.</p>
<p>One use for having weak_ptr&lt;&gt; objects is to avoid so- called reference cycles with shared_ptr&lt;&gt; objects. Conceptually, a reference cycle is where a shared_ptr&lt;&gt; inside an object x points to some other object y that contains a shared_ptr&lt;&gt;, which points back to x.</p></li>
</ul>
<h2 id="reference-in-loop">reference in loop</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> sum &#123;&#125;;</span><br><span class="line"><span class="type">unsigned</span> count &#123;&#125;;</span><br><span class="line"><span class="type">double</span> temperatures[] &#123;<span class="number">45.5</span>, <span class="number">50.0</span>, <span class="number">48.2</span>, <span class="number">57.0</span>, <span class="number">63.8</span>&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : temperatures)<span class="comment">//t is double</span></span><br><span class="line">&#123;</span><br><span class="line">  sum += t;</span><br><span class="line">  ++count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : temperatures) &#123;<span class="comment">//t is double&amp;</span></span><br><span class="line">        sum += t;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="working-with-strings">7. Working with Strings</h1>
<ul>
<li>Internally, the terminating null character is still present in the array managed by a std::string object, but only for compatibility with legacy and/or C functions. As a user of std::string, you normally do not need to know that it even exists. All string functionality transparently deals with this legacy character for you.</li>
<li>You can use the <strong>+</strong> operator to concatenate a string object with a string literal, a character, or another string object.</li>
<li><code>std::to_string() std::stoi() std::stod()</code></li>
</ul>
<h1 id="defining-functions">8. Defining Functions</h1>
<ul>
<li>Input parameters should be reference-to-const, except for smaller values such as those of fundamental types. Returning values is generally preferred over output parameters.</li>
<li>Returning a reference from a function allows the function to be used on the left of an assignment operator. Specifying the return type as a reference-to-const prevents this.</li>
</ul>
<h1 id="vocabulary-types">9. Vocabulary Types</h1>
<ul>
<li><p>Use <strong>std::optional&lt;&gt;</strong> to represent any value that may or may not be present. Examples are optional inputs to a function or the result of a function that may fail. This makes your code self-documenting and therefore safer. As of C++17, the Standard Library provides std::optional &lt;&gt;, designed to replace all implicit encodings of optional values that we showed earlier.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; </span></span><br><span class="line"><span class="function">  <span class="title">find_last</span><span class="params">(<span class="type">const</span> std::string&amp; s,              </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span> c, </span></span></span><br><span class="line"><span class="params"><span class="function">            std::optional&lt;<span class="type">int</span>&gt; startIndex)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; </span></span><br><span class="line"><span class="function">  <span class="title">read_int_setting</span><span class="params">(<span class="type">const</span> std::string&amp; file, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> std::string&amp; setting)</span></span>;</span><br></pre></td></tr></table></figure>
<p>We replaced it with a default value that is equal to <code>std::nullopt</code> . This special constant is defined by the Standard Library to initialize optional&lt;T&gt; values that do not (yet) have a T value assigned. To check:<br />
you have the compiler convert the optional&lt;&gt; to a Boolean for you, you call the <strong>has_value()</strong> function, or you <strong>compare the optional&lt;&gt; to nullopt</strong> . To get: you can either use the *** operator** or call the <strong>value()</strong> function. Assigning the optional<size_t> return value directly to a size_t, however, would not be possible. The compiler cannot convert values of type optional<size_t> to values of type size_t.</p></li>
<li><p>Use <strong>std::string_view</strong> instead of const std::string&amp; to avoid inadvertent copies of string literals or other character arrays.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_words</span><span class="params">(std::vector&lt;std::string&gt;&amp; words,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> std::string&amp; text,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> std::string&amp; separators)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text; <span class="comment">// The string to be searched</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter some text terminated by *:\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, text, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="type">const</span> std::string separators&#123;<span class="string">&quot; ,;:.\&quot;!?&#x27;\n&quot;</span>&#125;;</span><br><span class="line">    std::vector&lt;std::string&gt; words; <span class="comment">// Words found</span></span><br><span class="line">    <span class="built_in">find_words</span>(</span><br><span class="line">        words, text, <span class="string">&quot; ,;:.\&quot;!?&#x27;\n&quot;</span>); <span class="comment">/* no more &#x27;separators&#x27; constant! */</span></span><br><span class="line">    <span class="comment">//list_words(words);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里, find_words 第三个参数传入的是字符串常量(const  char[])而不是引用</span></span><br><span class="line"><span class="comment">//编译器会隐式临时复制, 然后传入这个复制的引用</span></span><br></pre></td></tr></table></figure>
<p>The compiler, however, will refuse any and all implicit conversions of std::string_view objects to values of type std::string (give it a try!).</p>
<p>string_view does not provide a <strong>c_str()</strong> function to convert it to a const char* array.<code>std::string&#123;my_view&#125;.</code></p></li>
<li><p>Use <strong>std::span&lt;const T&gt;</strong> instead of, for instance, const std::vector&lt;T&gt;&amp; parameters to make the same function work as well for C-style arrays, std::array&lt;&gt; objects, etc.</p></li>
<li><p>Similarly, use std::span&lt;T&gt; instead of std::vector&lt;T&gt;&amp; parameters, unless you need the ability to add or remove elements.</p></li>
<li><p>The reason is that there is one significant difference between a span and a view: a span &lt;&gt;, unlike a</p>
<p>string_view , allows you to reassign or change the elements of the underlying array. While a span&lt;&gt; allows you to reassign or otherwise alter elements, it does not allow you to add or remove any elements. That is, a span&lt;&gt; does not offer members such as push_back(), erase(), or clear(). Otherwise, a span&lt;&gt; could never be created for C-style arrays or std::array&lt;&gt; objects.</p></li>
<li><p>Use std::span&lt;(const) T,N&gt; instead of (const) std::array&lt;T,N&gt;&amp; parameters to make the same function work for C-style arrays (or other containers you know to contain at least N elements).</p></li>
</ul>
<h1 id="function-templates">10. Function Templates</h1>
<p>need examples</p>
<h1 id="modules-and-namespaces">11. Modules and Namespaces</h1>
<p>C++ is object oriented, in the sense that it supports the object oriented paradigm for software development.</p>
<p>However, differently from Java, C++ doesn't force you to group function definitions in classes: the standard C++ way for declaring a function is to just declare a function, without any class.</p>
<p>If instead you are talking about method declaration/definition then the standard way is to put just the declaration in an include file (normally named <code>.h</code> or <code>.hpp</code>) and the definition in a separate implementation file (normally named <code>.cpp</code> or <code>.cxx</code>). I agree this is indeed somewhat annoying and requires some duplication but it's how the language was designed (the main concept is that C++ compilation is done one unit at a time: you need the .cpp of the unit being compiled and just the .h of all the units being used by the compiled code; in other words the include file for a class must contain all the information needed to be able to generate code that uses the class). There are a LOT of details about this, with different implications about compile speed, execution speed, binary size and binary compatibility.</p>
<p>For quick experiments anything works... but for bigger projects the separation is something that is practically required (even if it may make sense to keep some implementation details in the public .h).</p>
<p>Note: Even if you know Java, C++ is a completely different language... and it's a language that cannot be learned by experimenting. The reason is that it's a rather complex language with a lot of asymmetries and apparently illogical choices, and most importantly, when you make a mistake there are no "runtime error angels" to save you like in Java... but there are instead "undefined behavior daemons".</p>
<p>The only reasonable way to learn C++ is by reading... no matter how smart you are there is no way you can guess what the committee decided (actually being smart is sometimes even a problem because the correct answer is illogical and a consequence of historical heritage.)</p>
<p>Just pick a <a target="_blank" rel="noopener" href="https://stackoverflow.com/q/388242/320726">good book</a> or two and read them cover to cover.</p>
<h1 id="defining-your-own-data-types">12. Defining Your Own Data Types</h1>
<ul>
<li>const member functions can’t modify the member variables of a class object unless the member variables have been declared as mutable.</li>
</ul>
<h1 id="operator-overloading">13. Operator Overloading</h1>
<p>For a unary operator defined as a <strong>class member function</strong>, the operand is the class object. For a unary operator defined as a <strong>global operator function</strong>, the operand is the function parameter.</p>
<p>For a binary operator function declared <strong>as a member of a class</strong>, <strong>the left operand is the class object, and the right operand is the function parameter.</strong> For a binary operator defined by a <strong>global operator function</strong>, <strong>the first parameter specifies the left operand, and the second parameter specifies the right operand</strong>.</p>
<p>If you overload operators == and &lt;=&gt;, you get operators !=, &lt;, &gt;, &lt;=, and &gt;= all for free. In many cases you can even have the compiler generate the code for you.</p>
<h1 id="inheritance">14. Inheritance</h1>
<p>A derived class constructor can, and often should, explicitly call constructors for its direct bases in the initialization list for the constructor. If you don’t call one explicitly, the base class’s default constructor is called. A copy constructor in a derived class, for one, should always call the copy constructor of all direct base classes.</p>
<h1 id="polymorphism">15. Polymorphism</h1>
<p>You should use the override qualifier with each member function of a derived class that overrides a virtual base class member. This causes the compiler to verify that the functions signatures in the base and derived classes are, and forever remain, the same.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Carton</span> : <span class="keyword">public</span> Box</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">volume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// Function body as before...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Details of the class as in Ex15_02... &#125;;</span></span><br></pre></td></tr></table></figure>
<p>The <strong>dynamic_cast&lt;&gt;</strong> operator is generally used to cast from a pointer-to-a-polymorphic-base-class to a pointer- to-a-derived-class. If the pointer does not point to an object of the given derived class type, <strong>dynamic_cast&lt;&gt; evaluates to nullptr</strong>. This type check is performed dynamically, at runtime.</p>
<h1 id="runtime-errors-and-exceptions">16. Runtime Errors and Exceptions</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Code that may throw exceptions must be in a try block...</span></span><br><span class="line">  <span class="keyword">if</span> (test &gt; <span class="number">5</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;test is greater than 5&quot;</span>; <span class="comment">// Throws an exception of type const char*</span></span><br><span class="line">  <span class="comment">// This code only executes if the exception is not thrown... &#125;</span></span><br><span class="line">  <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* message)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// Code to handle the exception...</span></span><br><span class="line">  <span class="comment">// ...which executes if an exception of type &#x27;char*&#x27; or &#x27;const char*&#x27; is thrown </span></span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If an exception isn’t caught by any catch block, then the std::terminate() function is called, which immediately aborts the program execution.</p>
<p>The noexcept specification for a function indicates that the function does not throw exceptions. If a noexcept function does throw an exception it does not catch, std::terminate() is called.</p>
<p>Even if a destructor does not have an explicit noexcept specifier, the compiler will almost always generate one for you. This implies that you must never allow an exception to leave a destructor; otherwise, std::terminate() will be triggered.</p>
<p>The Standard Library defines a range of standard exception types in the <stdexcept> module that are derived from the std::exception class that is defined in the <exception> module.</p>
<h1 id="class-templates">17. Class Templates</h1>
<p>Always use the copy-and-swap idiom to implement the copy assignment operator in terms of the copy constructor and a (noexcept) swap() function. Use the const-and-back-again idiom to implement non- const overloads in terms of const overloads of the same member function to avoid having to repeat yourself. This is an example of the DRY principle (Don’t Repeat Yourself), which advocates avoiding code duplication at all costs.</p>
<h1 id="move-semantics">18. Move Semantics</h1>
<p>std::move() can be used to convert an lvalue (such as a named variable) into an rvalue. Take care, though. Once moved, an object should normally not be used anymore.</p>
<p><strong>std::move() Does Not Move</strong></p>
<p>Make no mistake, std::move() does not move anything. All this function does is turn a given lvalue into an rvalue reference.</p>
<p>If there’s no move assignment operator for Array&lt;&gt; to accept the rvalue, the copy assignment operator will be used instead. So, always remember, adding std::move() is of no consequence if the function or constructor that you are passing a value to has no overload with an rvalue reference parameter!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Array&lt;std::string&gt; more_strings&#123; <span class="number">2&#x27;000</span> &#125;; Array&lt;std::string&gt;&amp;&amp; rvalue_ref&#123; std::<span class="built_in">move</span>(more_strings) &#125;; </span><br><span class="line">strings = rvalue_ref;</span><br></pre></td></tr></table></figure>
<p>Notwithstanding that the rvalue_ref variable clearly has an rvalue reference type, the output of the program will show that the corresponding object is copied: <code>Array of 1000 elements moved (assignment) Array of 2000 elements copied</code></p>
<p>Every variable name expression is an lvalue, even if the type of that variable is an rvalue reference type. To move the contents of a named variable, you must therefore always add std::move():</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strings = std::<span class="built_in">move</span>(rvalue_ref);</span><br></pre></td></tr></table></figure>
<p>One way to work around this duplication is to redefine the const T&amp; overload in terms of the T&amp;&amp; one like so:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> <span class="type">void</span> Array&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; element)</span><br><span class="line"> &#123; <span class="built_in">push_back</span>(T&#123; element &#125;); <span class="comment">// Create a temporary, transient copy and push that &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//better way in one function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Array&lt;T&gt;::<span class="built_in">push_back</span>(T element) <span class="comment">// Pass by value (copied lvalue, or moved rvalue!) </span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">newArray[m_size] = std::<span class="built_in">move</span>(element); <span class="comment">// Move the new element...</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>how a modern C++ compiler is supposed to <strong>handle return-by-value</strong> (slightly simplified, as always):</p>
<ul>
<li><p>In a return statement of the form return name;, a compiler is obliged to treat name as if it were an rvalue expression, provided name is either the name of a locally defined automatic variable or that of a function parameter.</p></li>
<li><p>In a return statement of the form return name;, a compiler is allowed to apply the so-called named return value optimization (NRVO), provided name is the name of a locally defined automatic variable (so not if it is that of a function parameter).</p></li>
</ul>
<p>The first bullet implies that using std::move(result) in our example would be, at the very least, redundant. Even</p>
<p><strong>without the std::move(), the compiler already treats result as if it is an rvalue</strong>. The second bullet moreover implies that return std::move(result) would prohibit the NRVO optimization. NRVO applies solely to statements of the form return result;</p>
<p>if the variable value in return value; has static or thread-local storage duration (see Chapter 11), you need to add std::move() if moving is what you want. This case is rare, though. When returning an object’s member variable, as in return m_member_variable;, std::move() is again required if you do not want the member variable to be copied. If the return statement contains any other lvalue expression besides the name of a single variable, then NRVO does not apply, nor will the compiler treat this lvalue as if it were an rvalue when looking for a constructor.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Array&lt;T&gt;&amp; Array&lt;T&gt;::<span class="keyword">operator</span>=(Array&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array of &quot;</span> &lt;&lt; rhs.m_size &lt;&lt; <span class="string">&quot; elements moved (assignment)&quot;</span></span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (&amp;rhs != <span class="keyword">this</span>) <span class="comment">// prevent trouble with self-assignments</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_elements;         <span class="comment">// delete[] all existing elements</span></span><br><span class="line">        m_elements = rhs.m_elements; <span class="comment">// copy the elements pointer and the size</span></span><br><span class="line">        m_size = rhs.m_size;</span><br><span class="line">        rhs.m_elements = <span class="literal">nullptr</span>; <span class="comment">// make sure rhs does not delete[] m_elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// return lhs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move and swap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;&amp; Array&lt;T&gt;::<span class="keyword">operator</span>=(Array&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    Array&lt;T&gt; <span class="built_in">moved</span>(std::<span class="built_in">move</span>(rhs)); <span class="comment">// move... (noexcept)</span></span><br><span class="line">    <span class="built_in">swap</span>(moved);                    <span class="comment">// ... and swap (noexcept)</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                   <span class="comment">// return lhs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="first-class-functions">19. First-Class Functions</h1>
<p>lambda</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> less&#123;[](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Minimum element: &quot;</span> &lt;&lt; *<span class="built_in">findOptimum</span>(numbers, less) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>in []</p>
<ul>
<li><p>capture by value : =, or just para name</p></li>
<li><p>capture by ref : &amp;</p></li>
<li><p>specific :</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> counter&#123; [&amp;count](<span class="type">int</span> x, <span class="type">int</span> y) </span><br><span class="line">    &#123; ++count; <span class="keyword">return</span> x &lt; y; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Here, count is the only variable in the enclosing scope that can be accessed from within the body of the lambda.</p>
<p>The capture default, if used, should always come first. Capture clauses such as [&amp;counter, =] or [number_to_search_for, &amp;] are therefore not allowed.</p>
<p>If you use the = capture default, you are no longer allowed to capture any specific variables by value; similarly, if you use &amp;, you can no longer capture specific variables by reference. Capture clauses such as [&amp;, &amp;counter] or [=, &amp;counter, number_to_search_for] are therefore not allowed.</p></li>
</ul>
<h1 id="containers-and-algorithms">20. Containers and Algorithms</h1>
<h1 id="constrained-templates-and-concepts">21. Constrained Templates and Concepts</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2023/01/804677221633.html">https://sinos_wei.gitee.io/2023/01/804677221633.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/std/">std</a><a class="post-meta__tags" href="/tags/cout/">cout</a><a class="post-meta__tags" href="/tags/move/">move</a><a class="post-meta__tags" href="/tags/optional/">optional</a><a class="post-meta__tags" href="/tags/rvalue/">rvalue</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/IMG_6227.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/a8b2e588036a.html"><img class="prev-cover" src="/img/cover/IMG_2619.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">cmake</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/a8bdee1d82ac.html"><img class="next-cover" src="/img/cover/IMG_0759.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">ai</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/01/45f494d95337.html" title="cpp 从入门到汇编"><img class="cover" src="/img/cover/IMG_8684.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-12</div><div class="title">cpp 从入门到汇编</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">145</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#basic-ideas"><span class="toc-number">1.</span> <span class="toc-text">1. Basic Ideas</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#introducing-fundamental-types-of-data"><span class="toc-number">2.</span> <span class="toc-text">2. Introducing Fundamental Types of Data</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">2.1.</span> <span class="toc-text">auto</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#working-with-fundamental-data-types"><span class="toc-number">3.</span> <span class="toc-text">3. Working with Fundamental Data Types</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#making-decisions"><span class="toc-number">4.</span> <span class="toc-text">4. Making Decisions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arrays-and-loops"><span class="toc-number">5.</span> <span class="toc-text">5. Arrays and Loops</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pointers-and-references"><span class="toc-number">6.</span> <span class="toc-text">6. Pointers and References</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete"><span class="toc-number">6.1.</span> <span class="toc-text">new delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#smart-pointer"><span class="toc-number">6.2.</span> <span class="toc-text">smart pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference-in-loop"><span class="toc-number">6.3.</span> <span class="toc-text">reference in loop</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#working-with-strings"><span class="toc-number">7.</span> <span class="toc-text">7. Working with Strings</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#defining-functions"><span class="toc-number">8.</span> <span class="toc-text">8. Defining Functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vocabulary-types"><span class="toc-number">9.</span> <span class="toc-text">9. Vocabulary Types</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#function-templates"><span class="toc-number">10.</span> <span class="toc-text">10. Function Templates</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#modules-and-namespaces"><span class="toc-number">11.</span> <span class="toc-text">11. Modules and Namespaces</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#defining-your-own-data-types"><span class="toc-number">12.</span> <span class="toc-text">12. Defining Your Own Data Types</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#operator-overloading"><span class="toc-number">13.</span> <span class="toc-text">13. Operator Overloading</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#inheritance"><span class="toc-number">14.</span> <span class="toc-text">14. Inheritance</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#polymorphism"><span class="toc-number">15.</span> <span class="toc-text">15. Polymorphism</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#runtime-errors-and-exceptions"><span class="toc-number">16.</span> <span class="toc-text">16. Runtime Errors and Exceptions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class-templates"><span class="toc-number">17.</span> <span class="toc-text">17. Class Templates</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#move-semantics"><span class="toc-number">18.</span> <span class="toc-text">18. Move Semantics</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#first-class-functions"><span class="toc-number">19.</span> <span class="toc-text">19. First-Class Functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#containers-and-algorithms"><span class="toc-number">20.</span> <span class="toc-text">20. Containers and Algorithms</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#constrained-templates-and-concepts"><span class="toc-number">21.</span> <span class="toc-text">21. Constrained Templates and Concepts</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/5f9009e5e107.html" title="自顶向下读书笔记"><img src="/img/cover/IMG_2625.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自顶向下读书笔记"/></a><div class="content"><a class="title" href="/2022/08/5f9009e5e107.html" title="自顶向下读书笔记">自顶向下读书笔记</a><time datetime="2023-03-17T03:58:22.522Z" title="Updated 2023-03-17 11:58:22">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/5e52a7d197f6.html" title="游戏编程模式读书笔记"><img src="/img/cover/IMG_3072.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="游戏编程模式读书笔记"/></a><div class="content"><a class="title" href="/2023/02/5e52a7d197f6.html" title="游戏编程模式读书笔记">游戏编程模式读书笔记</a><time datetime="2023-03-17T03:58:22.518Z" title="Updated 2023-03-17 11:58:22">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/04/79edaf6a872c.html" title="汇编"><img src="/img/cover/IMG_6247.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="汇编"/></a><div class="content"><a class="title" href="/2020/04/79edaf6a872c.html" title="汇编">汇编</a><time datetime="2023-03-17T03:58:22.516Z" title="Updated 2023-03-17 11:58:22">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/8fb81ad8abe1.html" title="代码大全读书笔记"><img src="/img/cover/IMG_2484.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码大全读书笔记"/></a><div class="content"><a class="title" href="/2023/03/8fb81ad8abe1.html" title="代码大全读书笔记">代码大全读书笔记</a><time datetime="2023-03-17T03:58:22.511Z" title="Updated 2023-03-17 11:58:22">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/c6d69f846995.html" title="mysql必知必会读书笔记"><img src="/img/cover/IMG_0779.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql必知必会读书笔记"/></a><div class="content"><a class="title" href="/2022/10/c6d69f846995.html" title="mysql必知必会读书笔记">mysql必知必会读书笔记</a><time datetime="2023-03-17T03:58:22.507Z" title="Updated 2023-03-17 11:58:22">2023-03-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>