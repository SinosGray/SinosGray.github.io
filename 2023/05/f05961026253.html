<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: 408 | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://sinos_wei.gitee.io/2023/05/f05961026253.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/24.jpeg">
<meta property="article:published_time" content="2023-05-15T06:13:57.000Z">
<meta property="article:modified_time" content="2023-09-05T16:31:11.896Z">
<meta property="article:author" content="Sinos">
<meta property="article:tag" content="frac">
<meta property="article:tag" content="int">
<meta property="article:tag" content="idx">
<meta property="article:tag" content="list">
<meta property="article:tag" content="index">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/24.jpeg"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="canonical" href="https://sinos_wei.gitee.io/2023/05/f05961026253.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: 408',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-06 00:31:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/24.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Sinos_wei's blog"><span class="site-name">Sinos_wei's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2023-09-05T16:31:11.896Z" title="Updated 2023-09-06 00:31:11">2023-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408/">408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>

</blockquote>
<span id="more"></span>
<h1 id="数据结构">数据结构</h1>
<h2 id="第1章绪论">第1章绪论</h2>
<h3 id="数据结构的基本概念">1.1 数据结构的基本概念</h3>
<h4 id="基本概念和术语">1.1.1 基本概念和术语</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD;</span><br><span class="line">    数据元素--基本单位--&gt;数据;</span><br><span class="line">    数据项--组成 最小单位 --&gt;数据元素;</span><br><span class="line">    数据元素--集合--&gt;数据对象;</span><br><span class="line">    数据对象--子集--&gt;数据;</span><br><span class="line">    值的集合--&gt;数据类型</span><br><span class="line">    此集合上的操作--&gt;数据类型</span><br><span class="line">    数据元素--特定关系组成的集合--&gt;数据结构</span><br></pre></td></tr></table></figure>
<h4 id="数据结构三要素">1.1.2 数据结构三要素</h4>
<p>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。</p>
<p>逻辑结构: 线性非线性</p>
<p>存储结构: 顺序存储, 链式存储, 索引存储, 散列存储</p>
<h3 id="算法和算法评价">1.2 算法和算法评价</h3>
<h4 id="算法的基本概念">1.2.1 算法的基本概念</h4>
<p>5 个特性: 有穷性, 确定性, 可行性, 输入, 输出</p>
<h4 id="算法效率的度量">1.2.2 算法效率的度量</h4>
<h2 id="第2章-.线性表">第2章 .线性表</h2>
<h3 id="线性表的定义和基本操作">2.1 线性表的定义和基本操作</h3>
<p>查找: 区分按值查找, 按序号查找</p>
<h4 id="线性表的定义">2.1.1 线性表的定义</h4>
<p>定义: 具有相同数据类型的有限序列, 逻辑上有先后次序, 是一种逻辑结构</p>
<h4 id="线性表的基本操作">2.1.2 线性表的基本操作</h4>
<h3 id="线性表的顺序表示">2.2 线性表的顺序表示</h3>
<h4 id="顺序表的定义">2.2.1 顺序表的定义</h4>
<p>定义: 线性表达的顺序存储</p>
<p>特点: 随机访问, 增删需要移动元素</p>
<h4 id="顺序表上基本操作的实现">2.2.2顺序表上基本操作的实现</h4>
<h3 id="线性表的链式表示">2.3 线性表的链式表示</h3>
<h4 id="单链表的定义">2.3.1 单链表的定义</h4>
<p>非随机存取</p>
<p>可以设置头结点, 数据为空, 好处: 统一了第一个位置上的操作, 统一了空与非空的操作</p>
<h4 id="单链表上基本操作的实现">2.3.2 单链表上基本操作的实现</h4>
<h4 id="双链表">2.3.3 双链表</h4>
<h4 id="循环链表">2.3.4 循环链表</h4>
<h4 id="静态链表">2.3.5 静态链表</h4>
<p>用数组描述线性表的链式存储结构, 此时的指针是结点的相对地址(数组下标)</p>
<figure>
<img src="https://p.ipic.vip/ku6a99.png" alt="截屏2023-05-15 15.53.17" /><figcaption aria-hidden="true">截屏2023-05-15 15.53.17</figcaption>
</figure>
<h4 id="顺序表和链表的比较">2.3.6 顺序表和链表的比较</h4>
<h2 id="第3章栈队列和数组">第3章栈、队列和数组</h2>
<h3 id="栈">3.1 栈</h3>
<h4 id="栈的基本概念">3.1.1 栈的基本概念</h4>
<p>卡特兰数: n 个不同元素进栈, 出栈元素不同排列的个数为</p>
<p><span class="math display">\[\frac{1}{n-1}C^{n}_{2n}\]</span></p>
<h4 id="栈的顺序存储结构">3.1.2 栈的顺序存储结构</h4>
<p>共享栈</p>
<figure>
<img src="https://p.ipic.vip/w17dhp.png" alt="截屏2023-05-16 11.27.35" /><figcaption aria-hidden="true">截屏2023-05-16 11.27.35</figcaption>
</figure>
<h4 id="栈的链式存储结构">3.1.3 栈的链式存储结构</h4>
<h3 id="队列">3.2队列</h3>
<h4 id="队列的基本概念">3.2.1 队列的基本概念，</h4>
<p>front队头: 删除端</p>
<p>rear队尾: 插入端</p>
<h4 id="队列的顺序存储结构">3.2.2 队列的顺序存储结构</h4>
<p>循环队列</p>
<p>区分队空还是满: 一般牺牲一个单元来区分, 约定: 队头指针在队尾指针的下一位置作为队满的标志</p>
<h4 id="队列的链式存储结构">3.2.3 队列的链式存储结构</h4>
<h4 id="双端队列">3.2.4 双端队列</h4>
<h3 id="栈和队列的应用">3.3 栈和队列的应用</h3>
<h4 id="栈在括号匹配中的应用">3.3.1 栈在括号匹配中的应用</h4>
<h4 id="栈在表达式求值中的应用">3.3.2 栈在表达式求值中的应用</h4>
<h4 id="栈在递归中的应用">3.3.3 栈在递归中的应用</h4>
<h4 id="队列在层次遍历中的应用">3.3.4 队列在层次遍历中的应用</h4>
<p>用队列遍历二叉树</p>
<h4 id="队列在计算机系统中的应用">3.3.5 队列在计算机系统中的应用</h4>
<h3 id="数组和特殊矩阵">3.4 数组和特殊矩阵</h3>
<h4 id="数组的定义">3.4.1 数组的定义</h4>
<h4 id="数组的存储结构">3.4.2 数组的存储结构</h4>
<p>按行优先: 00 01 02...10 11 12...从左到右, 从上到下</p>
<p>按列优先 00 10 20 ... 01 11 21 ... 从上到下, 从左到右</p>
<h4 id="特殊矩阵的压缩存储">3.4.3 特殊矩阵的压缩存储</h4>
<p>对称矩阵 序号公式?</p>
<p>三角矩阵 +1 常数</p>
<p>对角矩阵(条带状)</p>
<h4 id="稀疏矩阵">3.4.4 稀疏矩阵</h4>
<p>三元组:(行标, 列表, 非零值)</p>
<p>十字链表法?</p>
<h2 id="第4章串">第4章串。</h2>
<h3 id="串的定义和实现">*4.1 串的定义和实现</h3>
<h4 id="串的定义">4.1.1 串的定义．</h4>
<h4 id="串的存储结构">4.1.2 串的存储结构</h4>
<h4 id="串的基本操作">4.1.3 串的基本操作</h4>
<h4 id="串的模式匹配.">4.2 串的模式匹配.</h4>
<h4 id="简单的模式匹配算法">4.2.1 简单的模式匹配算法</h4>
<h4 id="串的模式匹配算法-kmp-算法.">4.2.2 串的模式匹配算法-KMP 算法.</h4>
<p>右移位数 = 已匹配的字符数 - 对应的部分匹配值, 再将匹配值右移, 并以 -1 开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char:  | a | b | a | b | a | b | c | a |</span><br><span class="line">index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | </span><br><span class="line">value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 |</span><br><span class="line">the value means: The length of the longest proper prefix in the (sub)pattern that matches a proper suffix in the same (sub)pattern.</span><br><span class="line">That means we get to skip ahead </span><br><span class="line"></span><br><span class="line">partial_match_length - </span><br><span class="line">table[partial_match_length - 1] </span><br><span class="line"></span><br><span class="line">(or 5 - table[4] or 5 - 3 or 2) characters</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string src_str, string pattern_str)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> src_length = src_str.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> pattern_length = pattern_str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(pattern_length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; pattern_length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern_str[i] == pattern_str[now]) &#123;</span><br><span class="line">                now++;</span><br><span class="line">                next[i] = now;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now != <span class="number">0</span>) &#123;</span><br><span class="line">                now = next[now - <span class="number">1</span>]; <span class="comment">//根据之前的结果得到的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> src_index = <span class="number">0</span>, pattern_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (src_index &lt; src_length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src_str[src_index] == pattern_str[pattern_index]) &#123;</span><br><span class="line">                src_index++;</span><br><span class="line">                pattern_index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern_index != <span class="number">0</span>) &#123;</span><br><span class="line">                pattern_index = next[pattern_index - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                src_index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pattern_index == pattern_length)</span><br><span class="line">                <span class="keyword">return</span> src_index - pattern_index ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="kmp-算法的进一步优化">4.2.3 KMP 算法的进一步优化</h4>
<h2 id="第5章-树与二叉树">第5章 树与二叉树</h2>
<h3 id="树的基本概念">5.1 树的基本概念</h3>
<h4 id="树的定义">5.1.1 树的定义</h4>
<h4 id="基本术语">5.1.2 基本术语</h4>
<p>结点的度: 一个结点孩子的度数</p>
<p>数的度: 树中结点的最大度数</p>
<p>度&gt;0 为分支结点, 度=0 为叶结点</p>
<p>结点的深度: 根结点深度为 1, 从根结点到叶结点累加</p>
<p>结点的高度: 从叶结点到根结点累加</p>
<p>树的高度: 树的最大层数</p>
<p>路径长度: 路径上经过的<strong>边</strong>的个数</p>
<h4 id="树的性质">5.1.3 树的性质</h4>
<p><strong><span class="math display">\[树的结点数 =\sum{结点度数} +1\]</span></strong></p>
<p>度为 m 的树第 i 层上至多有 <span class="math display">\[m^{i-1}\]</span>个结点</p>
<p>高度为 h 的 m 叉树至多有<span class="math display">\[\frac{(m^{h}-1)}{m-1}\]</span>个结点(<span class="math display">\[S=m^{h-1}+m^{h-2}+...+m+1\]</span>)</p>
<p>具有n 个结点的 m 叉树的最小高度为<span class="math display">\[\lceil log_m(n(m-1)+1) \rceil\]</span> (取自前一结论)</p>
<h3 id="二叉树的概念">5.2 二叉树的概念</h3>
<h4 id="二叉树的定义及其主要特性">5.2.1 二叉树的定义及其主要特性</h4>
<p><strong>满二叉树: 满的二叉树</strong></p>
<p><strong>完全二叉树: 满二叉树删去"倒数的几个节点"</strong></p>
<p><strong>二叉排序树: 左子树小于根节点, 右子树大于根节点, 子树同上</strong></p>
<p><strong>平衡二叉树: 树上任意节点的左右子树深度之差&lt;=1</strong></p>
<p>二叉树的性质</p>
<ul>
<li><span class="math display">\[n_0 = n_2 +1\]</span></li>
<li>完全二叉树从上到下, 从左到右, 从 1 到 n, 对于节点 i
<ul>
<li><span class="math display">\[parent = \lfloor\frac i 2\rfloor\]</span></li>
<li><span class="math display">\[leftchild = 2i\]</span> <span class="math display">\[rightchild = 2i+1\]</span></li>
<li><span class="math display">\[depth = \lfloor log_2 i +1 \rfloor\]</span></li>
</ul></li>
</ul>
<h4 id="二叉树的存储结构">5.2.2 二叉树的存储结构</h4>
<h3 id="二叉树的遍历和线索二叉树">5.3 二叉树的遍历和线索二叉树</h3>
<h4 id="二叉树的遍历">5.3.1 二叉树的遍历</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">value_t</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiTree</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    BiTree* lchild;</span><br><span class="line">    BiTree* rchild;</span><br><span class="line">    <span class="type">value_t</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTree* pt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderRecur</span><span class="params">(BiTree* p_bitree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_bitree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(p_bitree);</span><br><span class="line">        <span class="built_in">PreOrderRecur</span>(p_bitree-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderRecur</span>(p_bitree-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderIt</span><span class="params">(BiTree* p_bitree)</span> </span>&#123;</span><br><span class="line">    BiTree* p = p_bitree;</span><br><span class="line">    stack&lt;BiTree*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (!p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p);</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderRecur</span><span class="params">(BiTree* p_bitree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_bitree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InOrderRecur</span>(p_bitree-&gt;lchild);</span><br><span class="line">        <span class="built_in">visit</span>(p_bitree);</span><br><span class="line">        <span class="built_in">InOrderRecur</span>(p_bitree-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderIt</span><span class="params">(BiTree* p_bitree)</span> </span>&#123;</span><br><span class="line">    BiTree* p = p_bitree;</span><br><span class="line">    stack&lt;BiTree*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (!p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">visit</span>(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderRecur</span><span class="params">(BiTree* p_bitree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_bitree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostOrderRecur</span>(p_bitree-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderRecur</span>(p_bitree-&gt;rchild);</span><br><span class="line">        <span class="built_in">visit</span>(p_bitree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderIt</span><span class="params">(BiTree* p_bitree)</span> </span>&#123;</span><br><span class="line">    BiTree* p = p_bitree;</span><br><span class="line">    BiTree* recent_visited = <span class="literal">nullptr</span>;</span><br><span class="line">    stack&lt;BiTree*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (!p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != recent_visited) &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">visit</span>(p);</span><br><span class="line">                recent_visited = p;</span><br><span class="line">                p = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree* p_bitree)</span> </span>&#123;</span><br><span class="line">    BiTree* p = p_bitree;</span><br><span class="line">    queue&lt;BiTree*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        p = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据遍历结果构造二叉树</p>
<h4 id="线索二叉树">5.3.2 线索二叉树 ???</h4>
<p>规定: 若无左子树, lchild 指向前驱节点, 若无右子树, rchild 指向后继节点, ltag=1 代表前驱, rtag=1 代表后继</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadBiTree</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ThreadBiTree* lchild;</span><br><span class="line">    ThreadBiTree* rchild;</span><br><span class="line">    <span class="type">bool</span> ltag;</span><br><span class="line">    <span class="type">bool</span> rtag;</span><br><span class="line">    <span class="type">value_t</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadBiTree* p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadBiTree* p, ThreadBiTree* pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadBiTree* t)</span> </span>&#123;</span><br><span class="line">    ThreadBiTree* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(t, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadBiTree* <span class="title">FirstNode</span><span class="params">(ThreadBiTree* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;ltag == <span class="literal">false</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadBiTree* <span class="title">NextNode</span><span class="params">(ThreadBiTree* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThread</span><span class="params">(ThreadBiTree* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadBiTree* p = <span class="built_in">FirstNode</span>(t); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树森林">5.4 树、森林</h3>
<h4 id="树的存储结构">5.4.1 树的存储结构</h4>
<p>双亲表示法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="type">int</span> parent</span><br><span class="line">&#125; OTNode;</span><br><span class="line"><span class="comment">//root&#x27;s parent = -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  PNTNode nodes[MAX_SIZE];</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<p>孩子表示法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─┬─┐    ┌─┐     ┌─┐        </span><br><span class="line">│0│R│───▶│1│────▶│2│        </span><br><span class="line">│1│A│    └─┘     └─┘        </span><br><span class="line">│2│B│                       </span><br><span class="line">│3│C│    ┌─┐                </span><br><span class="line">│4│D│───▶│6│                </span><br><span class="line">│5│E│    └─┘                </span><br><span class="line">│6│F│                       </span><br><span class="line">├───┼                                              </span><br></pre></td></tr></table></figure>
<p>孩子兄弟表示法(二叉树表示法)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CSNode</span> * firstchild, *nextsibling;</span><br><span class="line">&#125; CSNode, *CSTree;</span><br><span class="line"><span class="comment">//nextsibling 是本节点的兄弟节点的指针</span></span><br></pre></td></tr></table></figure>
<h4 id="树森林与二叉树的转换">5.4.2 树、森林与二叉树的转换</h4>
<p>树-&gt;二叉树(唯一)</p>
<p>每个节点左指针指向第一个孩子, 右指针指向本节点相邻的右兄弟(左孩子右兄弟)</p>
<p>森林-&gt;二叉树(唯一)</p>
<p>现将每棵树转换为二叉树, 将树的根节点彼此视为兄弟连接到右指针上(从树-&gt;二叉树时, 根节点的右必为空)</p>
<h4 id="树和森林的遍历">5.4.3 树和森林的遍历</h4>
<p>树遍历</p>
<ul>
<li>先根遍历, 先访问根节点,再访问每棵子树, 类似对应二叉树的先序遍历</li>
<li>后根遍历, 先遍历子树再访问根节点, 类似对应二叉树的中序遍历</li>
</ul>
<p>森林遍历</p>
<ul>
<li>先序遍历, 先访问根节点,再访问每棵子树, 类似对应二叉树的先序遍历</li>
<li>中序遍历(也叫后序遍历), 先遍历子树再访问根节点, 类似对应二叉树的中序遍历</li>
</ul>
<h3 id="树与二叉树的应用">5.5树与二叉树的应用</h3>
<h4 id="哈夫曼树和哈夫曼编码">5.5.1 哈夫曼树和哈夫曼编码</h4>
<p>带权路径长度</p>
<p><span class="math display">\[WPL = \sum_{i=1}^{n}{w_il_i}\]</span></p>
<p><span class="math inline">\(w_i\)</span>为第 i 叶节点的权值, <span class="math inline">\(l_i\)</span>为该叶节点到根节点的路径长度</p>
<p>WPL 最小的二叉树成为哈夫曼树(最优二叉树)</p>
<p>构造哈夫曼树</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/%E6%88%AA%E5%B1%8F2023-05-22%2014.23.47.png?token=AKM4PTZAEANKSBPJ7WAGESDEOLW5E" alt="截屏2023-05-22 14.23.47" /><figcaption aria-hidden="true">截屏2023-05-22 14.23.47</figcaption>
</figure>
<p>哈夫曼编码是一种可变长度编码, 使用频率越高长度越短</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/%E6%88%AA%E5%B1%8F2023-05-22%2014.25.26.png?token=AKM4PT2AQBDF563DDVXKBELEOLW6Q" alt="截屏2023-05-22 14.25.26" /><figcaption aria-hidden="true">截屏2023-05-22 14.25.26</figcaption>
</figure>
<p>哈夫曼树不一定唯一(左右子树是 0 或 1 不规定; 有相同权值的节点. 但所有哈夫曼树最后的 WPL 是相同的)</p>
<h4 id="并查集">5.5.2. 并查集???</h4>
<h6 id="并查集是一种简单的集合表示">并查集是一种简单的集合表示</h6>
<h2 id="第6章图">第6章图</h2>
<h3 id="图的基本概念">6.1 图的基本概念</h3>
<h4 id="图的定义">6.1.1 图的定义</h4>
<p>简单图: 如果图满足: 不存在重复边, 不存在顶点到自身的边</p>
<p>完全图: 每两个顶点之间都存在边(有向图则需要两条边) <span class="math inline">\(E = \frac{n(n-1)}{2}\)</span></p>
<p>子图: 顶点和边都是子集</p>
<p>生成子图: 顶点相同, 边是子集</p>
<p>连通图: 无向图中任意顶点都是连通的, 无向图中的极大连通子图称为连通分量</p>
<p>强连通图: 有向图中任意中任意顶点都是连通的, 有向图中的极大强连通子图称为连通分量</p>
<p>生成树: 连通图的生成树是包含全部顶点的一个极小连通子图, 对生成树而言, 去掉一条边就会变成非连通图, 加上一条边就会出现回路</p>
<p>生成森林: 非连通图中连通分量的生成树构成了飞连通图的生成森林</p>
<p>带权图又称网</p>
<p>稀疏图稠密图: 当满足<span class="math inline">\(|E|&lt;|V|log|V|\)</span> 可视为稀疏图</p>
<p>路径长度: 路径上边的个数</p>
<p>简单路径: 顶点不重复出现的路径</p>
<p>距离: 最短路径的长度</p>
<p>有向树: 一个顶点入度=0, 其余顶点入度=1 的有向图称为有向树</p>
<h3 id="图的存储及基本操作">6.2 图的存储及基本操作</h3>
<h4 id="邻接矩阵法">6.2.1 邻接矩阵法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VertexType vex[MaxVertexNum];</span><br><span class="line">    EdgeType edge[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure>
<p>适用于稠密图</p>
<p>无向图只需存储三角矩阵的元素</p>
<p><span class="math inline">\(A^n\)</span>的元素<span class="math inline">\(A^n[i][j]\)</span>等于从 i 到 j 顶点长度为 n 的路径的数量</p>
<p>难以数出边的数量</p>
<h4 id="邻接表法">6.2.2 邻接表法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span>* next;</span><br><span class="line">    <span class="comment">// EdgeType weight</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode* first;</span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure>
<p>无向图的存储中会有重复</p>
<p>难以判断两顶点之间是否存在边</p>
<p>有向图存储的是出度边, 难以数出入度</p>
<p>邻接表不唯一</p>
<h4 id="十字链表有向图">6.2.3 十字链表(有向图)</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> tailvex;<span class="comment">//弧头顶点编号</span></span><br><span class="line">  <span class="type">int</span> headvex;<span class="comment">//弧尾顶点编号</span></span><br><span class="line">  ArcNode* hlink;<span class="comment">//弧头相同的下一个弧节点</span></span><br><span class="line">  ArcNode* tlink;<span class="comment">//弧尾相同的下一个弧节点</span></span><br><span class="line">  Data info;</span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VexNode</span>&#123;</span><br><span class="line">  Data data;</span><br><span class="line">  ArcNode* firstin;<span class="comment">//以本顶点为弧头的第一个弧</span></span><br><span class="line">  ArcNode* firstout;<span class="comment">//以本顶点为弧尾的第一个弧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接多重表无向图">6.2.4 邻接多重表(无向图)</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> ivex;<span class="comment">//顶点编号</span></span><br><span class="line">  <span class="type">int</span> jvex;<span class="comment">//顶点编号</span></span><br><span class="line">  ArcNode* ilink;<span class="comment">//ivex相同的下一个弧节点</span></span><br><span class="line">  ArcNode* jlink;<span class="comment">//jvex相同的下一个弧节点</span></span><br><span class="line">  Data info;</span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VexNode</span>&#123;</span><br><span class="line">  Data data;</span><br><span class="line">  ArcNode* firstedge<span class="comment">//第一条边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图的基本操作">6.2.5 图的基本操作</h4>
<h3 id="图的遍历">6.3 图的遍历</h3>
<p>访问每一个顶点</p>
<h4 id="广度优先搜索-bfs">6.3.1 广度优先搜索 BFS</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(MAX, <span class="literal">false</span>)</span></span>;</span><br><span class="line">queue&lt;DataType&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph g, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        v = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w = <span class="built_in">FirstNeighbor</span>(g, v); w&gt;=<span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(g, v, w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            <span class="built_in">visit</span>(w);</span><br><span class="line">            visited[w] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;g; i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            <span class="built_in">BFS</span>(g, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: S(V)</p>
<p>邻接表时间复杂度: O(V+E)</p>
<p>邻接矩阵时间复杂度: O(V<sup>2</sup>)</p>
<p>BFS求单源最短路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Distance 10e9</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSminDistance</span><span class="params">(Graph g, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(max_vex_count, Max_Distance)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(max_vex_count, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    distance[u] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w = <span class="built_in">FirstNeighbor</span>(g, u); w&gt;=<span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(g, u, w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            visited[w] = <span class="literal">true</span>;</span><br><span class="line">            distance[w] = distance[u] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广度生成树</p>
<h4 id="深度优先搜索-dfs">6.3.2 深度优先搜索 DFS</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(MAX, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph g, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstNeighbor</span>(g, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(g, v, w))</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(g, w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g; i++)</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            <span class="built_in">DFS</span>(g, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: S(V) 运行栈</p>
<p>邻接表时间复杂度: O(V+E)</p>
<p>邻接矩阵时间复杂度: O(V<sup>2</sup>)</p>
<h4 id="图的遍历与图的连通性">6.3.3 图的遍历与图的连通性</h4>
<p>对于无向图, 以上两种遍历方法调用 BFS(DFS)函数的次数 = 图的连通分量数</p>
<h3 id="图的应用">6.4 图的应用</h3>
<h4 id="最小生成树">6.4.1 最小生成树</h4>
<p>边的权值之和最小的生成树称为最小生成树</p>
<p>当各边权值不相等时, 最小生成树唯一, 树的最小生成树是自己本身</p>
<p>最小生成树的边数=顶点数-1</p>
<ul>
<li><p>通用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_min_generate_tree(g)</span><br><span class="line">	tree = null</span><br><span class="line">	while tree isnot generate_tree</span><br><span class="line">		do:</span><br><span class="line">			找到一条权重最小边(u, v),</span><br><span class="line">      并且加入 tree 后无回路</span><br><span class="line">			tree = tree+(u, v)</span><br></pre></td></tr></table></figure></li>
<li><p>Prim 算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prim(g, tree)</span><br><span class="line">	tree = null</span><br><span class="line">	V_tree = &#123;w&#125; # any vertex as w</span><br><span class="line">	while V-V_tree != null:</span><br><span class="line">		find (u, v)where:</span><br><span class="line">      u isin V_tree, </span><br><span class="line">      v isin V-V_tree, </span><br><span class="line">      and (u, v) is min</span><br><span class="line">		Tree = Tree + (u, v)</span><br><span class="line">		V_tree = V_tree + v</span><br></pre></td></tr></table></figure>
<p>O(V<sup>2</sup>)</p></li>
<li><p>Kruskal 算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kruskal(V, tree)</span><br><span class="line">	tree = V</span><br><span class="line">	# connected component 连通分量</span><br><span class="line">	connect_cp_count = n</span><br><span class="line">	while connect_cp &gt; 1:</span><br><span class="line">		find min(u, v) in E</span><br><span class="line">		if u, v isin different conncted component:</span><br><span class="line">			tree = tree + (u, v)</span><br><span class="line">			connect_cp_count--</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="最短路径">6.4.2 最短路径</h4>
<h5 id="dijkstra-算法-单源">dijkstra 算法 单源</h5>
<p>邻接矩阵时间复杂度: O(V<sup>2</sup>)</p>
<p>邻接表时间复杂度: O(V<sup>2</sup>)</p>
<p>有边权值为负时, 不适用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">    <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj_matrix, <span class="type">int</span> vertex_cnt, <span class="type">int</span> src_vertex)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> inf = INT_MAX / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(vertex_cnt, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vertex_cnt, inf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : adj_matrix) &#123;</span><br><span class="line">            <span class="type">int</span> x = t[<span class="number">0</span>] - <span class="number">1</span>, y = t[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            g[x][y] = t[<span class="number">2</span>];</span><br><span class="line">        &#125; <span class="comment">// 邻接表转换到邻接矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(vertex_cnt, inf)</span></span>;</span><br><span class="line">        dist[src_vertex - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(vertex_cnt, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_cnt; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; vertex_cnt; ++y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[y] &amp;&amp; (x == <span class="number">-1</span> || dist[y] &lt; dist[x])) &#123;</span><br><span class="line">                    x = y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            used[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; vertex_cnt; ++y) &#123;</span><br><span class="line">                dist[y] = <span class="built_in">min</span>(dist[y], dist[x] + g[x][y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = *<span class="built_in">max_element</span>(dist.<span class="built_in">begin</span>(), dist.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans == inf ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="floyd-算法-多源">floyd 算法 多源</h5>
<p><span class="math inline">\(A^k[i][j] = Min\{A^{k-1}[i][j], A^{k-1}[i][k] + A^{k-1}[k][j]\}\)</span></p>
<p>循环 n 次(n 为顶点数)</p>
<h4 id="有向无环图描述表达式">6.4.3 有向无环图描述表达式</h4>
<p>有向无环图 DAG (Directed Acyclic Graph)</p>
<h4 id="拓扑排序">6.4.4 拓扑排序</h4>
<p>AOV 网(Activity on Vertex Network) 有向边&lt;V<sub>i</sub>, V<sub>j</sub>&gt;表示 i 活动优先于 j 活动</p>
<p>拓扑排序: 在有向无环图中, 每个顶点之出现一次, A 在 B 前则不存在从 B 到 A 的路径 步骤:</p>
<ul>
<li>从 AOV 中选择一个没有前驱的顶点并输出</li>
<li>删除该顶点和所有以它为起点的有向边</li>
<li>重复 1, 2 直到 AOV 为空</li>
</ul>
<p>邻接表时间复杂度: O(V+E)</p>
<p>邻接矩阵时间复杂度: O(V<sup>2</sup>)</p>
<h4 id="关键路径">6.4.5 关键路径</h4>
<p>AOE 网(Activity On Edge Network), 顶点表示事件, 边表示活动, 边上的权值表示活动开销</p>
<p>AOE 网只有一个入度=0 的点, 一个出度=0 的点</p>
<p>AOE 网中的最长路径为关键路径, 关键路径上的点叫做关键活动</p>
<ul>
<li>事件 v<sub>k</sub>的最早发生时间 ve(k) ve(源点) = 0 <span class="math inline">\(ve(k) = Max\{ ve(j)+Weight(v_j, v_k) \}\)</span> 其中 k 为 j 的任意后继 计算 ve 从源点开始从前向后</li>
<li>事件 v<sub>k</sub>的最迟发生时间 vl(k) vl(汇点) = ve(汇点) <span class="math inline">\(vl(k) = Min\{ vl(j)-Weight(v_k, v_j) \}\)</span> 其中 k 为 j 的任意前驱 计算 ve 从汇点开始从后向前</li>
<li>活动 a<sub>i</sub>最早开始时间 e(i) = ve(k), 其中&lt;v<sub>k</sub>, v<sub>j</sub>&gt;表示活动 a<sub>i</sub></li>
<li>活动 a<sub>i</sub>最迟开始时间 l(i) = vl(j) - Weight(v<sub>k</sub>, v<sub>j</sub>), 其中&lt;v<sub>k</sub>, v<sub>j</sub>&gt;表示活动 a<sub>i</sub></li>
<li>活动 a<sub>i</sub>最早开始时间与最迟开始时间差额 d(i) = l(i) - e(i), 即时间余量</li>
</ul>
<p>算法:</p>
<ol type="1">
<li>从源点除法算 ve</li>
<li>从汇点出发算 vl</li>
<li>根据 ve 求 e</li>
<li>根据 vl 求 l</li>
<li>根据e, l 求 d, 所有 d=0 的活动构成关键路径</li>
</ol>
<h2 id="第7章-查找">第7章 查找</h2>
<h3 id="查找的基本概念">7.1 查找的基本概念</h3>
<p>平均查找长度 <span class="math inline">\(ASL = \sum^n_{i=1}P_iC_i\)</span></p>
<p>P<sub>i</sub>为查找概率, 一般认为是 1/n, C<sub>i</sub>是需要进行比较的次数</p>
<h3 id="顺序查找和折半查找">7.2 顺序查找和折半查找</h3>
<h4 id="顺序查找">7.2.1 顺序查找</h4>
<p>利用哨兵减少判断语句</p>
<ol type="1">
<li><p>一般线性表: 遍历</p>
<p><span class="math inline">\(ASL_{success} = \sum^n_{i=1}\frac1n(n-i+1) = \frac{n+1}2\)</span></p>
<p><span class="math inline">\(ASL_{failed} = n+1\)</span></p></li>
<li><p>有序表顺序查找</p>
<p>判定树</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/%E6%88%AA%E5%B1%8F2023-05-26%2009.50.09.png?token=AKM4PTZQNKPYVHJUOZKW3NDEOLW7I" alt="截屏2023-05-26 09.50.09" /><figcaption aria-hidden="true">截屏2023-05-26 09.50.09</figcaption>
</figure>
<p><span class="math inline">\(ASL_{success} = \sum^n_{i=1}\frac1n(n-i+1) = \frac{n+1}2\)</span></p>
<p><span class="math inline">\(ASL_{failed} = \sum^n_{i=1}q_i(l_i-1) = \frac{1+2+...+n+n}{n+1} = \frac n2 + \frac n{n+1}\)</span></p>
<p>q<sub>i</sub>为失败概率, l<sub>i</sub>为节点层数</p></li>
</ol>
<h4 id="折半查找-二分查找-有限顺序表">7.2.2 折半查找 (二分查找, 有限顺序表)</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elemtype;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;elemtype&gt; vec, elemtype key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = vec.<span class="built_in">size</span>(), mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">at</span>(mid) == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vec.<span class="built_in">at</span>(mid) &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判定树(平衡二叉树)</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/%E6%88%AA%E5%B1%8F2023-05-26%2013.03.34.png" alt="截屏2023-05-26 13.03.34" /><figcaption aria-hidden="true">截屏2023-05-26 13.03.34</figcaption>
</figure>
<p>$ASL_{success} = 1n ^n_{i=1}l_i $</p>
<p>$= 1n(1<em>1+2</em>2+4<em>3+...+h</em>2^{h-1}) $</p>
<p>$= n log_2(n+1) - 1 $</p>
<p><span class="math inline">\(\approx log_2(n+1) -1\)</span></p>
<p>查找成功, 次数为层数;</p>
<p>查找失败, 次数为叶节点层数+1(两种情况, 如 6, 9 分别对应 3, 4 次比较)</p>
<h4 id="分块查找">7.2.3 分块查找</h4>
<p>将顺序表通过取关键字切分为多个块, 块之间有序, 块内无序</p>
<p><span class="math inline">\(ASL = L_I + L_S = \frac{b+1}2 + \frac{s+1}2 = \frac {s^2+bs+2s}{2s} = \frac{s^2 + n + 2s}{2s}\)</span></p>
<p>当 <span class="math inline">\(s = \sqrt n\)</span> 时有最小值 <span class="math inline">\(\sqrt{n+1}\)</span></p>
<h3 id="树型查找">7.3 树型查找</h3>
<h4 id="二叉排序树-bst-搜索树-查找树">7.3.1 二叉排序树 (BST) (搜索树, 查找树)</h4>
<p>提高增删改查速度</p>
<p>定义: <strong>左子树上所有结点 &lt; 根节点, 右子树上所有结点 &gt; 根节点</strong>, 左右子树也是二叉排序树</p>
<p>对其进行中序遍历可以得到一个递增的有序序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">BSTSearch</span><span class="params">(node* root, elemtype key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> &amp;&amp; key != root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root-&gt;data)</span><br><span class="line">            root = root-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = root-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">elemtype <span class="title">BSTInsert</span><span class="params">(node* root, elemtype data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">        root-&gt;data = data;</span><br><span class="line">        root-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSTInsert</span>(root-&gt;lchild, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSTInsert</span>(root, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBST</span><span class="params">(node* root, elemtype datas[], <span class="type">int</span> data_length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; data_length) &#123;</span><br><span class="line">        <span class="built_in">BSTInsert</span>(root, datas[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除: 左子树或者右子树为空: 用另一个子树替代</p>
<p>左右子树均不为空: 令要删除的节点的直接后继(直接前驱)(中序)替代, 删除该后继, 之后重复</p>
<p><span class="math inline">\(ASL = O(log_2n)\)</span></p>
<p>当使用有序序列构造时获得最差情况单枝树, ASL = O(n)</p>
<h4 id="平衡二叉树-avl-树adelson-velsky-and-landis-tree">7.3.2 平衡二叉树 AVL 树(Adelson-Velsky and Landis Tree)</h4>
<p>定义: <strong>任意节点左右子树高度差 &lt;= 1</strong></p>
<p>平衡二叉树插入: 插入节点后调整平衡</p>
<ol type="1">
<li>LL A 的左子树的左子树上插入 <img src="https://gitee.com/sinos_wei/picgo/raw/master/%E6%88%AA%E5%B1%8F2023-05-26%2013.45.18.png" alt="截屏2023-05-26 13.45.18" /></li>
<li>RR 同上</li>
<li>LR A 的左子树的右子树上插入 <img src="https://gitee.com/sinos_wei/picgo/raw/master/%E6%88%AA%E5%B1%8F2023-05-26%2013.46.16.png" alt="截屏2023-05-26 13.46.16" /></li>
<li>RL 同上</li>
</ol>
<p>平衡二叉树删除: 删除后调整, 从叶到根层层调整(可能调整多次)</p>
<h4 id="红黑树">7.3.3 红黑树</h4>
<p>定义:</p>
<ol type="1">
<li>每个节点是红或黑, 根节点和叶节点为黑(空节点被视为叶节点)</li>
<li><strong>不存在相邻红节点</strong></li>
<li><strong>对每个节点, 从该节点到任意叶节点的简单路径上的黑节点数量相同, 其数量叫做黑高 bh, 根节点的黑高为树的黑高</strong></li>
</ol>
<p>红黑树的插入</p>
<ol type="1">
<li>按照二叉排序树方法插入节点z, 并着红色, 如果父节点是黑色则插入完毕</li>
<li>如果z 是根节点, 着黑色, 插入完毕</li>
<li>如果 z 父节点是红色, 类似平衡二叉树
<ol type="1">
<li>z 叔节点 y 是黑色, z 是右孩子 LR</li>
<li>z 叔节点 y 是黑色, z 是左孩子 LL</li>
<li>z 父节点和叔节点都红 将父节点和叔节点变黑, 爷节点变红, 将爷节点视为插入节点, 重复</li>
</ol></li>
</ol>
<p>红黑树的删除 ?</p>
<ol type="1">
<li>按二叉排序树方法删除</li>
<li>删除节点如果只有左或右子树, 直接删除并变色</li>
<li>删除节点为红且没有孩子, 直接删除</li>
<li>删除节点y为黑且没有孩子, 寻找空节点 x 替代, 视 x 为双重黑节点
<ol type="1">
<li>x 的兄弟节点 w 为红, 对 w 做 L(左旋) 操作, 转换到情况 2, 3, 4</li>
<li>x 兄弟节点 w 为黑, w 右孩子为红 RR, 对 w L</li>
<li>x 兄弟节点 w 为黑, w 左孩子为红, 右孩子为黑, 对 w R, 回到情况 2</li>
<li>x 兄弟节点w 为黑, w 左右孩子都为黑, 将 w 变红, x.p 变黑</li>
</ol></li>
</ol>
<h3 id="b树和b树">7.4 B树和B+树</h3>
<h4 id="b树及其基本操作">7.4.1 B树及其基本操作</h4>
<p><strong>m 阶 B 树为所有结点平衡因子都为 0 的 m 路平衡查找树</strong></p>
<p>定义:</p>
<ol type="1">
<li><p>每个节点至多有 m 棵子树,</p></li>
<li><p>若根节点不是叶节点, 则至少有两棵子树(指针数=关键字数+1)</p></li>
<li><p>除根节点外所有非叶节点至少有<span class="math inline">\(\lceil \frac m2 \rceil\)</span>棵子树</p></li>
<li><p>非叶节点结构如下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──────────────────────────┐ </span><br><span class="line">│n p0 k1 p1 k2 p2 ... kn pn│ </span><br><span class="line">└──────────────────────────┘ </span><br><span class="line">k 为关键字(已升序排序), p 为子树指针, n 为关键字数量</span><br></pre></td></tr></table></figure></p></li>
<li><p>所有叶节点在同一层且不带信息</p></li>
</ol>
<figure>
<img src="https://gitee.com/sinos_wei/picgo/raw/master/%E6%88%AA%E5%B1%8F2023-05-26%2015.51.26.png" alt="截屏2023-05-26 15.51.26" /><figcaption aria-hidden="true">截屏2023-05-26 15.51.26</figcaption>
</figure>
<p>B 树高度(不包含最后一层空指针(有无都可?))</p>
<ul>
<li><p>高度为 h 的有 n 个关键字的 m 阶 B 树:</p>
<p>​ $n(m-1)(1+m+m<sup>2+m</sup>3 + ... + m^{h-1}) = m^h-1 $</p></li>
<li><p>对于关键字数为 n 的 B 树, 最后一层空节点的个数为 n+1</p>
<p><span class="math inline">\(n+1\geq 2(\lceil \frac m2 \rceil)^{h-1}\)</span></p></li>
</ul>
<p>B 树插入关键字k</p>
<ol type="1">
<li>寻找倒数第一层非空节点(即寻找插入位置)</li>
<li>如果插入后关键字数&lt;m-1 直接插入, 否则对节点进行分裂</li>
<li>从中间位置(<span class="math inline">\(\lceil \frac m 2 \rceil\)</span>)分割, 左边保留在原结点, 右边进入新节点, 中间关键字进入父节点, 若父节点关键字超出, 重复此操作</li>
</ol>
<p>B 树删除关键字 k</p>
<ol type="1">
<li>对于不是最底层非叶结点的关键字, 可以用 k 的前驱(后继)k'替代 k, 直到 k'落入最底层非叶结点</li>
<li>在终端节点中: 若关键字个数&gt;=<span class="math inline">\(\lceil \frac m2 \rceil\)</span>, 可以直接撒谎从南湖</li>
<li>在终端节点中: 若关键字个数&lt;<span class="math inline">\(\lceil \frac m2 \rceil\)</span>, 且兄弟可借, 则调整父节点与兄弟节点</li>
<li>若兄弟不够借, 则删除后与兄弟节点合并, 此时父结点内关键字会减少, 重复此过程直到符合 b 树要求</li>
</ol>
<h4 id="b树的基本概念">7.4.2 B+树的基本概念</h4>
<ol type="1">
<li>每个节点至多有 m 棵子树,</li>
<li>除根节点外所有非叶节点至少有<span class="math inline">\(\lceil \frac m2 \rceil\)</span>棵子树</li>
<li>节点子树个数与关键字数相同</li>
<li><strong>所有叶节点包含全部关键字和指向其记录的指针, 叶节点中关键字排序, 相邻叶节点相互链接</strong></li>
<li>分支节点中仅包含它各个子节点中关键字的最大值及其指针</li>
</ol>
<figure>
<img src="https://gitee.com/sinos_wei/picgo/raw/master/%E6%88%AA%E5%B1%8F2023-05-26%2015.53.25.png" alt="截屏2023-05-26 15.53.25" /><figcaption aria-hidden="true">截屏2023-05-26 15.53.25</figcaption>
</figure>
<h3 id="散列表">7.5 散列表</h3>
<h4 id="散列表的基本概念">7.5.1 散列表的基本概念</h4>
<p>散列函数: <code>hash(key) = addr</code></p>
<p>散列表: 根据关键字直接进行访问的数据结构, 是一种直接映射</p>
<h4 id="散列函数的构造方法">7.5.2 散列函数的构造方法</h4>
<ol type="1">
<li><p>直接定址法</p>
<p><code>h(key) = a*key +b</code></p></li>
<li><p>除留余数法</p>
<p><code>h(key) = key%p</code></p></li>
<li><p>数字分析法</p>
<p>对关键字进行分析, 考察分布均匀程度</p></li>
<li><p>平方取中法</p>
<p>取关键字的中间几位作为散列地址</p></li>
</ol>
<h4 id="处理冲突的方法">7.5.3 处理冲突的方法</h4>
<ol type="1">
<li><p>开放定址法</p>
<p><span class="math inline">\(h_i = [h(key)+d_i]\%m\)</span></p>
<p>m为散列表长, d<sub>i</sub>为增量序列</p>
<p>注: 不能随便删除元素, 需要标记后定期维护</p>
<ol type="1">
<li>线性探测法: d<sub>i</sub> = 0, 1, 2 ... m-1 这样可能会争夺正常映射的散列表位置</li>
<li>平方探测法(二次探测法): <span class="math inline">\(d_i = 0^2, 1^2, (-1)^2, 2^2...k^2, (-k)^2\)</span> k&lt;=m/2, 散列表长度 m 必须是一个可以表示成 4k+3 (?)的素数(如此可以保证, 只要散列表中有一半空元素, 就一定能插入)</li>
<li>双散列法<span class="math inline">\(d_i = h_2(key)\)</span>: <span class="math inline">\(h_i=[h(key)+i*h_2(key)]\%m\)</span> i为冲突次数</li>
<li>伪随机序列法: d<sub>i</sub> = 伪随机序列</li>
</ol></li>
<li><p>拉链法: 存储在线性链表中</p></li>
</ol>
<h4 id="散列查找及性能分析">7.5.4 散列查找及性能分析</h4>
<p>装填因子 <span class="math inline">\(\alpha = \frac{表中记录数 n}{散列表长度 m}\)</span></p>
<h2 id="第8查-排序">第8查 排序</h2>
<h3 id="排序的基本概念">8.1 排序的基本概念</h3>
<h4 id="排序的定义">8.1.1 排序的定义</h4>
<h3 id="插入排序">8.2 插入排序</h3>
<h4 id="直接插入排序">8.2.1 直接插入排序</h4>
<blockquote>
<p>寻找第一个未排序的元素, 将未排序的元素插入已排序的前端序列</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(ElemType list[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> unsorted_index, sorted_index, find_insert;</span><br><span class="line">    ElemType guard;</span><br><span class="line">    <span class="keyword">for</span> (unsorted_index = <span class="number">1</span>; unsorted_index &lt; length; unsorted_index++) &#123;</span><br><span class="line">        sorted_index = unsorted_index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (list[unsorted_index] &lt; list[sorted_index]) &#123;</span><br><span class="line">            guard = list[unsorted_index];</span><br><span class="line">            <span class="keyword">for</span> (find_insert = sorted_index;</span><br><span class="line">                 find_insert &gt;= <span class="number">0</span> &amp;&amp; guard &lt; list[find_insert];</span><br><span class="line">                 find_insert--) &#123;</span><br><span class="line">                <span class="comment">//从后向前比较: 稳定</span></span><br><span class="line">                list[find_insert + <span class="number">1</span>] = list[find_insert];</span><br><span class="line">            &#125;</span><br><span class="line">            list[find_insert + <span class="number">1</span>] = guard;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: S(1)</p>
<p>时间复杂度: 最好(有序)O(n), 最坏(逆序)O(n<sup>2</sup>), 平均: 比较次数=移动次数=<span class="math inline">\(\frac{n^2}4\)</span></p>
<p>从后向前比较移动时: 稳定</p>
<h4 id="折半插入排序">8.2.2 折半插入排序</h4>
<blockquote>
<p>对有序序列进行二分查找</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HalfInsertSort</span><span class="params">(ElemType list[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> unsorted_index, sorted_index, low, high, mid, find_insert;</span><br><span class="line">    ElemType guard;</span><br><span class="line">    <span class="keyword">for</span> (unsorted_index = <span class="number">1</span>; unsorted_index &lt; length; unsorted_index++) &#123;</span><br><span class="line">        sorted_index = unsorted_index - <span class="number">1</span>;</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = sorted_index;</span><br><span class="line">        guard = list[unsorted_index];</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (list[mid] &gt; guard)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// list[high]&lt;=guard&lt;list[high+1], 插入位置: high+1</span></span><br><span class="line">        <span class="keyword">for</span> (find_insert = sorted_index; find_insert &gt;= high + <span class="number">1</span>;</span><br><span class="line">             find_insert--) &#123;</span><br><span class="line">            list[find_insert + <span class="number">1</span>] = list[find_insert];</span><br><span class="line">        &#125;</span><br><span class="line">        list[find_insert + <span class="number">1</span>] = guard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间复杂度: 比较次数 = nlog<sub>2</sub>n, 移动次数 = n<sup>2</sup>/4</p>
<p>稳定</p>
<h4 id="希尔排序缩小增量排序">8.2.3 希尔排序(缩小增量排序)</h4>
<blockquote>
<p>以 gap 分组为 length/gap 个组, 每个组各自排序</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> list[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> gap, for_each_group, i;</span><br><span class="line">    <span class="keyword">for</span>(gap = length/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(for_each_group = gap; for_each_group &lt; length; for_each_group++)</span><br><span class="line">            <span class="keyword">for</span>(i = for_each_group - gap; i &gt;= <span class="number">0</span> &amp;&amp; list[i] &gt; list[i+gap]; i -= gap) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(list[i], list[i+gap]);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: 1</p>
<p>时间复杂度: 约为 n<sup>1.3</sup>, 最坏 n<sup>2</sup></p>
<p>不稳定</p>
<h3 id="交换排序">8.3 交换排序</h3>
<h4 id="冒泡排序">8.3.1 冒泡排序</h4>
<blockquote>
<p>每次排序将未排序序列中最大的元素移到未排序序列最后, 但是两两比较</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType list[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> for_each = <span class="number">0</span>; for_each &lt; length; for_each++) &#123;</span><br><span class="line">        <span class="type">int</span> sorted_index = length - for_each;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> unsorted_index = <span class="number">0</span>; unsorted_index &lt; sorted_index - <span class="number">1</span>;</span><br><span class="line">             unsorted_index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[unsorted_index] &gt; list[unsorted_index + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(list[unsorted_index], list[unsorted_index + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改进冒泡排序, 最好情况 O(n) = n-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType list[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> didSwap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> for_each = <span class="number">0</span>; for_each &lt; length; for_each++) &#123;</span><br><span class="line">        didSwap = <span class="literal">false</span>;<span class="comment">//如果在某次遍历发现没有交换说明已排序完</span></span><br><span class="line">        <span class="type">int</span> sorted_index = length - for_each;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> unsorted_index = <span class="number">0</span>; unsorted_index &lt; sorted_index - <span class="number">1</span>;</span><br><span class="line">             unsorted_index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[unsorted_index] &gt; list[unsorted_index + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(list[unsorted_index], list[unsorted_index + <span class="number">1</span>]);</span><br><span class="line">                didSwap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (didSwap == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: 1</p>
<p>时间复杂度: 最好(顺序) n-1. 最坏(逆序): 比较次数:<span class="math inline">\(\frac{n(n-1)}2\)</span>, 移动次数: <span class="math inline">\(\frac{3n(n-1)}2\)</span> (3是 swap 函数的时间复杂度)</p>
<p>稳定</p>
<h4 id="快速排序">8.3.2 快速排序</h4>
<blockquote>
<p>一次确定一个元素的位置, 保证确定的元素左右两边分别&gt;=和&lt;=</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(ElemType list[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    ElemType pivot = list[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; list[high] &gt;= pivot)</span><br><span class="line">            high--;</span><br><span class="line">        list[low] = list[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; list[low] &lt;= pivot)</span><br><span class="line">            low++;</span><br><span class="line">        list[high] = list[low];</span><br><span class="line">    &#125;</span><br><span class="line">    list[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(ElemType list[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivot_position = <span class="built_in">Partition</span>(list, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(list, low, pivot_position - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(list, pivot_position + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度(栈): 最好=平均=log<sub>2</sub>n, 最坏 = n</p>
<p>时间复杂度: 最坏:每次划分都在端点处 n<sup>2</sup>, 最好:每次划分都在中点 nlog<sub>2</sub>n, 平均nlog<sub>2</sub>n</p>
<p>不稳定</p>
<h3 id="选择排序">8.4 选择排序</h3>
<h4 id="简单选择排序">8.4.1 简单选择排序</h4>
<blockquote>
<p>从未排序序列中找到最小元素, 插入已排序元素之后</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElemType list[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> for_each = <span class="number">0</span>; for_each &lt; length - <span class="number">1</span>; for_each++) &#123;</span><br><span class="line">        <span class="type">int</span> min = for_each;</span><br><span class="line">        <span class="type">int</span> unsorted = for_each + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> find_min = unsorted; find_min &lt; length; find_min++)</span><br><span class="line">            <span class="keyword">if</span> (list[find_min] &lt; list[min])</span><br><span class="line">                min = find_min;</span><br><span class="line">        <span class="comment">// get min from unsorted to last</span></span><br><span class="line">        <span class="keyword">if</span> (min != for_each)</span><br><span class="line">            <span class="built_in">swap</span>(list[for_each], list[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: 1</p>
<p>时间复杂度: 比较: <span class="math inline">\(\frac{n(n-1)}2\)</span>, 移动最好 0 最坏 3 * (n-1), 总体n<sup>2</sup> (移动一次要三次操作)</p>
<p>不稳定</p>
<h4 id="堆排序">8.4.2 堆排序</h4>
<p>大根堆: <code>L(i)&gt;=L(2i) &amp;&amp; L(i)&gt;=L(2i+1)</code> 任意节点的值&lt;=父结点的值</p>
<p>小根堆: <code>L(i)&lt;=L(2i) &amp;&amp; L(i)&lt;=L(2i+1)</code></p>
<blockquote>

</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(ElemType list[], <span class="type">int</span> len, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * index;      <span class="comment">// index的左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * index + <span class="number">1</span>; <span class="comment">// index的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_idx = index;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; list[left] &gt; list[max_idx])</span><br><span class="line">        max_idx = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; list[right] &gt; list[max_idx])</span><br><span class="line">        max_idx = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_idx != index) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(list[max_idx], list[index]);</span><br><span class="line">        <span class="built_in">adjust</span>(list, len, max_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(ElemType list[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建大根堆（从最后一个非叶子节点向上）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">adjust</span>(list, size, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(list[<span class="number">0</span>], list[i]); <span class="comment">// 将当前最大的放置到数组末尾</span></span><br><span class="line">        <span class="built_in">adjust</span>(list, i, <span class="number">0</span>); <span class="comment">// 将未完成排序的部分继续进行堆排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: 1</p>
<p>时间复杂度: nlogn</p>
<p>不稳定</p>
<h3 id="归并排序和基数排序">8.5 归并排序和基数排序</h3>
<h4 id="归并排序">8.5.1 归并排序</h4>
<blockquote>
<p>小组排序, 合并成大组</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ElemType assist_array[<span class="number">100</span>]; <span class="comment">// length of list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType list[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low2mid_idx, mid2high_idx, list_idx;</span><br><span class="line">    <span class="keyword">for</span> (list_idx = low; list_idx &lt;= high; list_idx++)</span><br><span class="line">        assist_array[list_idx] = list[list_idx];</span><br><span class="line">    <span class="keyword">for</span> (low2mid_idx = low, mid2high_idx = mid + <span class="number">1</span>, list_idx = low;</span><br><span class="line">         low2mid_idx &lt;= mid &amp;&amp; mid2high_idx &lt;= high;</span><br><span class="line">         list_idx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (assist_array[low2mid_idx] &lt;= assist_array[mid2high_idx]) <span class="comment">//稳定排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            list[list_idx] = assist_array[low2mid_idx];</span><br><span class="line">            low2mid_idx++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list[list_idx] = assist_array[mid2high_idx];</span><br><span class="line">            mid2high_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low2mid_idx &lt;= mid)</span><br><span class="line">        list[list_idx++] = assist_array[low2mid_idx++];</span><br><span class="line">    <span class="keyword">while</span> (mid2high_idx &lt;= high)</span><br><span class="line">        list[list_idx++] = assist_array[mid2high_idx++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType list[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(list, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(list, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(list, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度: n</p>
<p>时间复杂度: nlog<sub>2</sub>n</p>
<p>稳定</p>
<h4 id="基数排序">8.5.2基数排序</h4>
<p>将关键字拆分为组(如个十百千万) , 每个组排序一次</p>
<p>空间复杂度: r, r 为每个组有多少个可能的值(例如 10)</p>
<p>时间复杂度: d*(n+r), d 是关键字的组数</p>
<p>稳定</p>
<h3 id="各种内部排序算法的比较及应用">8.6 各种内部排序算法的比较及应用</h3>
<h4 id="内部排序算法的比较">8.6.1 内部排序算法的比较</h4>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>最好时间</th>
<th>平均时间</th>
<th>最坏时间</th>
<th>空间</th>
<th>稳定</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>直接插入</td>
<td>n</td>
<td>n<sup>2</sup>/4</td>
<td>n<sup>2</sup></td>
<td>1</td>
<td>yes</td>
</tr>
<tr class="even">
<td>折半插入</td>
<td>n</td>
<td>n<sup>2</sup>/4<br />(nlog<sub>2</sub>n)</td>
<td>n<sup>2</sup></td>
<td>1</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>希尔</td>
<td>?</td>
<td>n<sup>1.3</sup></td>
<td>n<sup>2</sup></td>
<td>1</td>
<td>no</td>
</tr>
<tr class="even">
<td>冒泡</td>
<td>n-1</td>
<td>n<sup>2</sup></td>
<td>n(n-1)/2</td>
<td>1</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>快速</td>
<td>nlog<sub>2</sub>n</td>
<td>nlog<sub>2</sub>n</td>
<td>n<sup>2</sup></td>
<td>log<sub>2</sub>n<br />~n</td>
<td>no</td>
</tr>
<tr class="even">
<td>简单选择</td>
<td>n(n-1)/2</td>
<td>n(n-1)/2</td>
<td>n(n-1)/2</td>
<td>1</td>
<td>no</td>
</tr>
<tr class="odd">
<td>堆</td>
<td>nlog<sub>2</sub>n</td>
<td>nlog<sub>2</sub>n</td>
<td>nlog<sub>2</sub>n</td>
<td>1</td>
<td>no</td>
</tr>
<tr class="even">
<td>归并</td>
<td>nlog<sub>2</sub>n</td>
<td>nlog<sub>2</sub>n</td>
<td>nlog<sub>2</sub>n</td>
<td>n</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>基数</td>
<td>d*(n+r)</td>
<td>d*(n+r)</td>
<td>d*(n+r)</td>
<td>r</td>
<td>yes</td>
</tr>
</tbody>
</table>
<h4 id="内部排序算法的应用">8.6.2 内部排序算法的应用</h4>
<h3 id="外部排序">8.7 外部排序</h3>
<h4 id="外部排序的基本概念">8.7.1 外部排序的基本概念</h4>
<h4 id="外部排序的方法">8.7.2 外部排序的方法</h4>
<p>归并排序:</p>
<ol type="1">
<li>将外存文件分成多个文件, 将文件内部依次内部排序, 然后写入外存</li>
<li>对内部排序后的文件归并, 直到整个文件有序</li>
</ol>
<p>每一趟归并都需要读一遍所有数据, 写一遍所有数据</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot.png?token=AKM4PT2N6IA27EKNOBQQT2TEOMVD4" alt="screenshot" /><figcaption aria-hidden="true">screenshot</figcaption>
</figure>
<p>如图所示是三次归并</p>
<p><span class="math inline">\(外部排序总时间 = 内部排序所需时间+外存信息读写时间+内部归并所需时间\)</span></p>
<h4 id="多路平衡归并与败者树">8.7.3 多路平衡归并与败者树</h4>
<p>路数k增加时, 每趟归并需要进行的比较次数为<span class="math inline">\((n-1)(k-1)\)</span></p>
<p>总比较次数就为</p>
<p><span class="math inline">\(\lceil log_kr \rceil(n-1)(k-1) = \frac{\lceil log_2r \rceil(n-1)(k-1)}{log_2k}\)</span> n为元素个数, r 为初始分段段数, k 为归并路数, <span class="math inline">\(\lceil log_kr \rceil\)</span>为归并趟数, 可以得出, 当 k 增加时, 内部排序的时间会增加</p>
<p>败者树: 增加 k 不会增加内部排序比较次数</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5268930.png?token=AKM4PT4JK7FNV2QRFOIRDKDEOMVEM" alt="screenshot-5268930" /><figcaption aria-hidden="true">screenshot-5268930</figcaption>
</figure>
<p>比较次数: <span class="math inline">\(\lceil log_kr \rceil(n-1) \lceil log_2k \rceil= \lceil log_2r \rceil(n-1)\)</span></p>
<h4 id="置换-选择排序生成初始归并段">8.7.4 置换-选择排序（生成初始归并段）</h4>
<p>考虑到内存大小有限, 为了减少归并段个数 r, 提出本算法</p>
<p>初始待排文件 fi, 初始归并段输出文件 fo, 内存工作区 wa, wa 可以容下 w 个记录, 有以下步骤</p>
<ol type="1">
<li>从 fi 输入 w 记录到 wa</li>
<li>从 wa 中选出关键字最小的记录, 记为 minw (使用败者树)</li>
<li>将 minw 输出到 fo</li>
<li>若 fi 不为空, 从 fi输入 1 个记录到 wa</li>
<li>从 wa 中所有关键字比 minw 大的记录中选择最小的记录, 作为新的 minw</li>
<li>重复 3~5, 直到 wa 中选不出 minw, 输出一个归并段结束符到 fo</li>
<li>重复 2~6, 直到 wa 空, 结束</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5269857.png?token=AKM4PT2HN4JCR2IKHGV6SHLEOMW2A" alt="screenshot-5269857" /><figcaption aria-hidden="true">screenshot-5269857</figcaption>
</figure>
<h4 id="最佳归并树">8.7.5 最佳归并树</h4>
<p>为了统一置换选择产生的归并段的长度, 做归并平衡, 利用哈夫曼树, 并添加虚段使其是一棵完全树</p>
<p><span class="math inline">\(n_0 = (k-1)n_k+1\)</span></p>
<p><span class="math inline">\(n_k = \frac{(n_0-1)}{k-1}\)</span></p>
<p>其中 k 为叉数</p>
<p>当 <span class="math inline">\((n_0-1\%{k-1}=u)\)</span> 时, 应该添加<span class="math inline">\(k-u-1\)</span>个虚段</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5270469.png?token=AKM4PT3WHJS6OM7YVHZQD6LEOMYAI" alt="screenshot-5270469" /><figcaption aria-hidden="true">screenshot-5270469</figcaption>
</figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2023/05/f05961026253.html">https://sinos_wei.gitee.io/2023/05/f05961026253.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/frac/">frac</a><a class="post-meta__tags" href="/tags/int/">int</a><a class="post-meta__tags" href="/tags/idx/">idx</a><a class="post-meta__tags" href="/tags/list/">list</a><a class="post-meta__tags" href="/tags/index/">index</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/24.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/cd35e6945182.html" title="408目录"><img class="cover" src="/img/cover/101.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">408目录</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/724d57ab8c34.html" title="操作系统"><img class="cover" src="/img/cover/5.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">操作系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/12/a8bdee1d82ac.html" title="ai"><img class="cover" src="/img/cover/19.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">ai</div></div></a></div><div><a href="/2022/01/45f494d95337.html" title="cpp 从入门到汇编"><img class="cover" src="/img/cover/20.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">cpp 从入门到汇编</div></div></a></div><div><a href="/2020/01/c283701d8e64.html" title="java"><img class="cover" src="/img/cover/76.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">java</div></div></a></div><div><a href="/2022/01/87d43a06543c.html" title="leetcode"><img class="cover" src="/img/cover/28.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">leetcode</div></div></a></div><div><a href="/2022/06/b17e0aa0b323.html" title="OS3pieces读书笔记"><img class="cover" src="/img/cover/16.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">OS3pieces读书笔记</div></div></a></div><div><a href="/2022/09/84cc1427d0ce.html" title="effective_cpp读书笔记"><img class="cover" src="/img/cover/7.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">effective_cpp读书笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://8.130.42.149:5230" target="_blank" title="memo"><i class="fab fa-heart"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">第1章绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 数据结构的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1 基本概念和术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2 数据结构三要素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 算法和算法评价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 算法的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 算法效率的度量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-.%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">第2章 .线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 线性表的定义和基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 线性表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 线性表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 线性表的顺序表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 顺序表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2顺序表上基本操作的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 线性表的链式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 单链表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 单链表上基本操作的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3 双链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">2.3.4 循环链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">2.3.5 静态链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">2.3.6 顺序表和链表的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">第3章栈、队列和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 栈的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 栈的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3 栈的链式存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 队列的基本概念，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 队列的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3 队列的链式存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">3.2.4 双端队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 栈和队列的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 栈在括号匹配中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2 栈在表达式求值中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3.3 栈在递归中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3.3.4 队列在层次遍历中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">3.3.5 队列在计算机系统中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 数组和特殊矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">3.4.1 数组的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">3.4.2 数组的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3.4.3 特殊矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">3.4.4 稀疏矩阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0%E4%B8%B2"><span class="toc-number">1.4.</span> <span class="toc-text">第4章串。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">*4.1 串的定义和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 串的定义．</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 串的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3 串的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D."><span class="toc-number">1.4.1.4.</span> <span class="toc-text">4.2 串的模式匹配.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">4.2.1 简单的模式匹配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-kmp-%E7%AE%97%E6%B3%95."><span class="toc-number">1.4.1.6.</span> <span class="toc-text">4.2.2 串的模式匹配算法-KMP 算法.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmp-%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">4.2.3 KMP 算法的进一步优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">第5章 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 树的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">5.1.1 树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">5.1.2 基本术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">5.1.3 树的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 二叉树的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1 二叉树的定义及其主要特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2 二叉树的存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 二叉树的遍历和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 二叉树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 线索二叉树 ???</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E6%A3%AE%E6%9E%97"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 树、森林</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">5.4.1 树的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">5.4.2 树、森林与二叉树的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">5.4.3 树和森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">5.5.1 哈夫曼树和哈夫曼编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">5.5.2. 并查集???</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%98%AF%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E9%9B%86%E5%90%88%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.5.5.2.0.1.</span> <span class="toc-text">并查集是一种简单的集合表示</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">第6章图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">6.1.1 图的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 图的存储及基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1 邻接矩阵法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2 邻接表法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">6.2.3 十字链表(有向图)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">6.2.4 邻接多重表(无向图)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">6.2.5 图的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-bfs"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">6.3.1 广度优先搜索 BFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">6.3.2 深度优先搜索 DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">6.3.3 图的遍历与图的连通性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">6.4.1 最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">6.4.2 最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dijkstra-%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90"><span class="toc-number">1.6.4.2.1.</span> <span class="toc-text">dijkstra 算法 单源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#floyd-%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%BA%90"><span class="toc-number">1.6.4.2.2.</span> <span class="toc-text">floyd 算法 多源</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">6.4.3 有向无环图描述表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">6.4.4 拓扑排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">6.4.5 关键路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.</span> <span class="toc-text">第7章 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 查找的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 顺序查找和折半查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">7.2.1 顺序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%9C%89%E9%99%90%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">7.2.2 折半查找 (二分查找, 有限顺序表)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">7.2.3 分块查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%9E%8B%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 树型查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-bst-%E6%90%9C%E7%B4%A2%E6%A0%91-%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">7.3.1 二叉排序树 (BST) (搜索树, 查找树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-avl-%E6%A0%91adelson-velsky-and-landis-tree"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">7.3.2 平衡二叉树 AVL 树(Adelson-Velsky and Landis Tree)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">7.3.3 红黑树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E6%A0%91%E5%92%8Cb%E6%A0%91"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 B树和B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E6%A0%91%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">7.4.1 B树及其基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">7.4.2 B+树的基本概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">7.5.1 散列表的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">7.5.2 散列函数的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">7.5.3 处理冲突的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">7.5.4 散列查找及性能分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E6%9F%A5-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">第8查 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 排序的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">8.1.1 排序的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">8.2.1 直接插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">8.2.2 折半插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">8.2.3 希尔排序(缩小增量排序)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">8.3.1 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">8.3.2 快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">8.4.1 简单选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">8.4.2 堆排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 归并排序和基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">8.5.1 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">8.5.2基数排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6 各种内部排序算法的比较及应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">8.6.1 内部排序算法的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">8.6.2 内部排序算法的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.7.</span> <span class="toc-text">8.7 外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">8.7.1 外部排序的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">8.7.2 外部排序的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E5%BD%92%E5%B9%B6%E4%B8%8E%E8%B4%A5%E8%80%85%E6%A0%91"><span class="toc-number">1.8.7.3.</span> <span class="toc-text">8.7.3 多路平衡归并与败者树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%94%9F%E6%88%90%E5%88%9D%E5%A7%8B%E5%BD%92%E5%B9%B6%E6%AE%B5"><span class="toc-number">1.8.7.4.</span> <span class="toc-text">8.7.4 置换-选择排序（生成初始归并段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">1.8.7.5.</span> <span class="toc-text">8.7.5 最佳归并树</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/f05961026253.html" title="数据结构"><img src="/img/cover/24.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/2023/05/f05961026253.html" title="数据结构">数据结构</a><time datetime="2023-09-05T16:31:11.896Z" title="Updated 2023-09-06 00:31:11">2023-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/04/9ea3537bedb7.html" title="电影"><img src="/img/cover/43.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="电影"/></a><div class="content"><a class="title" href="/2020/04/9ea3537bedb7.html" title="电影">电影</a><time datetime="2023-09-03T12:41:01.223Z" title="Updated 2023-09-03 20:41:01">2023-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/4eb2e1b2c3ff.html" title="system-design"><img src="/img/cover/34.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="system-design"/></a><div class="content"><a class="title" href="/2023/08/4eb2e1b2c3ff.html" title="system-design">system-design</a><time datetime="2023-08-31T03:34:07.014Z" title="Updated 2023-08-31 11:34:07">2023-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/dd0ba91b15ab.html" title="code-review"><img src="/img/cover/111.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="code-review"/></a><div class="content"><a class="title" href="/2023/07/dd0ba91b15ab.html" title="code-review">code-review</a><time datetime="2023-08-21T14:29:06.086Z" title="Updated 2023-08-21 22:29:06">2023-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/b615e50b2d89.html" title="clean-code"><img src="/img/cover/38.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="clean-code"/></a><div class="content"><a class="title" href="/2023/08/b615e50b2d89.html" title="clean-code">clean-code</a><time datetime="2023-08-21T14:19:50.585Z" title="Updated 2023-08-21 22:19:50">2023-08-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>