<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: 408 | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="组成原理 第1章 计箅机系统概述 *1.1 计算机发展历程 *1.1.1 计算机硬件的发展 *1.1.2 计算机软件的发展 1.2 计算机系统层次结构 1.2.1. 计算机系统的组成 计算机系统 &#x3D; 硬件系统+软件系统 1.2.2 计算机硬件 冯诺依曼思想(存储程序)  采用存储程序的工作方式 存储程序思想: 将实现编制好的程序和原始数据送入主存后才能执行, 程序一旦启动无须人为干涉 计算机硬件">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="https://sinos_wei.gitee.io/2023/05/4ef6e1899988.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:description" content="组成原理 第1章 计箅机系统概述 *1.1 计算机发展历程 *1.1.1 计算机硬件的发展 *1.1.2 计算机软件的发展 1.2 计算机系统层次结构 1.2.1. 计算机系统的组成 计算机系统 &#x3D; 硬件系统+软件系统 1.2.2 计算机硬件 冯诺依曼思想(存储程序)  采用存储程序的工作方式 存储程序思想: 将实现编制好的程序和原始数据送入主存后才能执行, 程序一旦启动无须人为干涉 计算机硬件">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/00000074.jpg">
<meta property="article:published_time" content="2023-05-15T06:13:57.000Z">
<meta property="article:modified_time" content="2023-12-13T01:42:34.443Z">
<meta property="article:author" content="Sinos">
<meta property="article:tag" content="cpu">
<meta property="article:tag" content="mdr">
<meta property="article:tag" content="dma">
<meta property="article:tag" content="mar">
<meta property="article:tag" content="cache">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/00000074.jpg"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="canonical" href="https://sinos_wei.gitee.io/2023/05/4ef6e1899988.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: 408',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-13 09:42:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/00000074.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Sinos_wei's blog"><span class="site-name">Sinos_wei's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机组成原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2023-12-13T01:42:34.443Z" title="Updated 2023-12-13 09:42:34">2023-12-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408/">408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机组成原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<h1 id="组成原理">组成原理</h1>
<h2 id="第1章-计箅机系统概述">第1章 计箅机系统概述</h2>
<h3 id="计算机发展历程">*1.1 计算机发展历程</h3>
<h4 id="计算机硬件的发展">*1.1.1 计算机硬件的发展</h4>
<h4 id="计算机软件的发展">*1.1.2 计算机软件的发展</h4>
<h3 id="计算机系统层次结构">1.2 计算机系统层次结构</h3>
<h4 id="计算机系统的组成">1.2.1. 计算机系统的组成</h4>
<p>计算机系统 = 硬件系统+软件系统</p>
<h4 id="计算机硬件">1.2.2 计算机硬件</h4>
<p>冯诺依曼思想(存储程序)</p>
<ol type="1">
<li><p>采用存储程序的工作方式</p>
<p>存储程序思想: 将实现编制好的程序和原始数据送入主存后才能执行, 程序一旦启动无须人为干涉</p></li>
<li><p>计算机硬件系统包括: 运算器, 存储器, 控制器, 输入输出 五大部分</p></li>
<li><p>指令和数据以同等的地位存储在存储器中, 形式上无区别, 但计算机应能区分他们, <strong>区分是根据指令阶段区分</strong></p></li>
<li><p>指令和数据均由二进制表示</p></li>
<li><p>以运算单元为中心</p></li>
<li><p>存储器是按地址访问、线性编址的空间</p></li>
<li><p>控制流由指令流产生</p></li>
<li><p>指令由操作码和地址码组成</p></li>
</ol>
<p>存储器:</p>
<ul>
<li><strong>MAR 地址寄存器(memory address register), MDR 数据寄存器(memory data register)</strong> MAR 代表 PC 长度, 是虚拟memory地址空间的大小 MDR 代表存储字长, 即数据的位数</li>
<li>存储体包含存储单元, 存储单元包含存储元件 存储元件存储 1bit, 存储单元存储 1 存储字, 长度称为存储字长, byte 的2^n倍</li>
</ul>
<p>运算器: 包含若干通用寄存器, 程序状态寄存器(PSW, Program Status Word)</p>
<p>控制器: 包括</p>
<ul>
<li>程序计数器(PC Program Counter), 可自加 1(1 是一条指令的长度), 与主存的 MAR 有直接通路</li>
<li>指令寄存器(IR instruction register), 内容来自 MDR, 其内容中的操作码送往 CU, 地址送往 MAR</li>
<li>控制单元(CU control unit)</li>
</ul>
<p>CPU总体结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ┌────┐           ┌────┐    ┌───┐</span><br><span class="line">   │cpu1│           │cpu2◄────►RAM│</span><br><span class="line">   └──▲─┘           └──▲─┘    └───┘</span><br><span class="line">      │                │</span><br><span class="line">      └────────┬───────┘ FSB</span><br><span class="line">               │</span><br><span class="line">  ┌───┐  ┌─────▼─────┐  ┌──┐   ┌───┐</span><br><span class="line">  │RAM◄──►northbridge◄──►MC◄───►RAM│</span><br><span class="line">  └───┘  └─────▲─────┘  └──┘   └───┘</span><br><span class="line">               │</span><br><span class="line">┌─────┐        │</span><br><span class="line">│PCI-E│  ┌─────▼─────┐</span><br><span class="line">│SATA ◄──►southbridge│</span><br><span class="line">│USB  │  └───────────┘</span><br><span class="line">└─────┘</span><br></pre></td></tr></table></figure>
<p>缓存结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              ┌───────────┐</span><br><span class="line">              │Main Memory│</span><br><span class="line">              └─────▲─────┘</span><br><span class="line">   Bus              │</span><br><span class="line">────────▲───────────▼───────►</span><br><span class="line">        │</span><br><span class="line">     ┌──▼──┐      ┌────────┐</span><br><span class="line">     │Cache◄──────►CPU core│</span><br><span class="line">     └─────┘      └────────┘</span><br></pre></td></tr></table></figure>
<p>在CPU中至少要有六类寄存器：指令寄存器（IR）、程序计数器（PC）、<strong>地址寄存器（AR）、数据寄存器（DR）</strong>、累加寄存器（AC）、程序状态字寄存器（PSW）</p>
<ol type="1">
<li><p>数据寄存器 数据寄存器（Data Register，DR）又称数据缓冲寄存器，其主要功能是作为CPU和主存、外设之间信息传输的中转站，用以弥补CPU和主存、外设之间操作速度上的差异。<br />
数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一条指令或一个数据字时，也将它们暂时存放在数据寄存器中。</p>
<p>数据寄存器的作用是 ：</p>
<p>（1）作为CPU和主存、外围设备之间信息传送的中转站；</p>
<p>（2）弥补CPU和主存、外围设备之间在操作速度上的差异；</p>
<p>（3）在单累加器结构的运算器中，数据寄存器还可兼作操作数寄存器。</p></li>
<li><p>地址寄存器 地址寄存器（Address Register，AR）用来保存CPU当前所访问的主存单元的地址。</p>
<p>由于在主存和CPU之间存在操作速度上的差异，所以必须使用地址寄存器来暂时保存主存的地址信息，直到主存的存取操作完成为止。</p>
<p>当CPU和主存进行信息交换，即CPU向主存存入数据/指令或者从主存读出数据/指令时，都要使用地址寄存器和数据寄存器。</p>
<p>如果我们把外围设备与主存单元进行统一编址，那么，当CPU和外围设备交换信息时，我们同样要使用地址寄存器和数据寄存器。</p></li>
<li><p>程序状态字寄存器 程序状态字（Program Status Word，PSW）用来表征当前运算的状态及程序的工作方式。</p>
<p>程序状态字寄存器用来保存由算术/逻辑指令运行或测试的结果所建立起来的各种条件码内容，如运算结果进/借位标志（C）、运算结果溢出标志（O）、运算结果为零标志（Z）、运算结果为负标志（N）、运算结果符号标志（S）等，这些标志位通常用1位触发器来保存。</p>
<p>除此之外，程序状态字寄存器还用来保存中断和系统工作状态等信息，以便CPU和系统及时了解机器运行状态和程序运行状态。</p>
<p>因此，程序状态字寄存器是一个保存各种状态条件标志的寄存器。</p></li>
<li><p>指令寄存器 指令寄存器（Instruction Register，IR）用来保存当前正在执行的一条指令。</p>
<p>当执行一条指令时，首先把该指令从主存读取到数据寄存器中，然后再传送至指令寄存器。</p>
<p>指令包括操作码和地址码两个字段，为了执行指令，必须对操作码进行测试，识别出所要求的操作，指令译码器（Instruction Decoder，ID）就是完成这项工作的。指令译码器对指令寄存器的操作码部分进行译码，以产生指令所要求操作的控制电位，并将其送到微操作控制线路上，在时序部件定时信号的作用下，产生具体的操作控制信号。</p>
<p>指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码，即可向操作控制器发出具体操作的特定信号。</p></li>
<li><p>程序计数器 程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的地址。</p>
<p>在程序执行之前，首先必须将程序的首地址，即程序第一条指令所在主存单元的地址送入PC，因此PC的内容即是从主存提取的第一条指令的地址。</p>
<p>当执行指令时，CPU能自动递增PC的内容，使其始终保存将要执行的下一条指令的主存地址，为取下一条指令做好准备。</p>
<p>但是，当遇到转移指令时，下一条指令的地址将由转移指令的地址码字段来指定，而不是像通常的那样通过顺序递增PC的内容来取得。</p>
<p>因此，程序计数器的结构应当是具有寄存信息和计数两种功能的结构。</p></li>
<li><p>累加寄存器 累加寄存器通常简称累加器（Accumulator，AC），是一个通用寄存器。</p>
<p>累加器的功能是：当运算器的算术逻辑单元ALU执行算术或逻辑运算时，为ALU提供一个工作区，可以为ALU暂时保存一个操作数或运算结果。</p>
<p>显然，运算器中至少要有一个累加寄存器。</p></li>
</ol>
<h4 id="计算机软件">1.2.3 计算机软件</h4>
<p>分为系统软件: OS, DBMS</p>
<p>和应用软件: 科学计算</p>
<p>翻译程序:</p>
<ul>
<li>汇编程序: 汇编语言 -&gt; 机器语言</li>
<li>解释程序: 源程序按顺序逐句翻译为机器指令并执行</li>
<li>编译程序: 高级语言 -&gt; 汇编语言/机器语言</li>
</ul>
<h4 id="计算机系统的层次结构">1.2.4 计算机系统的层次结构</h4>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5435425.png?token=AKM4PT2MVWN33GAZOQEAQ2LEOW2GA" alt="screenshot-5435425" /><figcaption aria-hidden="true">screenshot-5435425</figcaption>
</figure>
<h4 id="计算机系统的工作原理">1.2.5 计算机系统的工作原理</h4>
<p>从源程序到可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD;</span><br><span class="line">    开始--hello.c源程序--&gt;预处理器:c-pre-processor</span><br><span class="line">    预处理器:c-pre-processor--hello.i 修改了的源程序--&gt;编译器:c-compiler;</span><br><span class="line">    编译器:c-compiler--hello.s 汇编程序--&gt;汇编器:assembler</span><br><span class="line">    汇编器:assembler--hello.o 可重定位目标程序--&gt;链接器:linker&amp;loader</span><br><span class="line">    其他重定位目标程序----&gt;链接器:linker&amp;loader</span><br><span class="line">    链接器:linker&amp;loader----&gt;hello可执行目标程序</span><br></pre></td></tr></table></figure>
<p><strong>指令执行过程</strong></p>
<ol type="1">
<li>取指令 PC-&gt;MAR-&gt;MM-&gt;MDR-&gt;IR 根据 PC 内容取指令存入 IR</li>
<li>分析指令 OP(IR) -&gt; CU 分析 IR 中的 OP 产生控制信号</li>
<li>执行指令 Address(IR) -&gt; MAR -&gt; MM -&gt; MDR -&gt; ALU 根据 IR 中的地址取操作数传入 ALU</li>
<li>(PC)+1 -&gt; PC</li>
</ol>
<h3 id="计算机的性能指标">1.3 计算机的性能指标</h3>
<h4 id="计算机的主要性能指标">1.3.1 计算机的主要性能指标</h4>
<p>字长(机器字长): 一次定点整数运算能处理的二进制数据的位数, 通常和 cpu 寄存器位数, 加法器有关 指令字长一般是存储字长的整数倍(多个存取周期)</p>
<p>数据通路带宽: 外部数据总线一次能传送的信息的位数, 与 cpu 内部数据总线宽度可能不同</p>
<p>主存容量: MAR 的长度反应存储单元的个数, MDR 的长度反应了存储字长</p>
<p><span class="math inline">\(吞吐量 = \frac{处理请求数量}{时间}\)</span> 主要与主存的存取周期有关</p>
<p><span class="math inline">\(响应时间 = 收到响应结果时刻 - 发送请求时刻\)</span></p>
<p>CPI clock per instruction</p>
<p><span class="math inline">\(CPU执行时间 = \frac{CPU 时钟周期数}{主频} = \frac{指令数量*CPI}{主频}\)</span></p>
<p>MIPS 10<sup>6</sup> instructions per second <span class="math inline">\(MIPS = \frac{指令数量}{执行时间*10^6} = \frac{主频}{CPI*10^6}\)</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">10n</th>
<th style="text-align: center;">詞頭</th>
<th style="text-align: center;">記号</th>
<th style="text-align: center;">表記</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1024</td>
<td style="text-align: center;">yotta</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">一秭</td>
</tr>
<tr class="even">
<td style="text-align: center;">1021</td>
<td style="text-align: center;">zetta</td>
<td style="text-align: center;">Z</td>
<td style="text-align: center;">十垓</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1018</td>
<td style="text-align: center;">exa</td>
<td style="text-align: center;">E</td>
<td style="text-align: center;">百京</td>
</tr>
<tr class="even">
<td style="text-align: center;">1015</td>
<td style="text-align: center;">peta</td>
<td style="text-align: center;">P</td>
<td style="text-align: center;">千兆</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1012</td>
<td style="text-align: center;">tera</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">兆</td>
</tr>
<tr class="even">
<td style="text-align: center;">109</td>
<td style="text-align: center;">giga</td>
<td style="text-align: center;">G</td>
<td style="text-align: center;">十億</td>
</tr>
<tr class="odd">
<td style="text-align: center;">106</td>
<td style="text-align: center;">mega</td>
<td style="text-align: center;">M</td>
<td style="text-align: center;">百萬</td>
</tr>
<tr class="even">
<td style="text-align: center;">103</td>
<td style="text-align: center;">kilo</td>
<td style="text-align: center;">k</td>
<td style="text-align: center;">千</td>
</tr>
<tr class="odd">
<td style="text-align: center;">102</td>
<td style="text-align: center;">hecto</td>
<td style="text-align: center;">h</td>
<td style="text-align: center;">百</td>
</tr>
<tr class="even">
<td style="text-align: center;">101</td>
<td style="text-align: center;">deca，deka</td>
<td style="text-align: center;">da</td>
<td style="text-align: center;">十</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">一</td>
</tr>
<tr class="even">
<td style="text-align: center;">10−1</td>
<td style="text-align: center;">deci</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">十分之一 / 分</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10−2</td>
<td style="text-align: center;">centi</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">百分之一 / 厘</td>
</tr>
<tr class="even">
<td style="text-align: center;">10−3</td>
<td style="text-align: center;">milli</td>
<td style="text-align: center;">m</td>
<td style="text-align: center;">千分之一 / 毫</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10−6</td>
<td style="text-align: center;">micro</td>
<td style="text-align: center;">µ</td>
<td style="text-align: center;">百万分之一 / 微</td>
</tr>
<tr class="even">
<td style="text-align: center;">10−9</td>
<td style="text-align: center;">nano</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">十億分之一 / 奈</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10−12</td>
<td style="text-align: center;">pico</td>
<td style="text-align: center;">p</td>
<td style="text-align: center;">一兆分之一 / 皮</td>
</tr>
<tr class="even">
<td style="text-align: center;">10−15</td>
<td style="text-align: center;">femto</td>
<td style="text-align: center;">f</td>
<td style="text-align: center;">千兆分之一 / 飛</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10−18</td>
<td style="text-align: center;">atto</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">百京分之一</td>
</tr>
<tr class="even">
<td style="text-align: center;">10−21</td>
<td style="text-align: center;">zepto</td>
<td style="text-align: center;">z</td>
<td style="text-align: center;">十垓分之一</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10−24</td>
<td style="text-align: center;">yocto</td>
<td style="text-align: center;">y</td>
<td style="text-align: center;">一秭分之一</td>
</tr>
</tbody>
</table>
<h4 id="几个专业术语">1.3.2 几个专业术语</h4>
<p>系列机: 有基本相同的体系结构(Computer Architecture) , 使用相同基本指令系统的不同计算机组成的产品系列</p>
<p><strong>体系结构: 机器语言或汇编语言程序员能看到的传统机器的属性, 包括: 指令集, 数据类型, 存储器寻址技术等抽象属性</strong></p>
<p>计算机组成: 如何实现体系结构所体现的属性, 对大部分程序员是透明的, 如: 如何执行指令周期, 如何实现乘法等</p>
<p>兼容:</p>
<ul>
<li><strong>向前兼容(向上兼容): 现在的版本对未来兼容</strong> forward</li>
<li><strong>向后兼容(向下兼容): 现在的版本对过去兼容</strong> backward 软件一般向后兼容, 现在的机器可以使用老的软件 数据一般向前兼容, 新的数据可以被用在旧的系统中</li>
</ul>
<p>固件: 程序固化在 ROM 中组成的部件称为固件</p>
<h2 id="第2章-数据的表示和运算">第2章 数据的表示和运算</h2>
<h3 id="数制与编码">2.1数制与编码</h3>
<h4 id="进位计数制及其相互转换">2.1.1 进位计数制及其相互转换</h4>
<p>十进制转换为 r 进制:</p>
<ul>
<li>整数部分: 除基数取余, 先得到的余数是低位</li>
<li>小数部分: 乘基数取整, 先得到的整数是高位</li>
</ul>
<p><strong>机器数</strong>: 计算机中将数据及其符号数字化, 常用的表示方法有: 原码, 补码, 反码</p>
<h4 id="bcd码-binary-coded-decimal">*2.1.2 BCD码 binary-coded decimal</h4>
<ul>
<li>8421 码: 进位+6 修正</li>
<li>余 3 码: 在 8421 码的基础上加 0011</li>
<li>2421 码</li>
</ul>
<h4 id="定点数的编码表示">2.1.3 定点数的编码表示</h4>
<p>通常用: 定点补码表示正数, 定点原码小数(纯小数, .xxxxx)表示浮点数尾数, 移码表示浮点数阶码</p>
<p>对于 n 位数, 原码范围: -(2<sup>n-1</sup>-1) ~ 2<sup>n-1</sup>-1 补码范围: -2<sup>n-1</sup> ~ 2<sup>n-1</sup>-1 正数范围: 0~2<sup>n</sup>-1</p>
<p>原码: 最高位是符号位</p>
<p>补码: 纯小数(字长为 n+1, 整数部分 1, 小数部分 n)</p>
<p><span class="math display">\[[x]_补= \begin{cases}
x,\quad &amp;0\le x &lt;1 \\
2+x=2-|x|,\quad &amp;-1 \le x &lt;0
\end{cases} (mod2) \]</span></p>
<p>纯整数(字长为 n+1)</p>
<p><span class="math display">\[[x]_补= \begin{cases}
0, x,\quad &amp;0\le x &lt;2^n \\
2^{n+1}+x=2^{n+1}-|x|,\quad &amp;-2^n \le x &lt;0
\end{cases} (mod2^{n+1}) \]</span></p>
<p><strong>负真数-&gt;补码: 符号位取 1, 其余位取反末位+1</strong></p>
<p><strong>正真数-&gt;补码: 不变</strong></p>
<p><strong>负补码-&gt;真数: 各位取反末位+1</strong></p>
<p><strong>正补码-&gt;真数: 不变</strong></p>
<p><strong>对于负数, 不看符号位, 补码+原码应该进位</strong></p>
<h4 id="整数的表示">2.1.4 整数的表示</h4>
<h3 id="运算方法和运算电路">2.2 运算方法和运算电路</h3>
<h4 id="基本运算部件">2.2.1 基本运算部件</h4>
<p>一位全加器 FA</p>
<p><span class="math inline">\(S_i = A_i \oplus B_i \oplus C_{i-1}\)</span></p>
<p><span class="math inline">\(C_i = A_i B_i + (A_i \oplus B_i)C_{i-1}\)</span></p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5500004.png?token=AKM4PT72N75KMTDID2OJL5LEO2YKG" alt="screenshot-5500004" style="zoom:50%;" /></p>
<p>串行进位加法器</p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5500171.png?token=AKM4PT2UT57SXYVUN2OXYRDEO2YUS" alt="screenshot-5500171" style="zoom:50%;" /></p>
<p>并行进位加法器</p>
<p>令进位产生函数<span class="math inline">\(G_i = A_i B_i\)</span>, 进位传递函数<span class="math inline">\(P_i = A_i \oplus B_i\)</span></p>
<p><span class="math inline">\(C_i = G_i+P_i C_{i-1}\)</span></p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5500220.png?token=AKM4PT2EJXJJRS4OVDY2N33EO2YXW" alt="screenshot-5500220" style="zoom:50%;" /></p>
<p>带符号加法器</p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5500448.png?token=AKM4PTYG65IBW5E3SEQ5QHTEO2ZF6" alt="screenshot-5500448" style="zoom:50%;" /></p>
<p>溢出<span class="math inline">\(OF = C_n \oplus C_{n-1}\)</span></p>
<p>符号<span class="math inline">\(SF = F_{n-1}\)</span></p>
<p>零标志 ZF = 1 当且仅当 F=0</p>
<p>进位/借位<span class="math inline">\(CF = C_{out} \oplus C_{in}\)</span></p>
<p>ALU</p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5500701.png?token=AKM4PT7QFDJ7LWW2YZCYQSLEO2ZVY" alt="screenshot-5500701" style="zoom:50%;" /></p>
<h4 id="定点数的移位运算">2.2.2 定点数的移位运算</h4>
<p>算数移位: 对有符号数, 逻辑移位: 对无符号数</p>
<p>循环移位: 分为带进位位和不带进位位</p>
<h4 id="定点数的加减运算">2.2.3 定点数的加减运算</h4>
<p>补码定点数加减电路</p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/screenshot-5501133.png?token=AKM4PTZ5DP2FU6ZWRIJPHJTEO22Q2" alt="screenshot-5501133" style="zoom:50%;" /></p>
<p>补码判断溢出的方法:</p>
<ol type="1">
<li><p>一位符号位 V=1 表示溢出 <span class="math inline">\(V=A_s B_s \overline S_s + \overline{A_s B_s}S_s\)</span></p></li>
<li><p>双符号位 V=1 表示溢出, 此时最高位为真正的符号</p>
<p><span class="math inline">\(V=S_{s1}\oplus S_{s2}\)</span></p></li>
<li><p>一位符号位+进位情况 V=1 表示溢出</p>
<p><span class="math inline">\(V=C_{s}\oplus C_{1}\)</span>, 其中 C<sub>s</sub>为最高位进位</p></li>
</ol>
<h4 id="定点数的乘除运算">2.2.4 定点数的乘除运算</h4>
<p>无符号数乘法电路</p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531105550282.png?token=AKM4PT4OMAEOQUSBEBWCHYDEO23XI" alt="image-20230531105550282" style="zoom:50%;" /></p>
<p>补码一位乘法(booth 乘法)</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/v2-649308ad16a3f2b1df25c4fdb2b78df3_1440w.webp?token=AKM4PT3CV2MT5LMCSW4FXDTEO24K4" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>补码乘法电路</p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531110149175.png?token=AKM4PTYSEET3OJ2ZXE3R5D3EO24NY" alt="image-20230531110149175" style="zoom:50%;" /></p>
<p>原码除法</p>
<p>补码除法</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531110313978.png?token=AKM4PTZJO3PU4Z3K7NZFC33EO24TE" alt="image-20230531110313978" /><figcaption aria-hidden="true">image-20230531110313978</figcaption>
</figure>
<p>除法电路</p>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531110336681.png?token=AKM4PT7JIVXEUQR2SDC25U3EO24UO" alt="image-20230531110336681" style="zoom:50%;" /></p>
<h4 id="c语言中的整数类型及类型转换">2.2.5 C语言中的整数类型及类型转换</h4>
<p>强制类型转换位值不变, 只改变解释方式</p>
<p><strong>隐式转换优先级</strong>, 从下转换到上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long double</span><br><span class="line">double</span><br><span class="line">float</span><br><span class="line">unsigned long long </span><br><span class="line">long long</span><br><span class="line">unsigned long</span><br><span class="line">long</span><br><span class="line">unsigned int</span><br><span class="line">int</span><br><span class="line">char/short/unsigned char/unsigned short</span><br><span class="line"></span><br><span class="line">unsigned int x &#123;20u&#125;;</span><br><span class="line">int y &#123;30&#125;;</span><br><span class="line">x-y // type is unsigned int</span><br></pre></td></tr></table></figure>
<h4 id="数据的存储和排列">2.2.6 数据的存储和排列</h4>
<p>按照 byte 编址</p>
<p>大端: 高位在低地址</p>
<p>小端: 低位在低地址</p>
<p>边界对齐</p>
<h4 id="汇编加减乘除">2.2.7 汇编加减乘除</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;自增自减 inc dec</span><br><span class="line">inc ax</span><br><span class="line"></span><br><span class="line">;加法 add</span><br><span class="line">add eax, var; eax+(var)-&gt;eax</span><br><span class="line">;进位位=1 则 cf=1</span><br><span class="line"></span><br><span class="line">;减法 sub</span><br><span class="line">sub eax, var;eax-(var)-&gt;eax</span><br><span class="line">;取补后做加法, 加法的进位位=0, 则 cf=0</span><br><span class="line"></span><br><span class="line">;取负 neg </span><br><span class="line">neg eax</span><br><span class="line"></span><br><span class="line">;乘法 mul 无符号数乘法</span><br><span class="line">mov al, 5h</span><br><span class="line">mov bl, 10h</span><br><span class="line">mul bl;bl*al-&gt;ax</span><br><span class="line"></span><br><span class="line">;乘法 imul 有符号数乘法</span><br><span class="line">;单操作数</span><br><span class="line">imul bx;ax*bx-&gt;dx:ax</span><br><span class="line">;双操作数</span><br><span class="line">imul ax, var;ax*(var)-&gt;ax 有截断</span><br><span class="line">;三操作数 imul reg, reg/mem, imm</span><br><span class="line">imul ax, bx, 8;bx*8-&gt;ax</span><br><span class="line">;例如如果 32 位乘法的积扩展到 dx, 则进位=1, 也即 dx 非全 0 或全 1 时, 溢出位=1</span><br><span class="line"></span><br><span class="line">;除法 div 无符号数除法</span><br><span class="line">mov ax, 0083h</span><br><span class="line">mov bl, 2</span><br><span class="line">div bl;al = ax/bl, ah = ax%bl</span><br><span class="line">;除法 idiv 有符号数除法</span><br><span class="line">DIV (unsigned divide) 无符号数除法</span><br></pre></td></tr></table></figure>
<h3 id="浮点数的表示与运算">2.3 浮点数的表示与运算</h3>
<h4 id="浮点数的表示">2.3.1 浮点数的表示</h4>
<p><span class="math inline">\(N=(-1)^S * M * R^E\)</span></p>
<p>浮点数的规格化: 调整尾数和阶码, 使得尾数的最高位上是有效值</p>
<p><strong>IEEE 754 标准</strong></p>
<p>偏置值: 2<sup>E-1</sup>-1 = 127 或 1023 尾数: 1.xxxx , 1 隐藏可以多表示 1 位</p>
<p><strong>32 位浮点数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0    1        9        32</span><br><span class="line"> sign exponent mantissa</span><br><span class="line"> 1    8        23</span><br><span class="line">0/1  [1-127, 254-127]   [1.0, 1.111...]</span><br><span class="line">注意: 阶码全为 0 或 1 时有特殊含义</span><br></pre></td></tr></table></figure>
<p>64 位浮点数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0    1        12        64</span><br><span class="line"> sign exponent  mantissa</span><br><span class="line"> 1    11        52</span><br></pre></td></tr></table></figure>
<p>80 位浮点数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0    1        16        80</span><br><span class="line"> sign exponent  mantissa</span><br><span class="line"> 1    15        64</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531113026759.png" alt="image-20230531113026759" /><figcaption aria-hidden="true">image-20230531113026759</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：178.125</span><br><span class="line">1. 先把浮点数分别把整数部分和小数部分转换成2进制</span><br><span class="line">   1. 整数部分用除2取余的方法，求得：1011 0010</span><br><span class="line">   2. 小数部分用乘2取整的方法，求得：001</span><br><span class="line">   3. 合起来即是：10110010.001</span><br><span class="line">   4. 转换成二进制的浮点数，即把小数点移动到整数位只有1，即为：1.0110010001 * 2^111，111是二进制，由于左移了7位，所以是111</span><br><span class="line">2. 把浮点数转换二进制后，这里基本已经可以得出对应3部分的值了</span><br><span class="line">   1. 数符：由于浮点数是正数，故为0.(负数为1)</span><br><span class="line">   2. 阶码 : 阶码的计算公式：阶数 + 偏移量, 阶码是需要作移码运算，在转换出来的二进制数里，阶数是111(十进制为7)，对于单精度的浮点数，偏移值为01111111(127)[偏移量的计算是：2^(e-1)-1, e为阶码的位数，即为8，因此偏移值是127]，即：111+01111111 = 10000110</span><br><span class="line">   3. 尾数：小数点后面的数，即0110010001</span><br><span class="line">   4. 最终根据位置填到对位的位置上：</span><br><span class="line">   0 10000110 (1)0110010001</span><br><span class="line">   </span><br><span class="line">例如: C640 0000H</span><br><span class="line">1. 符号码:1, 阶码:100 0110 0, 尾数:10000...</span><br><span class="line">2. -        +1-128=000 0110 1   1.10000...(2 进制) = 1.5</span><br><span class="line">3. -1.5 * 2^13</span><br></pre></td></tr></table></figure>
<h4 id="浮点数的加减运算">2.3.2 浮点数的加减运算</h4>
<ol type="1">
<li>对阶, <strong>小阶向大阶</strong>看齐</li>
<li>尾数求和</li>
<li><strong>规格化</strong> 左规(尾数左移1位，阶码减1)右规(尾数右移1位，阶码加1)</li>
<li>舍入: 将右移移出的保留两位参与计算
<ol type="1">
<li>0 舍 1 入</li>
<li>恒置 1</li>
</ol></li>
<li>溢出判断, 判断阶数是否溢出</li>
</ol>
<p>舍入方式</p>
<p>1、就近舍入： 即十进制下的四舍五入。但是也会出现以下几种情况： 多余数字是1001，它大于0.5，故最低位进1。 多余数字是0111，它小于0.5，则直接舍掉多余数字。 多余数字是1000，正好是等于0.5的特殊情况；那么此时最低位为0则舍掉多余位，最低位为1则进位1。 注意这里说明的数位都是指二进制数。因为这是尾数，所以在计算这些二进制和0.5的关系的时候，也即转为10进制的时候，我们用每一位的权重乘以2^(-i)然后求和即可。</p>
<p>2、朝0舍入：即朝数轴零点方向舍入，所以我们直接截尾即可。</p>
<p>3、朝正无穷舍入：对正数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；负数的话不管多余位是多少直接截尾即可。</p>
<p>4、朝负无穷舍入：对负数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；正数的话不管多余位是多少直接截尾即可。</p>
<h2 id="第3章-存储系统">第3章 存储系统</h2>
<h3 id="存储器概述">3.1 存储器概述</h3>
<h4 id="存储器的分类">3.1.1 存储器的分类</h4>
<ol type="1">
<li><p>按作用(层次)</p>
<ol type="1">
<li>主存 main memory</li>
<li>辅助存储器(外存)</li>
<li>Cache</li>
</ol></li>
<li><p>按存储介质</p>
<p>磁表面存储器(磁盘磁带), 磁芯存储器, 半导体存储器, 光存储器(光盘)</p></li>
<li><p><strong>按存取方式</strong></p>
<ol type="1">
<li>RAM: 随机存取</li>
<li>ROM: 现代 ROM 有些也可以重复读写, 也为随机读写, 保留了断电内容保留的特点, 写比读要慢很多</li>
<li>串行访问存储器: 按物理位置的先后顺序寻址, 如磁带, 磁盘, 光盘</li>
</ol></li>
</ol>
<h4 id="存储器的性能指标">3.1.2 存储器的性能指标</h4>
<p>存储容量(存储字数*字长), 单位成本(总成本/总容量) 存储速度:</p>
<ul>
<li>数据传输率 = 数据宽度/存取周期</li>
<li>存取时间 T<sub>a</sub> 从启动一次存储器操作到完成操作所用的时间, 分为读出时间和写入时间</li>
<li>存取周期(读写周期, 访问周期) T<sub>m</sub> 存储器进行一次完整的读写操作所需的全部时间, 也是两次独立访问存储器操作之间所需的最小时间间隔</li>
<li>主存带宽 B<sub>m</sub> 也叫数据传输率, 表示每秒从主存进出信息的最大数量</li>
</ul>
<p>通常存取周期 &gt; 存取时间, 因为存储器在读写操作之后有一段复原时间, 特别是对破坏性读出的存储器</p>
<h4 id="多级层次的存储系统">3.1.3 多级层次的存储系统</h4>
<h3 id="主存储器">3.2 主存储器</h3>
<h4 id="sram-芯片和-dram-芯片">3.2.1 SRAM 芯片和 DRAM 芯片</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>SRAM</th>
<th>DRAM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读取</td>
<td>非破坏性</td>
<td>破坏性</td>
</tr>
<tr class="even">
<td>优点</td>
<td>存取快</td>
<td>易集成, 价格低, 功耗低</td>
</tr>
<tr class="odd">
<td>缺点</td>
<td>集成度低, 功耗大, 价格贵</td>
<td>存取慢</td>
</tr>
<tr class="even">
<td>原理</td>
<td>MOS 管</td>
<td>电容</td>
</tr>
<tr class="odd">
<td>刷新</td>
<td>no</td>
<td>yes</td>
</tr>
<tr class="even">
<td>送行列地址</td>
<td>同时</td>
<td>分两次</td>
</tr>
</tbody>
</table>
<p><strong>DRAM 刷新</strong>: 一个刷新周期中有许多存取周期</p>
<ol type="1">
<li>集中刷新: 每个刷新周期内用固定时间对所有行逐行刷新, 此期间存储器停止读写操作, 称为死时间</li>
<li>分散刷新: 每个存取周期中增加刷新(如刷新其中一行), 没有了死时间, 但是增加了存取周期</li>
<li>异步刷新: 两次刷新操作的时间间隔<span class="math inline">\(t = \frac{刷新周期}{行数}\)</span> 每隔时间 t 产生一次刷新请求, 刷新其中的一行, 即每次刷新只有一行处于死时间</li>
</ol>
<p>DRAM 刷新对 CPU 透明, 刷新单位是行, 刷新不需要选片, 所有芯片同时刷新</p>
<p>存储器芯片结构</p>
<ul>
<li>存储体(存储矩阵): 通过行选择线 X 列选择线 Y 选择访问单元</li>
<li>地址译码器: 将地址转换为译码输出线上的电平驱动读写电路</li>
<li>IO 控制电路: 控制被选中的单元的读写, 具有放大信息的作用
<ul>
<li>片选控制信号: 选中芯片</li>
<li>读写控制信号</li>
</ul></li>
</ul>
<h4 id="只读存储器">3.2.2 只读存储器</h4>
<p>特点:</p>
<ol type="1">
<li>结构简单, 位密度比可读写存储器高</li>
<li>非易失性</li>
</ol>
<p>ROM 类型</p>
<ol type="1">
<li>掩模式只读存储器 MROM 写入后人和人无法改变其内容, 由半导体制造商写入, 便宜但灵活性差</li>
<li>一次可编程只读存储器 PROM 允许用户用专门的设备写入程序, 一旦写入就无法改变</li>
<li>可擦除可编程只读存储器 EPROM 可以用编程器写入并且可以多次改写, 但编程次数有限且写入时间长(不能代替 RAM)</li>
<li>电子式可擦除可编程只读存储 EEPROM 写入更简单</li>
<li>FLASH 存储器 闪存 既可以在不加电情况下长期保存信息, 又可以在线快速擦除和重写, 兼具 EPROM 和 EEPROM 优点</li>
<li>固态硬盘 SSD 保留了 Flash 的特性, 比传统硬盘读写速度快, 功耗低, 但价格高</li>
</ol>
<h4 id="主存储器-mm-的基本组成">3.2.3 主存储器 MM 的基本组成</h4>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531142926138.png" alt="image-20230531142926138" /><figcaption aria-hidden="true">image-20230531142926138</figcaption>
</figure>
<p>地址引脚复用: 行地址和列地址通过相同引脚先后两次输入</p>
<h4 id="多模块存储器">3.2.4 多模块存储器</h4>
<p>多个存储模块并行工作</p>
<ul>
<li>单体多字存储器 一个存储体, 每个存储单元存 m 个字, 总线宽度为 m 个字, 一次并行读出 m 个字 提高了存取效率, 但当指令数据不是连续存放时效果不明显</li>
<li><strong>多体并行存储器</strong>
<ul>
<li>高位交叉编址(顺序方式) 高位地址表示体号, 低位地址表示体内地址, 这种方式仍是串行存取, 顺序存储器</li>
<li>低位交叉编址(交叉方式) 低位地址表示体号, 高位地址表示体内地址, 这种方式是并行存取 设字长=数据总线宽度, 一个字的存取周期=T, 总线传送周期=r, 为实现流水线, 应满足<span class="math inline">\(m=\frac T r\)</span> m 称为交叉存取度, 模块数应&gt;=m, 连续存取 m 个字需要的时间为 <span class="math inline">\(t_1 = T +(m-1)r\)</span></li>
</ul></li>
</ul>
<h3 id="主存储器与-cpu-的连接">3.3 主存储器与 CPU 的连接</h3>
<h4 id="连接原理">3.3.1 连接原理</h4>
<ol type="1">
<li>MM 通过数据总线, 地址总线, 控制总线与 CPU 连接</li>
<li>数据总线的位数 * 工作频率 = k * 数据传输率</li>
<li>地址总线位数决定寻址最大内存空间</li>
<li>控制总线指出总线周期的类型和本次输入输出操作完成的时刻</li>
</ol>
<h4 id="主存容量的扩展">3.3.2 主存容量的扩展</h4>
<ol type="1">
<li><p>位扩展 CPU数据线数 &gt; 存储芯片数据位数, 此时增加存储字长, 片选信号<span class="math inline">\(\overline{CS}\)</span>要连接到所有芯片 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531145821725.png?token=AKM4PT5DIGOWXXUSBSTXP33EO3YFA" alt="image-20230531145821725" /></p></li>
<li><p>字扩展 增加存储器中字的数量, 字长不变</p>
<p>将地址的一部分(如高位)作为片选信号 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531150028395.png?token=AKM4PTY5U76EBEWBLH7Q4HLEO3YMU" alt="image-20230531150028395" /></p></li>
<li><p>字位同时扩展 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531150320862.png?token=AKM4PT27POIY7DU2PURM6OLEO3YXO" alt="image-20230531150320862" /></p></li>
</ol>
<h4 id="存储芯片的地址分配和片选">3.3.3 存储芯片的地址分配和片选</h4>
<p>先片选再片内字选, 片选的方法有</p>
<ol type="1">
<li>线选法 用片内字选之外的高位地址线直接接到存储芯片的片选端(0 代表有效?) 不需要地址译码器, 线路简单 但是地址空间不连续, 选片地址线必须分时为低电平(不能同时有效), 没有充分利用存储器空间(高几位相当于没有了)</li>
<li>译码片选 用片内字选意外的高位地址线通过地址译码器产生片选信号</li>
</ol>
<h4 id="存储器与-cpu-的连接">3.3.4 存储器与 CPU 的连接</h4>
<ol type="1">
<li>选择 ROM 还是 RAM, 芯片的数量</li>
<li>地址线连接(片选)</li>
<li>数据线连接(扩位)</li>
<li>读写命令线, 通常高电平读低电平写</li>
<li>片选线</li>
</ol>
<h3 id="外部存储器.">3.4 外部存储器.</h3>
<h4 id="磁盘存储器">3.4.1 磁盘存储器</h4>
<p>容量大, 成本低, 可反复使用, 可长期保存, 非破坏性读出, 但存取速度慢, 机械结构复杂</p>
<h5 id="磁盘存储器-1">磁盘存储器</h5>
<p>磁盘设备的组成:</p>
<ol type="1">
<li>硬盘存储器的组成:
<ol type="1">
<li>磁盘驱动器: 磁头组件和盘片组件</li>
<li>磁盘控制器: 硬盘存储器和主机的接口, 标准有 IDE, SCSI, SATA</li>
<li>盘片</li>
</ol></li>
<li>存储区域 一块硬盘有若干记录面, 记录面划分为若干磁道, 磁道划分若干扇区(块 block), 扇区是磁盘读写最小单位
<ol type="1">
<li>磁头数: 即记录面数</li>
<li>柱面数: 即磁道数, 不同记录面的相同位置的磁道组成柱面</li>
<li>扇区数: 每个磁道上有多少扇区</li>
</ol></li>
</ol>
<p>磁记录原理: 磁头和磁性记录介质相对运动, 通过电磁转换完成读写</p>
<p>磁盘性能指标:</p>
<ol type="1">
<li>记录密度: 单位面积上记录的二进制信息量
<ol type="1">
<li>道密度: 磁盘半径方向单位长度的磁道数</li>
<li>位密度: 磁道单位长度能记录的二进制数据位数</li>
<li>面密度: 道密度 * 位密度</li>
</ol></li>
<li>磁盘容量
<ol type="1">
<li>非格式化容量: 磁盘记录表面可利用的磁化单元总数, 由道密度和位密度计算</li>
<li>格式化容量: 安装某种特点的记录格式所能存储信息的总量, 一般小于非格式化容量</li>
</ol></li>
<li><strong>平均存取时间</strong>: = 寻道时间(磁头找到目的磁道) + 旋转延迟时间(磁头找到目的扇区, 转半圈) + 传输时间(传输数据, 一般一个扇区, 即每转时间/每个磁道的扇区数)
<ol type="1">
<li>寻找时间 <span class="math inline">\(T_s = m*n+s\)</span> m为磁盘驱动器速度常数, n 为跨越的磁道数, s 为启动磁臂时间</li>
<li>旋转延迟时间 <span class="math inline">\(T_r = \frac 1 {2r}\)</span> r为磁盘旋转速度, (即转半圈需要的时间)</li>
<li>传输时间 <span class="math inline">\(T_t = \frac{b}{rN}\)</span> b为读写字节数, r 为磁盘转速, N 为同一个磁道上的字节数</li>
</ol></li>
<li>数据传输率: 设磁盘转速 r 转/秒, 每条磁道容量 N byte, 则数据传输率 D<sub>r</sub> = rN</li>
</ol>
<p>磁盘地址 主机向磁盘控制器发送地址 扇区地址可以划分为: 驱动器号, 柱面(磁道)号, 盘面号, 扇区号</p>
<p>硬盘工作流程: 寻址, 读盘, 写盘; 每个操作对应一个控制字 硬盘的读写是串行的, 不能同时读写, 也不能同时读(写)多组数据</p>
<p>磁盘调度算法(针对磁道, 磁道是从 1~N~1 是一个来回)</p>
<ol type="1">
<li>FCFS</li>
<li>最短寻找时间优先 SSTF (shortest seek time first) 可能饥饿</li>
<li>扫描算法 SCAN(电梯调度算法) 在当前移动方向上选择最近的进行服务</li>
<li><strong>循环扫描 C-SCAN</strong> 返回时移动至起始端而不进行任何服务</li>
<li>look 调度, 在扫描算法基础上, 不严格从磁盘的一端到另一端, 而是到达最远请求即可</li>
</ol>
<h5 id="磁盘阵列">磁盘阵列</h5>
<ul>
<li>raid0: 无冗余无校验, 并行访问</li>
<li>raid1: 镜像</li>
<li>raid2: 有纠错的海明码阵列</li>
<li>raid3: 位交叉奇偶校验</li>
<li>raid4: 块交叉奇偶校验</li>
<li>raid5: 无独立校验的奇偶校验, 恢复码分散到所有磁盘中</li>
</ul>
<h4 id="固态硬盘-ssd">3.4.2 固态硬盘 SSD</h4>
<p>以 page 为单位读写, 只有在 page所在的 block 全部擦除后才能对这个 page 写</p>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230531153412682.png?token=AKM4PT5KDLVE2LL776GWOOLEO34LK" alt="image-20230531153412682" /><figcaption aria-hidden="true">image-20230531153412682</figcaption>
</figure>
<p>磨损均衡:</p>
<ol type="1">
<li>动态磨损均衡: 写入数据时自动选择较新的闪存块</li>
<li>静态磨损均衡: 无数据写入时也会进行数据分配, 让老闪存块承担无需写的存储任务</li>
</ol>
<h3 id="高速缓冲存储器">3.5 高速缓冲存储器</h3>
<h4 id="程序访问的局部性原理">3.5.1 程序访问的局部性原理</h4>
<p>时间, 空间局部性</p>
<h4 id="cache-的基本工作原理">3.5.2 Cache 的基本工作原理</h4>
<p>基本单位: cache 和主存都被划分成相等的块, cache 中的块又叫 cache 行, 由若干 byte 组成</p>
<p>cache line -&gt; memory block</p>
<p><strong>cache line 缺失时, 从主存读取数据到 cache line 再访问 cacheline, 即访问两次, 缺页同理访问两次</strong></p>
<h4 id="cache-和主存的映射方式">3.5.3 Cache 和主存的映射方式</h4>
<p>地址映射</p>
<ol type="1">
<li><p>直接映射 主存的每一block 只能装入 cache 的唯一 line, 如果冲突就直接替换(无需替换算法) cache_line_number = MM_block_number mod cache_line_count 地址结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  address in MM</span><br><span class="line">─────────────────────────────────────►</span><br><span class="line">────► ────────────────► ─────────────► ─►</span><br><span class="line">tag  cache_line_number address_in_line valid</span><br></pre></td></tr></table></figure></li>
<li><p>全相联映射 每一块可以装入 cache 中的任何位置, cpu 访问 cache 时需要对所有 cache line 比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  address in MM</span><br><span class="line">───────────────────►</span><br><span class="line">────► ─────────────► ─►</span><br><span class="line">tag  address_in_line valid</span><br></pre></td></tr></table></figure></li>
<li><p>组相联映射 cache 分为若干组, 每个内存 block 可以存入固定组中的任意一行, 即组间直接映射, 组内全相联映射, 每组有 r 行, 称为 r 路组相联 例如1000 行 2 路组相联, 即 500 组每组 2 行, 2 行是全相联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  address in MM</span><br><span class="line">────────────────────────────────────────►</span><br><span class="line">────► ───────────────────► ─────────────► ─►</span><br><span class="line">tag  cache_group_number   address_in_line valid</span><br><span class="line">─────────────────────────►</span><br><span class="line">MM_block_number</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/202310111305805.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/202310111310110.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>使用哪种存疑</strong></p></li>
</ol>
<h4 id="cache-中主存块的替换算法">3.5.4 Cache 中主存块的替换算法</h4>
<ol type="1">
<li>随机算法</li>
<li>FIFO 算法</li>
<li><strong>近期最少用算法(LRU)</strong> 为每个 cache line 设置计数器, 计数器位数 = <strong>r 组相联路数</strong> 步骤:
<ol type="1">
<li>命中时, 计数值比其低的line 的计数器+1, 其余不变, 所在 line 计数器=0,</li>
<li>未命中但还有空闲 line 时, 新装 line 的计数器=0, 其余+1</li>
<li>未命中且无空闲line 时, 计数值为 2<sup>r</sup>-1 的块被淘汰, 计数值=0, 其余计数值+1</li>
</ol></li>
<li>最不经常用算法 LFU 每行设置一个计数器, 新建行计数器=0, 每访问一次计数器+1, 需要替换时将计数值最小行换出</li>
</ol>
<h4 id="cache-写策略"><strong>3.5.5 Cache 写策略</strong></h4>
<p>写命中</p>
<ol type="1">
<li>全写法 write through 当 cpu 对 cache 写命中时, 必须把数据同时写入 cache 和 MM
<ol type="1">
<li>写缓冲: 在 cache 和 MM 之间增加写缓冲, cpu 同时将数据写入 cache 和写缓冲中, 写缓冲再控制将内容写入 MM 写缓冲是一个 FIFO 队列</li>
</ol></li>
<li>回写法 write back 当 cpu 对 cache 写命中时, 只写入 cache, 只有当此 line 被换出时才写入 MM
<ol type="1">
<li>需要增加修改位(脏位, dirty bit, 1 代表修改过)</li>
</ol></li>
</ol>
<p>写不命中</p>
<ol type="1">
<li>写分配法 write allocate + 回写 加载MM 中的块到 cache(利用空间局部性), 然后更新这个 cache line 这样每次写不命中都要访存</li>
<li>非写分配法 non-write allocate +全写 只写入MM 不进行调块</li>
</ol>
<h3 id="虚拟存储器">3.6 虚拟存储器</h3>
<p>主存+辅存, 对应用程序透明</p>
<p>即, 主存作为辅存的 cache</p>
<h4 id="虚拟存储器的基本概念">3.6.1 虚拟存储器的基本概念</h4>
<p>将主存或辅存的地址空间统一编址</p>
<p>全相联映射, 回写法</p>
<p>cpu 使用虚拟地址时, 通过辅助硬件找出虚拟地址与实地址之间的对应关系, 如果已经在主存中就直接访问, 如果不在就将该字所在的 page(segment) 调入 MM 后再由 cpu 访问</p>
<h4 id="页式虚拟存储器">3.6.2 页式虚拟存储器</h4>
<p>以 page 为基本单位, 虚拟空间和主存空间都被划分成同样大小的page MM 的 page叫做实页, 页框; 虚拟空间的 page 叫做虚页 虚拟地址划分为字段: 虚页号, 页内地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  virtual address</span><br><span class="line">──────────────────────────────────►</span><br><span class="line">───────────────────► ─────────────►</span><br><span class="line">virtual_page_number address_in_page</span><br></pre></td></tr></table></figure>
<p>虚拟地址到物理地址的转换由页表实现, 页表记录虚页调入 MM 被安排的主存位置, 页表一般长久的保存在 MM 中</p>
<ol type="1">
<li><p>页表 page table entry in page table <code>key=virtual_page_number, valid_bit, dirty_bit, ref_bit, physical_page_address</code> valid_bit 有效位: 1 代表在内存中 dirty_bit: 回写法脏位 ref_bit: 引用位, 用于替换策略的计数器 页表基址寄存器存放进程的页表首地址, 根据页表: 将虚拟页号映射到物理页号, 再通过一样的页内地址找到物理地址 <code>vaddr = vpage_num + offset_in_page = ppage_num + offset_in_page</code></p></li>
<li><p><strong>快表 TLB (translation lookaside buffer) 一般由 SRAM 构成, TLB也是 cache 的一种</strong> 把经常访问的页表项存储在 TLB 中, TLB 是由高速缓冲组成的, 每个 cpu 有自己的 tlb(专门用于页表的高速缓存) TLB 通常采用全相联或组相联 注意: 不同的进程的虚拟地址会对应不同的物理地址, <strong>也就是说在进程切换时 tlb 需要 flush(全部失效)</strong>, 里面有机制识别进程 id 或者是否是内核空间不需要 flush</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual_address_number</span><br><span class="line">─────────────────────────► </span><br><span class="line">────► ───────────────────► ─────────────►</span><br><span class="line">tag  cache_group_number   page_table_record </span><br></pre></td></tr></table></figure></li>
<li><p>有 TLB 和 cache 的多级存储系统 查找时, TLB 和 page table 可以同时查找取较快的那一个的结果 此时一次虚拟地址数据的查找可能会有:</p>
<ol type="1">
<li>访存 1: 可能访问 MM 中的页表</li>
<li>访外存: 页表不在主存内(缺页异常)</li>
<li>访存 2: cache 不命中</li>
</ol></li>
</ol>
<h4 id="段式虚拟存储器">3.6.3 段式虚拟存储器</h4>
<p>segment 是按照程序的逻辑结构划分的, 各个 segment长度因程序而异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual address</span><br><span class="line">──────────────────────────────────►</span><br><span class="line">──────────────► ──────────────────►</span><br><span class="line">segment_number  address_in_segment     </span><br></pre></td></tr></table></figure>
<p>vaddr-&gt;paddr 由段表实现 entry in segment table <code>key=segment_number, valid_bit(1代表已装入主存), segment_begin_physical_addr, segment_length</code></p>
<p><code>vaddr = segment_num + offset_in_segment = segment_begin_physical_addr + offset_in_segment</code></p>
<p>段表基址寄存器</p>
<h4 id="段页式虚拟存储器">3.6.4 段页式虚拟存储器</h4>
<p>把程序按逻辑结构划分成 segment, 每个 segment 划分成 page</p>
<p>每个程序对应一个 segment table, 每个 segment 对应一个 page table, segment 长度是 page 的整数倍, segment 起点是 page 的起点 <figure class="highlight plaintext"><figcaption><span>address</span></figcaption><table><tr><td class="code"><pre><span class="line">virtual address</span><br><span class="line">──────────────────────────────────►</span><br><span class="line">───────────► ───────► ────────────►</span><br><span class="line">segment_num page_num address_in_page  </span><br></pre></td></tr></table></figure></p>
<p>先根据段表寄存器得到段表基址, 根据段号得到页表基址, 根据页号得到实页号, 根据页内地址得到物理地址</p>
<p>但是需要两次查表</p>
<h4 id="虚拟存储器与-cache-的比较">3.6.5 虚拟存储器与 Cache 的比较</h4>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230712134545176.png" alt="image-20230712134545176" /><figcaption aria-hidden="true">image-20230712134545176</figcaption>
</figure>
<h2 id="第4章指令系统">第4章指令系统</h2>
<h3 id="指令系统">4.1 指令系统</h3>
<p>指令系统是 ISA 最核心的部分</p>
<p>指令集体系结构 ISA(Instruction set architecture), 完整定义了软件和硬件之间的接口, 规定的内容主要包括: 指令格式, 数据类型和及格式, 操作数存放方式, 程序可访问寄存器, 存储空间大小和编址, 寻址方式, 指令执行过程的控制方式等.</p>
<h4 id="指令的基本格式">4.1.1 指令的基本格式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instruction</span><br><span class="line">────────────────────────────►</span><br><span class="line">───────────► ───────────────►</span><br><span class="line">operation   address  </span><br></pre></td></tr></table></figure>
<p>指令长度和机器字长无固定关系, 但一般为机器字长整数倍, 如: 单字长指令, 半字长指令, 双字长指令</p>
<p>按指令长度, 指令系统可分为定长指令系统, 变长指令系统</p>
<p>按操作数地址码数量可分为:</p>
<p><code>OP, a1, a2, a3, a4</code></p>
<ol type="1">
<li><p>零地址指令 通常操作数隐含与栈中, 结果再压入栈</p></li>
<li><p>一地址指令</p>
<p>OP(a1) -&gt; a1</p>
<p>(ACC)OP(a1) -&gt; ACC, 另一个操作数由 acc 累加器提供</p></li>
<li><p>二地址指令 (a1)OP(a2) -&gt; a1</p></li>
<li><p>三地址指令 (a1)OP(a2) -&gt; a3</p></li>
<li><p>四地址指令 (a1)OP(a2) -&gt; a3, a4 为下一条要执行的指令地址</p></li>
</ol>
<h4 id="定长操作码指令格式">4.1.2 定长操作码指令格式</h4>
<p>最高若干位(定长)为操作码 当计算机字长&gt;=32 时这是常规方法</p>
<h4 id="扩展操作码指令格式">4.1.3 扩展操作码指令格式</h4>
<p>指令字长一定, 操作码的长度可变</p>
<p>要注意: 不允许短码是长码的前缀, 操作码不能重复, 使用频率高的指令用短码</p>
<h4 id="指令的操作类型">4.1.4 指令的操作类型</h4>
<h3 id="指令的寻址方式">4.2 指令的寻址方式</h3>
<p><strong>形式地址 A, 有效地址 EA, 地址为 A 的地址的数值(A)</strong></p>
<h4 id="指令寻址和数据寻址">4.2.1．指令寻址和数据寻址</h4>
<ol type="1">
<li>指令寻址: 寻找下一条要执行的指令的地址
<ol type="1">
<li>顺序寻址: PC+1</li>
<li>跳跃寻址</li>
</ol></li>
<li>数据寻址: 操作数的地址 指令=<code>操作码, 寻址特征, 形式地址 A</code></li>
</ol>
<h4 id="常见的数据寻址方式">4.2.2 <strong>常见的数据寻址方式</strong></h4>
<ol type="1">
<li>隐含地址: 如零地址指令, 但是需要增加硬件配合隐含的操作数地址</li>
<li>立即数寻址 地址字段不是操作数地址而是操作数本身, 采用补码表示, <strong>取操作数不需要访问主存</strong></li>
<li>直接寻址 EA = A, 只需要一次访存, 但是 A 的位数限制了寻址范围</li>
<li>间接寻址 EA = (A), key 扩大寻址范围, 但是需要2次访存(多次间接寻址需要更多次访存)</li>
<li>寄存器寻址 EA = R, 操作数在寄存器 R 中, 不需要访存</li>
<li>寄存器间接寻址 EA = (R), 操作数地址在寄存器 R 中, 需要一次访存</li>
<li>相对寻址 EA = (PC)+A, 操作数地址由 PC 的值和 A 共同决定, 多用于转移指令 对于<code>jmp A</code>, 若此时 pc=x, 则执行后<code>pc = x+A+1</code></li>
<li>基址寻址 EA = (BR) + A, BR 是基址寄存器, 基址寄存器是面向操作系统的(如页表段表基址?), BR 中的值不变</li>
<li>变址寻址 EA = (IX)+A, IX 为变址寄存器, 变址寄存器是面向用户的, A 的值不变, 多用于循环</li>
<li>堆栈寻址 堆栈的读写单元地址由特定寄存器 SP 提供 (硬堆栈: 由寄存器组成, 软堆栈: 由内存的一部分组成) 如零地址指令</li>
</ol>
<h3 id="程序的机器级代码表示">4.3 程序的机器级代码表示</h3>
<h4 id="常用汇编指令介绍">4.3.1 常用汇编指令介绍</h4>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 39%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">项目</th>
<th style="text-align: left;">Intel风格(dosbox使用的是这种)</th>
<th style="text-align: left;">AT&amp;T风格</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">操作数顺序</td>
<td style="text-align: left;">目标操作数在前</td>
<td style="text-align: left;">源操作数在前</td>
</tr>
<tr class="even">
<td style="text-align: left;">寄存器</td>
<td style="text-align: left;"><strong>原样</strong></td>
<td style="text-align: left;">加%前缀</td>
</tr>
<tr class="odd">
<td style="text-align: left;">立即数</td>
<td style="text-align: left;"><strong>原样</strong></td>
<td style="text-align: left;">加$前缀</td>
</tr>
<tr class="even">
<td style="text-align: left;">16进制立即数</td>
<td style="text-align: left;">用后缀B与H分别表示二进制与十六进制 对于16进制字母开头的要加前缀0</td>
<td style="text-align: left;">加前缀0x</td>
</tr>
<tr class="odd">
<td style="text-align: left;">访问内存长度的表示</td>
<td style="text-align: left;">前缀BYTE PTR, WORD PTR, DWORD PTR和QWORD PTR表示字节,字,双字和四字</td>
<td style="text-align: left;">后缀b,w,l,q表示字节,字,双字和四字</td>
</tr>
<tr class="even">
<td style="text-align: left;">引用全局或静态变量var的值</td>
<td style="text-align: left;">[<strong>var</strong>]</td>
<td style="text-align: left;">var</td>
</tr>
<tr class="odd">
<td style="text-align: left;">引用全局或静态变量var的地址</td>
<td style="text-align: left;"><strong>var</strong></td>
<td style="text-align: left;">$var</td>
</tr>
<tr class="even">
<td style="text-align: left;">引用局部变量</td>
<td style="text-align: left;">需要基于栈指针（rsp）</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">绝对寻址</td>
<td style="text-align: left;">[imm]</td>
<td style="text-align: left;">imm</td>
</tr>
<tr class="even">
<td style="text-align: left;">间接寻址</td>
<td style="text-align: left;">[reg]</td>
<td style="text-align: left;">(%reg)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">基址相对寻址</td>
<td style="text-align: left;">[reg +imm]</td>
<td style="text-align: left;">imm(%reg)</td>
</tr>
<tr class="even">
<td style="text-align: left;">变址寻址</td>
<td style="text-align: left;">[base+index]</td>
<td style="text-align: left;">(base,index)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">变址寻址</td>
<td style="text-align: left;">imm[base+index]</td>
<td style="text-align: left;">imm(base,index)</td>
</tr>
<tr class="even">
<td style="text-align: left;">比例变址寻址</td>
<td style="text-align: left;">imm[base + index * scale ]</td>
<td style="text-align: left;">imm(base, index, scale)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scale只能是1,2,4,8其中的一个数字(1省略不写就是普通变址寻址)</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">代码注释</td>
<td style="text-align: left;">单行注释用;+注释内容。例如:mov rax, rdx ;这里是注释</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">注意</td>
<td style="text-align: left;">这里imm为立即数,base和index为寄存器,scale为伸缩量</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h4 id="过程调用的机器级表示">4.3.2 过程调用的机器级表示</h4>
<p>执行步骤: 假设 caller 调用 called</p>
<ol type="1">
<li>caller 将参数放在 called 能访问的地方</li>
<li>caller 将返回地址放在特定的地方, 控制转移给 called //call</li>
<li>called 保存 caller 现场, 为自己的非静态局部变量分配空间</li>
<li>执行 called</li>
<li>called 恢复 caller 现场, 将结果放在 caller 能访问的地方, 释放局部变量</li>
<li>called 取出返回地址, 控制转移给 caller //ret</li>
</ol>
<h4 id="选择语句的机器级表示">4.3.3 选择语句的机器级表示</h4>
<p><strong>标志位:(标志寄存器)</strong></p>
<ol type="1">
<li><p>zf: 零标志位, 相关指令执行后结果为 <strong>0</strong> 则 zf=1, 否则 0 mov ax,1 sub ax,1</p></li>
<li><p>pf: 奇偶标志位, <strong>结果中 1 为偶数</strong> pf=1, 否则 0</p></li>
<li><p>sf: 符号标志位, 结果为<strong>负</strong>, sf=1, 否则为 0, 无符号数计算 sf 恒等于 0</p></li>
<li><p>cf: 进位标志位, 在进行<strong>无符号</strong>数运算的时候，CF记录了运算结果的最高有效位向更高有效位向更高位的进位值/借位值,产生进位或向更高位借位都会使CF=1</p>
<p>加法 A+B: 进位输出为1，则CF标志位为1，反之则为0 <strong>减法</strong> A-B：[A]补+[-B]补：进位输出为1，则CF标志位为0，反之则为1（与加法相反） a 补 +(- b)补 原式化作 a-b+2^n； 此时再考察运算结果，不难发现，<strong>如果进位输出C_out为1，则表示该结果大于等于 2^n，即 a-b+2^n &gt;= 2^n，则 a-b &gt;= 0，计算时无需借位，借位标志 CF 为0</strong>。反之，当进位输出为0时，计算结果小于 2^n，a-b &lt; 0，计算时需要借位，借位标志 CF 为 1</p></li>
<li><p>of: 溢出标志位, <strong>有符号</strong>运算结果太大或太小 of=1, 否则 0</p></li>
<li><p><code>cmp, test</code>分别相当于 <code>sub, add</code>, 但是不会改变其他寄存器而 只改变标志位</p></li>
</ol>
<h4 id="循环语句的机器级表示">4.3.4 循环语句的机器级表示</h4>
<h3 id="cisc-和risc-的基本概念">4.4 CISC 和RISC 的基本概念</h3>
<h4 id="复杂指令系统计算机-cisc">4.4.1 复杂指令系统计算机 (CISC)</h4>
<p>特点</p>
<ol type="1">
<li>指令数目多(&gt;200)</li>
<li><strong>指令长度不固定</strong>, 格式多, 寻址方法多</li>
<li>可以访存的指令不受限制</li>
<li>指令使用频率相差大</li>
<li>指令执行时间相差大, 大多数指令需要多个时钟周期</li>
<li>控制器多采用微程序控制</li>
<li>难以优化编译</li>
</ol>
<h4 id="精简指令系统计算机-risc">4.4.2 精简指令系统计算机 (RISC)</h4>
<p>特点:</p>
<ol type="1">
<li><p>复杂指令由简单指令的组合实现</p></li>
<li><p>指令长度固定, 格式少, 寻址方式少</p></li>
<li><p>只有 load/store 指令访存, 其他指令都在寄存器之间进行</p></li>
<li><p><strong>cpu 中通用寄存器数量多</strong></p>
<blockquote>
<p>到底有多少个寄存器，和编译时的寄存器分配关系很大——寄存器太少的话，就要经常把寄存器上的内容倒腾到内存里去，这一来一回用时实在是太大了；寄存器太多的话，根本用不完，白白花了材料钱和制作费。Patterson在他的《<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=计算机体系结构&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A532791165%7D">计算机体系结构</a>：量化研究方法》这本教材里给出了一个寄存器数目的效用曲线，寄存器数目在16-32个之间，对于目前的编译技术而言是最优的选择。</p>
<p>所以回过头，我们来看RISCV，五位寄存器编码，刚好32个寄存器。</p>
<p>最后说一下CISC的寄存器。按照本篇回答的观点，寄存器在16-32个效用最高，再加上x86的历史遗留的寻址问题，导致x86不可能支持过多的通用寄存器——一是成本和收益不对等，二是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=通用寄存器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A532791165%7D">通用寄存器</a>会挤占别的特殊寄存器（比如寻址需要用到的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=基地址寄存器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A532791165%7D">基地址寄存器</a>等）。除此之外，寄存器过多，会使得<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=指令编码&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A532791165%7D">指令编码</a>难以设计，尤其是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=解码器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A532791165%7D">解码器</a>难以快速解码。</p>
<p>比如你原来有32个通用寄存器，然后你有一套用在32个寄存器上的CISC指令。现在突然变成64个寄存器，怎么在兼容原有指令的基础之上给新加的32个寄存器编码呢？一种思路是直接在所有指令后面加上几位，用来指示各个寄存器的“新旧”，这样设计的话，本来就复杂的CISC解码器就更复杂了...另外一种思路是在原来的那套指令上就留好冗余，用于扩展，但这样浪费太大，一条指令可能也就32到64位，里面有三到四位留作冗余...</p>
</blockquote></li>
<li><p>risc 一定采用流水线技术, 大部分指令在一个时钟周期内完成</p></li>
<li><p>以硬布线控制为主</p></li>
<li><p>重视编译优化工作</p></li>
</ol>
<h4 id="cisc-和risc-的比较">4.4.3 CISC 和RISC 的比较</h4>
<p>risc 的优点:</p>
<ol type="1">
<li>risc 更能利用芯片面积, 硬布线控制比微程序控制占用面积小</li>
<li>risc 更能提高运算速度</li>
<li>risc 便于设计</li>
<li>risc 利于编译代码优化</li>
</ol>
<h2 id="第5章中央处理器">第5章中央处理器</h2>
<h3 id="cpu-的功能和基本结构">5.1 CPU 的功能和基本结构</h3>
<h4 id="cpu-的功能">5.1.1 CPU 的功能</h4>
<p>由运算器和控制器组成</p>
<p>具体功能有:</p>
<ol type="1">
<li>指令控制: 取指令, 分析指令, 执行指令</li>
<li>操作控制: 产生指令的操作信号</li>
<li>时间控制: 为每条指令按时间顺序昌盛控制信号</li>
<li>数据加工: 数据算数和逻辑运算</li>
<li>中断处理</li>
</ol>
<h4 id="cpu-的基本结构">5.1.2 CPU 的基本结构</h4>
<ol type="1">
<li>运算器
<ol type="1">
<li>算数逻辑单元: 算数逻辑运算</li>
<li>暂存寄存器: 暂存MM 来的数据</li>
<li>累加寄存器ACC: 通用寄存器, 暂时存放 ALU 运算的结果</li>
<li>通用寄存器组, ax, bx, cx, dx, sp 等</li>
<li>程序状态字寄存器 PSW</li>
<li>移位器</li>
<li>计数器: 控制乘除运算操作步数</li>
</ol></li>
<li>控制器
<ol type="1">
<li>程序计数器 PC</li>
<li>指令寄存器IR: 保存当前在执行的指令(CIR current instruction register)</li>
<li>指令译码器</li>
<li>存储器地址寄存器 MAR</li>
<li>存储器数据寄存器 MDR</li>
<li>时序系统: 产生时序信号</li>
<li>微操作信号发生器, 根据 IR PSW 时序信号产生控制信号, 包括组合逻辑型和存储逻辑型两种</li>
</ol></li>
</ol>
<h3 id="指令执行过程">5.2 指令执行过程</h3>
<h4 id="指令周期">5.2.1 指令周期</h4>
<p>指令周期定义: cpu从主存取出并执行一条指令的时间称为指令周期, 通常用机器周期表示, 一个机器周期代表一个基本操作所需要的时间(如取指令一个时钟周期, 执行指令一个时钟周期等), 一个机器周期包含若干时钟周期, 时钟周期是 cpu 操作的基本单位</p>
<p>完整的指令周期: 取指周期, 间址周期, 执行周期, 中断周期(处理中断请求)</p>
<p>对应四个标志触发器: FE, IND, EX, INT(fetch, indirect, execute, Interupt)</p>
<h4 id="指令周期的数据流">5.2.2 <strong>指令周期的数据流</strong></h4>
<ol type="1">
<li><p>取指周期</p>
<p><strong>根据 PC 取指令从 MM 到 IR, PC+=1</strong></p>
<ol type="1">
<li>PC -&gt; MAR -&gt; address bus -&gt; MEM</li>
<li>CU -读命令-&gt; control bus -&gt; MEM</li>
<li>MEM -&gt; data bus -&gt; MDR -&gt; IR</li>
<li>CU -控制信号-&gt; PC+1</li>
</ol></li>
<li><p>间址周期 <strong>根据 IR 内地址取数据从 MM 到 MDR</strong></p>
<p>get EA</p>
<ol type="1">
<li>IR address part -&gt; MAR -&gt; address bus -&gt; MEM</li>
<li>CU -read-&gt; control bus -&gt; MEM</li>
<li>MEM -&gt; data bus -&gt; MDR</li>
</ol></li>
<li><p>执行周期</p>
<p><strong>根据 IR 中的操作码从 ALU 获得执行结果</strong></p></li>
<li><p>中断周期</p>
<p>处理中断请求, 假设断点存入堆栈</p>
<ol type="1">
<li>CU -&gt; SP-1, SP -&gt; MAR -&gt; address bus -&gt; MEM 找到栈顶位置</li>
<li>CU -write-&gt; control bus -&gt; MM 准备写</li>
<li>PC -&gt; MDR -&gt; data bus -&gt; MEM 将 PC 值存入栈顶</li>
<li>CU -&gt; PC 中断程序入口地址存入 PC 开始执行</li>
</ol></li>
</ol>
<h4 id="指令执行方案">5.2.3 指令执行方案</h4>
<ol type="1">
<li>单指令周期 所有指令用相同执行时间完成, 每条指令都在一个时钟周期内完成</li>
<li>多指令周期 对不同指令用不同的执行步骤, 所需时钟周期也不同</li>
<li>流水线方案 让多条指令同时执行单处于不同执行步骤中</li>
</ol>
<h3 id="数据通路的功能和基本结构">5.3 数据通路的功能和基本结构</h3>
<h4 id="数据通路的功能">5.3.1 数据通路的功能</h4>
<p>数据通路由 CU 控制</p>
<h4 id="数据通路的基本结构">5.3.2 数据通路的基本结构</h4>
<p>cpu 内:</p>
<ol type="1">
<li>cpu 内部单总线方式 所有寄存器输入输出连在同一个 bus 上, 会出现数据冲突</li>
<li>cpu 内部多总线方式 多条 bus</li>
<li>专用数据通路方式 根据指令执行过程中的数据流动方向安排线路, 避免冲突, 但硬件量较大</li>
</ol>
<p>例子</p>
<ol type="1">
<li><p>寄存器到寄存器 <code>(PC) -&gt; MAR</code></p></li>
<li><p>MM 与 CPU: 读指令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(PC) -&gt; MAR</span><br><span class="line">1 -&gt; R //read signal</span><br><span class="line">MEM(MAR) -&gt; MDR</span><br><span class="line">(MDR) -&gt; IR</span><br></pre></td></tr></table></figure></p></li>
<li><p>运算 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(MDR) -&gt; MAR //EA 存入 MAR</span><br><span class="line">1 -&gt; R //read signal</span><br><span class="line">MEM(MAR) -&gt; MDR</span><br><span class="line">(MDR) -&gt; Y //first param</span><br><span class="line">(ACC) + (Y) -&gt; Z //result in Z</span><br><span class="line">(Z) -&gt; ACC //result in ACC</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="控制器的功能和工作原理">5.4 控制器的功能和工作原理</h3>
<h4 id="控制器的结构和功能">5.4.1 控制器的结构和功能</h4>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/202310191118737.png" alt="image-20230602162415336.png" /><figcaption aria-hidden="true">image-20230602162415336.png</figcaption>
</figure>
<p>控制器的主要功能:</p>
<ol type="1">
<li>从 MM 取指令, 指出下一条指令的位置</li>
<li>指令译码, 产生控制信号</li>
<li>控制数据流动方向</li>
</ol>
<h4 id="硬布线控制器">5.4.2 硬布线控制器</h4>
<p>CU 输入:</p>
<ol type="1">
<li>译码产生的指令信息</li>
<li>时序系统产生的机器周期信号和节拍信号(节拍宽度对应一个时钟周期, 机器周期一般以存取周期作为基准时间)</li>
<li>执行单位的反馈信息, 即状态标志</li>
<li>其他如中断请求, DMA 请求</li>
</ol>
<p>微操作实现</p>
<ol type="1">
<li>取指令操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(PC) -&gt; MAR</span><br><span class="line">1 -&gt; R</span><br><span class="line">MEM(MAR) -&gt; MDR</span><br><span class="line">(MDR) -&gt; IR</span><br><span class="line">OP PART OF IR -&gt; CU</span><br><span class="line">(PC)+1 -&gt; PC</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>间址周期操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDRESS PART OF IR -&gt; MAR</span><br><span class="line">1 -&gt; R</span><br><span class="line">MEM(MAR) -&gt; MDR</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>执行周期非访存操作</li>
</ol>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLA, COM, SHR, CSL, STP 等</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li>执行周期访存操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ADD X</span><br><span class="line">ADDRESS PART OF IR -&gt; MAR, 1-&gt; R</span><br><span class="line">MEM(MAR) -&gt; MDR</span><br><span class="line">(ACC) + (MDR) -&gt; ACC</span><br><span class="line">// STA X 存数指令</span><br><span class="line">ADDRESS PART OF IR -&gt; MAR, 1-&gt; W</span><br><span class="line">(ACC) -&gt; MDR</span><br><span class="line">(MDR) -&gt; MEM(MAR)</span><br><span class="line">// LDA X 取数指令</span><br><span class="line">ADDRESS PART OF IR -&gt; MAR, 1-&gt; R</span><br><span class="line">MEM(MAR) -&gt; MDR</span><br><span class="line">(MDR) -&gt; ACC</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>执行周期转移操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// JMP X 无条件转移</span><br><span class="line">ADDRESS PART OF IR -&gt; PC</span><br><span class="line">// BAN X 条件转移(负则转移)???</span><br><span class="line">A0* ADDRESS PART OF IR + ^A0*(PC) -&gt; PC</span><br></pre></td></tr></table></figure>
<p>cpu 控制方式</p>
<ol type="1">
<li>同步控制方式 所有控制信号来自统一时钟, 以最长最复杂信号为标准, 电路简单但速度慢</li>
<li>异步控制方式 各个部件以固有速度工作, 通过应答方式联络, 电路复杂</li>
<li>联合控制方式 大部分同步控制, 小部分异步控制</li>
</ol>
<p>设计步骤?</p>
<h4 id="微程序控制器">5.4.3 微程序控制器</h4>
<p>每条机器指令编写成一个微程序(微程序种类数量一般为机器指令种类数量+取指, 间址, 中断等微程序), 每个微程序包含若干微指令, 每条微指令对应若干微操作命令. 这些微程序存储在一个控制存储器中</p>
<p>微操作是计算机中最基本不可再分解的操作 微命令是控制部件向执行部件发出的各种控制命令 微操作与微命令一一对应 微命令之间有互斥和相容</p>
<p>微指令是若干微命令的集合, 存放微指令的控制存储器的单元地址称为微地址, 一条微指令包含至少两部分:</p>
<ol type="1">
<li>操作控制字段: 微操作码字段, 用于产生各种操作控制信号</li>
<li>顺序控制字段: 微地址码字段, 用于控制产生下一条微指令地址</li>
</ol>
<p>微周期是执行一条微指令所需的时间, 通常为一个时钟周期</p>
<p><strong>控制存储器 CM(control memory): 用于存放微程序, 在 cpu 内部, 用 rom 实现</strong></p>
<p>微程序控制器的组成:</p>
<ol type="1">
<li>控制存储器 CM</li>
<li>微指令寄存器 CMDR(应该叫控制存储器数据寄存器?)</li>
<li>微地址形成部件: 用于产生初始和后继微地址</li>
<li>微地址寄存器 CMAR: 接收微地址, 为在 CM 中读取微指令做准备(应该叫控制存储器地址寄存器?)</li>
</ol>
<p>微程序控制器的工作过程:</p>
<ol type="1">
<li>自动将取指微程序的入口地址送到 CMAR, 根据 CMAR 从 CM 读出微指令送入 CMDR, 取指微程序执行, 执行完后主存中的机器指令存入 IR</li>
<li>根据 IR 的操作码字段, 通过微地址形成部件产生对应微程序的入口地址送入 CMAR</li>
<li>从 CM 逐条取出微指令并执行</li>
<li>完成机器指令后, 回到 1, 重复</li>
</ol>
<p><strong>微指令编码方式</strong></p>
<ol type="1">
<li>直接编码 无需译码, 微指令的微命令字段中每一个 bit 都代表一个微命令 简单, 执行快, 操作并行性好 但微指令字太长, 导致 CM 容量大</li>
<li><strong>字段直接编码</strong> 将微指令的微命令字段分成若干字段, 将互斥的微命令放在同一字段中, 相容放在不同字段中, 对每个字段进行译码 缩短了字长, 但是慢</li>
<li>字段间接编码 一个字段的某些微命令需要另一个字段中的某些微命令来解释 进一步缩短字长, 但削弱了并行性</li>
</ol>
<p>微指令地址形成方式</p>
<ol type="1">
<li>由微指令的地址字段直接给出, 又叫断定方式</li>
<li>根据机器指令的操作码形成, 由微地址形成部件产生</li>
<li>增量计数 (CMAR) + 1 =&gt; CMAR</li>
<li>根据各种标志决定分支转移地址</li>
<li>通过测试网络形成</li>
<li>由硬件直接产生(例如刚开机执行取指令微程序)</li>
</ol>
<p>微指令格式</p>
<ol type="1">
<li><p>水平型微指令 直接编码, 字段直接编码, 字段间接编码, 混合编码都属于水平型 <code>A1, A2... 判断测试字段, 后继地址字段</code></p></li>
<li><p>垂直型微指令 <code>微操作码, 目的地址, 源地址</code> 由微操作码指定微指令功能, 一条垂直指令只能执行一种基本操作</p></li>
<li><p>混合型</p>
<p>比较:</p>
<ol type="1">
<li>水平: 并行好, 速度快, 灵活性强, 执行一条指令需要的时间短, 用户难以掌握, 微指令字长微程序短</li>
<li>垂直: 并行差, 一条指令时间长, 微指令字短微程序长, 用户易掌握</li>
</ol></li>
</ol>
<p>设计?</p>
<h3 id="异常和中断机制">5.5 异常和中断机制</h3>
<h4 id="异常和中断的基本概念">5.5.1 异常和中断的基本概念</h4>
<p>CPU 内部产生的意外事件(与正在执行的指令相关的同步事件)叫异常, 内中断</p>
<p>cpu 外部设备向 cpu 发出的中断请求(通常用于输入输出)叫中断, 外中断</p>
<h4 id="异常和中断的分类">5.5.2 异常和中断的分类</h4>
<p>分类问题:[https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt]???和王道不符, 采用 stackoverflow???</p>
<ol type="1">
<li><p>exception 包括以下3种, 是 cpu 内部的问题</p>
<ol type="1">
<li><p>trap(也可以叫访管指令?应该是一种东西) A <strong><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Kernel_trap">trap</a></strong> is an <strong>exception</strong> in a user process. <strong>It's the usual way to invoke a kernel routine (a <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/System_call">system call</a>)</strong> because those run with a higher priority than user code. Handling is synchronous (so the user code is suspended and continues afterwards). In a sense they are "<strong>active</strong>" - most of the time, the code expects the trap to happen and relies on this fact. trap 后会执行 trap 之后的语句</p></li>
<li><p>fault 故障 A <strong>fault</strong> is an exception that can generally be corrected and that, once corrected, allows the program to be restarted with no loss of continuity. When a fault is reported, the processor restores the machine state to the state prior to the beginning of execution of the faulting instruction. The return address (saved contents of the CS and EIP registers) for the fault handler points to the faulting instruction, rather than to the instruction following the faulting instruction. fault 之后会再次执行 fault 的语句(如果处理不了 fault 会手动增加 return address 得到 trap-like 行为), eg: page fault</p></li>
<li><p>abort</p>
<p>An <strong>abort</strong> is an exception that does not always report the precise location of the instruction causing the exception and does not allow a restart of the program or task that caused the exception. Aborts are used to report <strong>severe errors, such as hardware errors and inconsistent or illegal values in system tables.</strong></p></li>
</ol></li>
<li><p>interrupt, 是 cpu 外部的问题 The term Interrupt is usually reserved for hardware interrupts. They are program control interruptions caused by <strong>external hardware events</strong>. Here, external means <strong>external to the CPU</strong>. Hardware interrupts usually come from many different sources such as timer chip, peripheral devices (keyboards, mouse, etc.), I/O ports (serial, parallel, etc.), disk drives, CMOS clock, expansion cards (sound card, video card, etc). That means hardware interrupts almost never occur due to some event related to the executing program.</p>
<ol type="1">
<li>可屏蔽中断 通过可屏蔽中断请求线 INTR 向cpu 发送的中断请求 cpu 可以在中断控制器中设置相应屏蔽词来屏蔽</li>
<li>不可屏蔽中断 通过专门的不可屏蔽中断请求线 NMI 向 cpu 发出的中断请求</li>
</ol></li>
</ol>
<p>硬件中断: interrupt + abort, 软件中断: trap + fault</p>
<p>例子:</p>
<ol type="1">
<li>interrupt: io 请求, 时钟中断(时间片)</li>
<li>exception
<ol type="1">
<li>trap: 用户态到核心态</li>
<li>fault: <strong>page fault缺页</strong>, 非法操作码, 除 0, 运算溢出</li>
<li>abort: 控制器出错, 存储器校验错</li>
</ol></li>
</ol>
<p>关于 trap 和 systemcall</p>
<ol type="1">
<li>Traps: A trap is an interrupt generated by the CPU <strong>when a user-level program attempts to execute a privileged instruction or encounters an error.</strong> When a trap occurs, the CPU transfers control to the kernel and executes a trap handler. The trap handler checks the type of trap and takes appropriate action, such as terminating the program or performing a privileged operation on behalf of the program.</li>
<li>System calls: <strong>A system call is a request made by a user-level program to the OS to perform a privileged operation</strong>, such as reading from or writing to a file or allocating memory. To make a system call, the program executes a special instruction that triggers a software interrupt. The OS then transfers control to the kernel and executes a system call handler. The system call handler checks the type of system call and takes appropriate action, such as reading from a file or allocating memory.</li>
<li>Traps and system calls are similar in that they both involve transferring control to the kernel to perform privileged operations. <strong>However, traps are usually generated automatically by the CPU when a program encounters an error or attempts to execute a privileged instruction, while system calls are initiated by the program itself to request privileged operations.</strong></li>
</ol>
<h4 id="异常和中断响应过程">5.5.3 异常和中断响应过程</h4>
<p><strong>当遇到中断时步骤:</strong></p>
<ol type="1">
<li>关中断 禁止响应新的中断, 通常设置 中断允许 IF 触发器来实现, 1 为开 0 为关(不响应)</li>
<li>保存断点和程序状态 返回地址和程序状态字寄存器 PSWR 保存到栈或者特定寄存器中</li>
<li>识别异常和中断 异常大多软件识别, 中断即可软件识别又可硬件识别
<ol type="1">
<li>软件识别是 cpu 内设置一个异常状态寄存器, 用于记录异常原因, 操作系统使用查询程序查询此寄存器来检测种类, 然后转到内核的处理程序</li>
<li>硬件识别, 又叫向量中断, 中断处理程序的首地址叫做中断向量, 所有中断向量被放在中断向量表中</li>
</ol></li>
<li>转到响应处理程序</li>
<li>返回</li>
</ol>
<p>其中 1-3 为 cpu 的操作</p>
<p><strong>单级中断的过程: 其中 1~3 硬件完成, 4~8 中断服务程序完成</strong></p>
<ol type="1">
<li>关中断</li>
<li>保存断点</li>
<li>识别中断源</li>
<li>保存现场(<strong>包括: PC, 标志寄存器, 与之对比, 子程序调用只要求保存 PC</strong>, 中断的通用寄存器保存由操作系统执行(而不是中断服务程序))</li>
<li>中断事件处理</li>
<li>恢复现场</li>
<li>开中断</li>
<li>中断返回</li>
</ol>
<p><strong>中断隐指令</strong>指<strong>CPU响应中断之后，经过某些操作，转去执行中断服务程序的一种操作</strong> CPU收到中断信息后，首先引发中断过程，由硬件完成，没有指令对应。即中断隐指令。以8086为例，中断过程做的事：取中断类型码N；EFLAGS进栈；TF=0，IF=0；CS进栈；IP进栈；设置CS、IP为中断处理程序的入口。 而中断处理程序要做的第一件事就是保存通用寄存器的内容。 进一步，在保护模式中，不同特权级对应不同特权栈，用户态下中断处理通常进入内核态，导致栈的切换，此时程序断点就保存在内核栈了；内核态的中断处理还是在内核态，故在内核栈。所以，程序断点在内核栈中。</p>
<p>保护模式下的中断操作(详细)</p>
<ol type="1">
<li>CPU检查是否有中断/异常信号 CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量。 对于异常和系统调用那样的软中断，因为中断向量是直接给出的，所以和通过IRQ（中断请求）线发送的硬件中断请求不同，不会再专门去取其对应的中断向量。</li>
<li>根据中断向量到IDT(中断描述符表 Interrupt Descriptor Table)表中取得处理这个向量的中断程序的段选择符</li>
<li>根据取得的段选择符到GDT(Global Descriptor Table)中找相应的段描述符, 此时CPU就得到了中断服务程序的起始地址。 这里，CPU会根据当前cs(code segment)寄存器里的CPL和GDT的段描述符的DPL，以确保中断服务程序是高于当前程序的，如果这次中断是编程异常（如：int 80h系统调用），那么还要检查CPL和IDT表中中断描述符的DPL，以保证当前程序有权限使用中断服务程序，这可以避免用户应用程序访问特殊的陷阱门和中断门[3]。https://zhuanlan.zhihu.com/p/590066420?utm_id=0</li>
<li>CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址 CPU会根据CPL和中断服务程序段描述符的DPL信息确认是否发生了特权级的转换，比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的首地址存在TR寄存器中）里取得该程序的内核栈地址，即包括ss和esp的值，并立即将系统当前使用的栈切换成新的栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的ss,esp压到新栈中保存起来。</li>
<li>保护当前程序的现场 CPU开始利用栈保护被暂停执行的程序的现场：依次压入当前程序使用的<strong>eflags，cs，eip，errorCode</strong>（如果是有错误码的异常）信息。(<strong>不包括通用寄存器</strong>)</li>
<li>跳转到中断服务程序(也叫中断处理子程序, 从此开始属于软件, 也是操作系统的范畴)的第一条指令开始执行 CPU利用中断服务程序的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务程序。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</li>
<li>中断服务程序处理完毕，恢复执行先前中断的程序 在每个中断服务程序的最后，必须有中断完成返回先前程序的指令，这就是iret（或iretd）。程序执行这条返回指令时，会从栈里弹出先前保存的被暂停程序的现场信息，即eflags,cs,eip重新开始执行</li>
</ol>
<h3 id="指令流水线">5.6 指令流水线</h3>
<h4 id="指令流水线的基本概念">5.6.1 指令流水线的基本概念</h4>
<p>时间并行: 一个任务分成多个阶段在不同功能部件上执行</p>
<p>空间并行: 一个处理机内设置多个执行相同功能的部件, 这样的处理机叫超标量处理机</p>
<p>指令流水线:</p>
<ol type="1">
<li>阶段: 取指 IF, 译码/读寄存器 ID, 执行/计算地址 EX, 访存 MEM, 写回 WB</li>
<li>实现流水线的指令集的条件
<ol type="1">
<li>指令长度尽量一致</li>
<li>指令规格尽量规整</li>
<li>使用 load/store 指令</li>
<li>数据指令对齐存放</li>
</ol></li>
<li>流水线的表示方法 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230603144941411.png" alt="image-20230603144941411" /></li>
</ol>
<h4 id="流水线的基本实现-对单周期指令">5.6.2 流水线的基本实现 (对单周期指令)?</h4>
<h4 id="流水线的冒险与处理">5.6.3 流水线的冒险与处理</h4>
<p>流水线冒险: 在流水线中遇到情况使流水线无法正确执行后续指令引起阻塞或停顿</p>
<ol type="1">
<li><p>结构冒险(资源冲突) 多条指令同时争夺同一资源 解决方法:</p>
<ol type="1">
<li>前一指令访存时, 后一指令暂停一个时钟周期</li>
<li>单独设置数据存储器和指令存储器, 避免冲突</li>
</ol></li>
<li><p>数据冒险 下一条指令会用到当前指令的计算结果 分类</p>
<ol type="1">
<li>写后读 RAW: 当前写完, 下一条才能读</li>
<li>读后写 WAR: 当前读完, 下一条才能写</li>
<li>写后写 WAW: 当前写完, 下一条才能写</li>
</ol>
<p>解决方法</p>
<ol type="1">
<li>把数据相关和后续指令都暂停几个时钟周期, 又可分为硬件阻塞(stall) 和软件插入 (NOP)方法</li>
<li>设置相关专用通路(数据旁路), 不等待当前指令, 下一条指令直接从 ALU 读取计算结果避免暂停</li>
<li>编译优化指令顺序</li>
</ol></li>
<li><p>控制冒险 转移, 调用, 返回会改变 PC 的值, 造成断流 解决方法</p>
<ol type="1">
<li>分支预测(分静态动态), 尽早生成转移目标地址</li>
<li>预取转移成功和不成功两个控制流方向上的目标指令</li>
<li>加快提前生成条件码</li>
<li>提高转移方向预测率</li>
</ol></li>
</ol>
<h4 id="流水线的性能指标">5.6.4 流水线的性能指标</h4>
<p>吞吐率 <span class="math inline">\(TP=\frac n {T_k}\)</span> n 是任务数, T<sub>k</sub> 是完成 n 个任务用的总时间, k 是流水线段数, <span class="math inline">\(\Delta t\)</span>是时钟周期, 在理想连续情况下, 流水线的吞吐率: <span class="math inline">\(TP = \frac n {(k+n-1)\Delta t}\)</span></p>
<p>流水线加速比 <span class="math inline">\(S = \frac {T_0}{T_k}\)</span> T<sub>0</sub>为不使用流水线的时间, 理想情况下: <span class="math inline">\(S = \frac {kn\Delta t}{(k-n+1)\Delta t} = \frac{kn}{k+n-1}\)</span></p>
<h4 id="高级流水线技术">5.6.5 高级流水线技术</h4>
<ol type="1">
<li><p><strong>超标量流水线技术</strong>(动态多发射技术)</p>
<p>每个时钟周期并发多条独立指令, 为此需要多个处理部件 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230603150902012.png" alt="image-20230603150902012" /></p></li>
<li><p>超长指令字技术(静态多发射技术)</p>
<p>由编译程序挖掘指令潜在的并行性, 将多条可并行指令组合成一条由多操作码字段的超长指令字, 为此需要多个处理部件</p></li>
<li><p>超流水线技术 提高流水线 主频 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230603151217502.png" alt="image-20230603151217502" /></p></li>
</ol>
<h3 id="多处理器的基本概念">5.7 多处理器的基本概念</h3>
<h4 id="sisdsimd-mimd-的基本概念">5.7.1 SISD、SIMD、 MIMD 的基本概念</h4>
<ol type="1">
<li>单指令流单数据流 SISD 一个处理器一个存储器</li>
<li>单指令流多数据流 SIMD 数据并行, 一个指令控制部件, 多个处理单元, 处理单元虽然执行相同指令, 但处理不同数据, 例如循环 向量处理器是 SIMD 的变体, 是一种实现了直接操作向量指令集的 cpu</li>
<li>多指令流单数据流 MISD 不存在这样的计算机</li>
<li>多指令流多数据流 MIMD
<ol type="1">
<li>多计算机系统(消息传递 MIMD) 每个计算机节点有各自私有的存储器, 独立的储存地址, 不能通过存取指令访问其他计算机节点, 而需要消息传递</li>
<li>多处理器系统(共享存储多处理器 SMP) 共享的单一地址空间</li>
</ol></li>
</ol>
<h4 id="硬件多线程的基本概念">5.7.2 硬件多线程的基本概念</h4>
<p>为每个线程提供单独的通用寄存器组, 单独的PC</p>
<p>实现方式有:</p>
<ol type="1">
<li><p>细粒度多线程</p>
<p>多个线程轮流交叉执行指令, 线程之间指令不相关, 可以乱序并行执行, 处理器能在每个时钟周期切换线程</p></li>
<li><p>粗粒度多线程 仅在一个线程出现较大开销的阻塞时才切换线程(如 cache 缺失), 切换时必须重载流水线, 开销更大</p></li>
<li><p>同时多线程 SMT 同一时钟周期中, 发射多个不同线程的多条指令执行</p></li>
</ol>
<h4 id="多核处理器的基本概念">5.7.3 多核处理器的基本概念</h4>
<p>多个处理单元集成到单个 cpu, 每个处理单元为一个核 core, 每个 core 有自己的 cache 也可以共享一个 cache, 核一般对称并共享主存储器</p>
<h4 id="共享内存多处理器的基本概念">5.7.4 共享内存多处理器的基本概念</h4>
<p>共享单一物理地址空间的多处理器叫共享内存多处理器 SMP 处理器通过存储器中的共享变量通信</p>
<p>分类:</p>
<ol type="1">
<li>统一存储访问(UMA)多处理器: 每个存储器对所有存储单元访问时间是大致相同的</li>
<li>非统一存储访问(NUMA)多处理器: 某些访存请求比其他快</li>
</ol>
<h2 id="第6章-总线">第6章 总线</h2>
<h3 id="总线概述">6.1 总线概述．</h3>
<h4 id="总线基本概念">6.1.1 总线基本概念</h4>
<p>总线是能为多个部件分时共享的公共信息传送路线</p>
<p>总线设备:</p>
<ol type="1">
<li>主设备: 获得总线控制权的设备</li>
<li>被主设备访问的设备, 只能响应从主设备发来的总线命令</li>
</ol>
<h4 id="总线的分类">6.1.2 总线的分类</h4>
<ol type="1">
<li>片内总线 cpu内: 寄存器与寄存器, 寄存器与 ALU 之间的公共连接线</li>
<li>系统总线 各功能部件(cpu, MM, IO)之间相互连接的总线, 按传输信息内容分为
<ol type="1">
<li>数据总线: 双向传输, 位数与机器字长存储字长有关, 数据通路是数据流经的路径, 数据总线是承载的媒介</li>
<li>地址总线: 单向总线, 位数与主存地址空间大小有关</li>
<li>控制总线: cpu 发出的控制命令和外设主存返回给 cpu 的反馈信号</li>
</ol></li>
<li>io 总线 通过 io 接口与系统总线相联, 目的是将低速设备与高速总线分离 <strong>其中控制总线, 地址总线是 cpu 到 io 单向, 数据总线是双向</strong></li>
<li>通信总线(外部总线) 计算机系统之间传输信息的总线</li>
</ol>
<p>按时序控制分为同步总线, 异步总线</p>
<p>按数据传输格式分为并行总线, 串行总线</p>
<h4 id="系统总线的结构">6.1.3 系统总线的结构</h4>
<ol type="1">
<li>单总线结构 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230603153725019.png" alt="image-20230603153725019" /></li>
<li>双总线结构 一条是主存总线, 连接 cpu 主存和通道, 一条是 io 总线, 连接外部设备和通道 <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230603153825182.png" alt="image-20230603153825182" /></li>
<li>三总线结构 主存总线, io 总线, 直接内存访问总线(DMA) <img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230603153910940.png" alt="image-20230603153910940" /></li>
</ol>
<h4 id="常见的总线标准">6.1.4 常见的总线标准</h4>
<ol type="1">
<li>ISA industry standard architecture</li>
<li>EISA extended industry standard architecture, 为配合 32bit'cpu, 兼容 ISA</li>
<li>VESA video electronics standards association, 32bit 局部总线, 传送图像</li>
<li>PCI peripheral component interconnect, 外部设备互联, 高性能 32bit/64bit 总线, 如显卡声卡网卡, 支持即插即用, pci 总线是一个与处理器时钟无关的外围高速总线, 是局部总线</li>
<li>AGP accelerated graphics port, 传输视频三维图形, 局部总线</li>
<li>PCI-E PCI-express, 最新</li>
<li>RS-232C, 串行通信总线, 应用于串行二进制交换的数据终端设备 DTE 和数据通信设备 DCE</li>
<li>USB, universal <strong>serial</strong> bus, io 总线, 设备总线, 热插拔, 串行(serial)</li>
<li>PCMCIA personal computer memory card international association, 扩展功能的小型插槽</li>
<li>IDE integrated drive electronics, ATA, 硬盘和光驱</li>
<li>SCSI small computer system interface, 硬盘软驱</li>
<li>SATA serial advanced technology attachment, 出行硬件驱动器接口, 硬盘接口规范</li>
</ol>
<h4 id="总线的性能指标">6.1.5 总线的性能指标</h4>
<ol type="1">
<li>总线传输周期: 一次总线操作需要的时间 包括: 申请阶段, 寻址阶段, 传输阶段, 结束阶段. 由若干总线时钟周期组成</li>
<li>总线时钟周期: 就是机器的时钟周期</li>
<li>总线工作频率: 1/总线传输周期</li>
<li>总线时钟频率: 1/总线时钟周期</li>
<li>总线宽度: 总线位宽</li>
<li>总线带宽: 总线最大传输速率, byte/s, <span class="math inline">\(总线带宽 = 总线工作频率 * (总线宽度/8)\)</span></li>
<li>总线复用: 一种信号线在不同时间传输不同信息</li>
<li>信号线数</li>
</ol>
<h3 id="总线事务和定时">6.2 总线事务和定时</h3>
<h4 id="总线事务">6.2.1 总线事务</h4>
<p>从请求总线到完成总线使用的操作序列叫总线事务, 步骤有;</p>
<ol type="1">
<li>请求阶段: 发出总线传输请求获得总线控制权</li>
<li>仲裁阶段: 总线仲裁部分决定使用权给谁</li>
<li>寻址阶段: 主设备通过总线给出要访问的从设备地址及有关命令, 启动从模块</li>
<li>传输阶段: 主模块和从模块进行数据交换</li>
<li>释放阶段, 主模块信息从总线上撤除, 让出总线使用权</li>
</ol>
<p><strong>突发传送</strong>方式能进行连续成组数据传送, 每个时钟周期传送一个字长但是不释放总线 突发(burst)将多个传输作为一个单元进行执行，而不是独立地处理每个字。</p>
<h4 id="同步定时方式">6.2.2 同步定时方式</h4>
<p>系统采用统一时钟信号协调发送和接收双发的传送定时关系</p>
<p>简单,速度快, 但不能进行有效性检测</p>
<h4 id="异步定时方式">6.2.3 <strong>异步定时方式</strong></h4>
<p>没有统一时钟, 依靠传送握手信号实现定时控制</p>
<p>可以保证工作速度差距很大的部件可靠的传输数据, 但更复杂速度慢</p>
<p>分类:</p>
<ol type="1">
<li>不互锁: 主设备的请求信号和从设备的响应信号都是发出一段时间后撤回, 不必等待应答</li>
<li>半互锁: 主设备请求信号必须接收到从设备的响应信号才撤回, 从设备的响应信号的撤回不必等待请求信号的撤回</li>
<li>全互锁: 都必须等待对方才能撤回</li>
</ol>
<h2 id="第7章输入输出系统">第7章输入/输出系统</h2>
<h3 id="io系统基本概念">7.1 I/O系统基本概念</h3>
<h4 id="输入输出系统">*7.1.1 输入/输出系统</h4>
<ol type="1">
<li>外部设备</li>
<li>接口: 各个外设与主机传输数据时进行各种协调工作的逻辑部件, 包括速度匹配, 电平, 格式转换等</li>
<li>io 软件: 驱动程序等</li>
<li>io 硬件</li>
</ol>
<h4 id="io控制方式">*7.1.2 I/O控制方式</h4>
<ol type="1">
<li>程序查询方式</li>
<li>程序中断方式</li>
<li>DMA 方式</li>
<li>通道方式</li>
</ol>
<h4 id="外部设备">*7.1.3 外部设备</h4>
<h3 id="io接口-io-控制器">7.2 I/O接口 (I/O 控制器)</h3>
<h4 id="io接口的功能">7.2.1 I/O接口的功能</h4>
<ol type="1">
<li>地址译码和设备选择</li>
<li>实现主机与外设的通信联络控制</li>
<li>数据缓冲</li>
<li>信号格式转换: 如电平转换, 串并转换, 模数转换</li>
<li>传送控制命令和状态信息</li>
</ol>
<h4 id="io-接口的基本结构">7.2.2 I/O 接口的基本结构</h4>
<figure>
<img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/image-20230603161214626.png" alt="image-20230603161214626" /><figcaption aria-hidden="true">image-20230603161214626</figcaption>
</figure>
<h4 id="io接口的类型">7.2.3 I/O接口的类型</h4>
<ol type="1">
<li>并行接口(一字节或一字所有位同时传输)和串行接口(一位一位传输)</li>
<li>按主机访问方式: 程序查询接口, 中断接口, DMA 接口</li>
<li>按功能灵活性: 可编程接口, 不可编程接口</li>
</ol>
<h4 id="io-端口及其编址">7.2.4 I/O 端口及其编址</h4>
<p>IO 端口是指接口电路中可以被 cpu 直接访问的寄存器, 主要有数据端口, 状态端口, 控制端口 每个端口对应一个端口地址 端口的编址方式有</p>
<ol type="1">
<li>统一编址(存储器映射方式): 把 io 端口当做存储器的单元进行地址分配, 不需要 cpu 设置专门的 io 指令 内存空间变小, 速度慢</li>
<li>独立编址(io 映射方式): 需要专门的 io指令访问 io 端口</li>
</ol>
<h3 id="io方式">7.3 I/O方式</h3>
<h4 id="程序查询方式">7.3.1 程序查询方式</h4>
<p>信息交换控制完全由 cpu 执行实现</p>
<p>接口中设置一个数据端口, 一个状态端口, 主机进行 io 时, 先发出询问信号, 读取设备状态决定下一步是传输还是等待</p>
<p>流程:</p>
<ol type="1">
<li>cpu 执行初始化程序, 预置传送参数</li>
<li>向 io 接口发出命令字, 启动 io 设备</li>
<li>不断查询状态端口中的状态, 直到外设准备就绪</li>
<li>传送一次数据</li>
<li>修改地址和计数器参数</li>
<li>判断传送是否结束, 没结束-&gt;3, 直到计数器=0</li>
</ol>
<p>cpu 存在踏步现象</p>
<h4 id="程序中断方式">7.3.2 程序中断方式</h4>
<p>? 见操作系统</p>
<h4 id="dma-方式">7.3.3 DMA 方式</h4>
<p>完全由硬件组成的信息传送控制方式, 数据准备阶段 cpu 和外设平行工作</p>
<p>主存和 DMA 之间有一条直接数据通路, 数据传输不需要经过 cpu 具有以下特点:</p>
<ol type="1">
<li>主存既可以被 cpu 访问, 又可以被外设访问</li>
<li>数据块传送时, MM 地址的确定, 传送数据的计数都由硬件电路实现</li>
<li>主存中要开辟专门的缓冲区</li>
<li>DMA 传送速度快, cpu 和外设并行工作</li>
<li>DMA 在传送开始前要通过程序进行预处理, 结束后要通过中断方式进行后处理</li>
</ol>
<p>DMA 控制器(DMA 接口)组成 当 io 设备需要进行数据传输时, 通过 DMA 从志气向 cpu 提出传送请求, cpu 响应后让出系统总线, DMA 接管总线进行数据传输, 主要功能有:</p>
<ol type="1">
<li>接受外设发出的 DMA 请求, 并向 CPU 发出总线请求</li>
<li>cpu 响应发出总线响应信号, DMA 接管总线控制权, 进入 DMA 操作周期</li>
<li>确定传送数据的主存单元地址和长度, 自动修改主存地址计数和长度计数</li>
<li>规定数据在主存和外设间的传送方向, 发出读写控制信号, 执行数据传送</li>
<li>向 cpu 报告 DMA 操作结束</li>
</ol>
<p>DMA 传送过程中将接管 cpu 的地址数据控制总线, 可见 DMA 控制器必须有控制系统总线的能力</p>
<p>DMA 的传送方式</p>
<ol type="1">
<li>停止访问主存: 当有 DMA 请求时, cpu 停止访问 MM</li>
<li>周期挪用: 当 io 的 DMA 与 cpu 同时请求访存时, io 优先级更高(因为 io 不立即访存可能丢失数据), 此时 io 设备挪用几个存取周期, 传送完一个数据后立即释放总线, 是一种单字传输方式</li>
<li>DMA 与 cpu 交替访存: 适用于cpu 工作周期&gt;存取周期, 此时可将 cpu 工作周期划分为两个周期, 一个专供 DMA 访存, 一个专供 CPU 访存</li>
</ol>
<p>DMA 传送过程</p>
<ol type="1">
<li>预处理: cpu 执行几条 io 指令测试 io 设备状态, 初始化 DMAC 中的寄存器等, 然后 cpu 继续执行原来程序, 直到 io 向 DMAC 发送 DMA 请求, DMAC 向 cpu 发送总线请求再传输数据</li>
<li>数据传输: DMA 数据传输以 byte 或数据块为单位, 这个循环是由 DMAC 实现的, 即数据传输阶段完全由 DMA 控制</li>
<li>后处理, DMAC 向 cpu 发送中断请求, cpu 执行 DMA 结束处理, 包括校验, 是否使用 DMA 传输其他数据等</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2023/05/4ef6e1899988.html">https://sinos_wei.gitee.io/2023/05/4ef6e1899988.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpu/">cpu</a><a class="post-meta__tags" href="/tags/mdr/">mdr</a><a class="post-meta__tags" href="/tags/dma/">dma</a><a class="post-meta__tags" href="/tags/mar/">mar</a><a class="post-meta__tags" href="/tags/cache/">cache</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/00000074.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/1d8ca121605c.html" title="计算机网络"><img class="cover" src="/img/cover/IMG_2403.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/84f8fd6e47d3.html" title="zhengzhi"><img class="cover" src="/img/cover/IMG_4071.PNG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">zhengzhi</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/05/724d57ab8c34.html" title="操作系统"><img class="cover" src="/img/cover/32222.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-11-13</div><div class="title">操作系统</div></div></a></div><div><a href="/2021/04/7aa96f6293b7.html" title="每个内存_自翻"><img class="cover" src="/img/cover/00000069.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-19</div><div class="title">每个内存_自翻</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://8.130.42.149:5230" target="_blank" title="memo"><i class="fab fa-heart"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%85%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">第1章 计箅机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">*1.1 计算机发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">*1.1.1 计算机硬件的发展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">*1.1.2 计算机软件的发展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 计算机系统层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1. 计算机系统的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 计算机硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 计算机软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4 计算机系统的层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">1.2.5 计算机系统的工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 计算机的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 计算机的主要性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 几个专业术语</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.</span> <span class="toc-text">第2章 数据的表示和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1数制与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 进位计数制及其相互转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bcd%E7%A0%81-binary-coded-decimal"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">*2.1.2 BCD码 binary-coded decimal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 定点数的编码表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 整数的表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 运算方法和运算电路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 基本运算部件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 定点数的移位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 定点数的加减运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 定点数的乘除运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.2.5 C语言中的整数类型及类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">2.2.6 数据的存储和排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">2.2.7 汇编加减乘除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 浮点数的表示与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 浮点数的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 浮点数的加减运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">第3章 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 存储器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 存储器的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 存储器的性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3 多级层次的存储系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 主存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sram-%E8%8A%AF%E7%89%87%E5%92%8C-dram-%E8%8A%AF%E7%89%87"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 SRAM 芯片和 DRAM 芯片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 只读存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8-mm-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3 主存储器 MM 的基本组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">3.2.4 多模块存储器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E-cpu-%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 主存储器与 CPU 的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 连接原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2 主存容量的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%92%8C%E7%89%87%E9%80%89"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3.3 存储芯片的地址分配和片选</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E-cpu-%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3.3.4 存储器与 CPU 的连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8."><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 外部存储器.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">3.4.1 磁盘存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8-1"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">磁盘存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97"><span class="toc-number">1.3.4.1.2.</span> <span class="toc-text">磁盘阵列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98-ssd"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">3.4.2 固态硬盘 SSD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 高速缓冲存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">3.5.1 程序访问的局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">3.5.2 Cache 的基本工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cache-%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">3.5.3 Cache 和主存的映射方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cache-%E4%B8%AD%E4%B8%BB%E5%AD%98%E5%9D%97%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">3.5.4 Cache 中主存块的替换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cache-%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">3.5.5 Cache 写策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">3.6.1 虚拟存储器的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">3.6.2 页式虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">3.6.3 段式虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">3.6.4 段页式虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E-cache-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">3.6.5 虚拟存储器与 Cache 的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.</span> <span class="toc-text">第4章指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 指令的基本格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 定长操作码指令格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3 扩展操作码指令格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">4.1.4 指令的操作类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 指令的寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1．指令寻址和数据寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2 常见的数据寻址方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 程序的机器级代码表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">4.3.1 常用汇编指令介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">4.3.2 过程调用的机器级表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">4.3.3 选择语句的机器级表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.3.4 循环语句的机器级表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cisc-%E5%92%8Crisc-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 CISC 和RISC 的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA-cisc"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">4.4.1 复杂指令系统计算机 (CISC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA-risc"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">4.4.2 精简指令系统计算机 (RISC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cisc-%E5%92%8Crisc-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">4.4.3 CISC 和RISC 的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">第5章中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 CPU 的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">5.1.1 CPU 的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">5.1.2 CPU 的基本结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1 指令周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2 指令周期的数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3 指令执行方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 数据通路的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 数据通路的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 数据通路的基本结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 控制器的功能和工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">5.4.1 控制器的结构和功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">5.4.2 硬布线控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">5.4.3 微程序控制器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 异常和中断机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">5.5.1 异常和中断的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">5.5.2 异常和中断的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">5.5.3 异常和中断响应过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">5.6.1 指令流水线的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0-%E5%AF%B9%E5%8D%95%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">5.6.2 流水线的基本实现 (对单周期指令)?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%86%92%E9%99%A9%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">5.6.3 流水线的冒险与处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">5.6.4 流水线的性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">5.6.5 高级流水线技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 多处理器的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sisdsimd-mimd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">5.7.1 SISD、SIMD、 MIMD 的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">5.7.2 硬件多线程的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">5.7.3 多核处理器的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.7.4.</span> <span class="toc-text">5.7.4 共享内存多处理器的基本概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%80%BB%E7%BA%BF"><span class="toc-number">1.6.</span> <span class="toc-text">第6章 总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 总线概述．</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">6.1.1 总线基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">6.1.2 总线的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">6.1.3 系统总线的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">6.1.4 常见的总线标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">6.1.5 总线的性能指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 总线事务和定时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1 总线事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2 同步定时方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">6.2.3 异步定时方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.</span> <span class="toc-text">第7章输入&#x2F;输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 I&#x2F;O系统基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">*7.1.1 输入&#x2F;输出系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">*7.1.2 I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">*7.1.3 外部设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3-io-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 I&#x2F;O接口 (I&#x2F;O 控制器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">7.2.1 I&#x2F;O接口的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">7.2.2 I&#x2F;O 接口的基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">7.2.3 I&#x2F;O接口的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%85%B6%E7%BC%96%E5%9D%80"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">7.2.4 I&#x2F;O 端口及其编址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 I&#x2F;O方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">7.3.1 程序查询方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">7.3.2 程序中断方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dma-%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">7.3.3 DMA 方式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/c227678fd801.html" title="redis设计与实现读书笔记"><img src="/img/cover/IMG_3226.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis设计与实现读书笔记"/></a><div class="content"><a class="title" href="/2024/01/c227678fd801.html" title="redis设计与实现读书笔记">redis设计与实现读书笔记</a><time datetime="2024-01-10T10:06:01.614Z" title="Updated 2024-01-10 18:06:01">2024-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/a6f2ba33bf73.html" title="ts js html"><img src="/img/cover/00000106.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts js html"/></a><div class="content"><a class="title" href="/2023/07/a6f2ba33bf73.html" title="ts js html">ts js html</a><time datetime="2024-01-09T12:30:53.541Z" title="Updated 2024-01-09 20:30:53">2024-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/a5b7e0f39f18.html" title="深入浅出nodejs"><img src="/img/cover/00000076.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入浅出nodejs"/></a><div class="content"><a class="title" href="/2024/01/a5b7e0f39f18.html" title="深入浅出nodejs">深入浅出nodejs</a><time datetime="2024-01-06T11:48:17.075Z" title="Updated 2024-01-06 19:48:17">2024-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/a6ef84649f8f.html" title="nodejs-project-structure"><img src="/img/cover/00000197.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nodejs-project-structure"/></a><div class="content"><a class="title" href="/2024/01/a6ef84649f8f.html" title="nodejs-project-structure">nodejs-project-structure</a><time datetime="2024-01-04T11:41:32.798Z" title="Updated 2024-01-04 19:41:32">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/f52915be9043.html" title="webkit技术内幕读书笔记"><img src="/img/cover/00000051.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webkit技术内幕读书笔记"/></a><div class="content"><a class="title" href="/2024/01/f52915be9043.html" title="webkit技术内幕读书笔记">webkit技术内幕读书笔记</a><time datetime="2024-01-02T08:30:58.253Z" title="Updated 2024-01-02 16:30:58">2024-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>