<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: undefined | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta property="og:type" content="article">
<meta property="og:title" content="react">
<meta property="og:url" content="https://sinos_wei.gitee.io/2024/01/e6a15612f4ba.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/IMG_4070.PNG">
<meta property="article:published_time" content="2024-01-14T03:08:27.000Z">
<meta property="article:modified_time" content="2024-01-15T00:41:26.572Z">
<meta property="article:author" content="Sinos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/IMG_4070.PNG"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="canonical" href="https://sinos_wei.gitee.io/2024/01/e6a15612f4ba.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: undefined',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 08:41:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/IMG_4070.PNG')"><nav id="nav"><span id="blog-info"><a href="/" title="Sinos_wei's blog"><span class="site-name">Sinos_wei's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">react</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2024-01-15T00:41:26.572Z" title="Updated 2024-01-15 08:41:26">2024-01-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="react"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>

</blockquote>
<span id="more"></span>
<h1 id="jsx">jsx</h1>
<ol type="1">
<li><strong>作为文本</strong> 直接在 JSX 标签内： <code>&lt;h1&gt;&#123;name&#125;'s To Do List&lt;/h1&gt;</code> 有效，但 <code>&lt;&#123;tag&#125;&gt;Gregorio Y. Zara's To Do List&lt;/&#123;tag&#125;&gt;</code> 无效。</li>
<li><strong>作为属性</strong> 紧跟在 <code>=</code> 符号之后： <code>src=&#123;avatar&#125;</code> 将读取 <code>avatar</code> 变量，但 <code>src="&#123;avatar&#125;"</code> 将传递字符串 <code>"&#123;avatar&#125;"</code>。</li>
<li>要在 JSX 中传递一个 JS 对象，必须将对象封装在另一对大括号中： <code>person=&#123;&#123; name: "Hedy Lamarr", inventions: 5 &#125;&#125;</code></li>
</ol>
<p>任何 JavaScript 表达式都可以在大括号之间工作，包括像 <code>formatDate()</code> 这样的函数调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">date</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Intl</span>.<span class="title class_">DateTimeFormat</span>(</span><br><span class="line">    <span class="string">&#x27;en-US&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">weekday</span>: <span class="string">&#x27;long&#x27;</span> &#125;</span><br><span class="line">  ).<span class="title function_">format</span>(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>To Do List for &#123;formatDate(today)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 &amp;&amp;，只有当 isPacked 为 true 时，你才能有条件地渲染复选标记：</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;name&#125; &#123;isPacked &amp;&amp; &#x27;✔&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="传递属性">传递属性</h1>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Avatar</span>(<span class="params">&#123; person, size &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Avatar</span></span><br><span class="line">  size=&#123;<span class="number">80</span>&#125;</span><br><span class="line">  person=&#123;&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Aklilu Lemma&#x27;</span>, </span><br><span class="line">    <span class="attr">imageId</span>: <span class="string">&#x27;OKS67lh&#x27;</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Profile</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Avatar</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这会将 Profile 的所有属性转发给 Avatar，但不会列出每个属性的名称。</span></span><br></pre></td></tr></table></figure>
<p>children</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Card</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Profile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Avatar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">size</span>=<span class="string">&#123;100&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">person</span>=<span class="string">&#123;&#123;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">name:</span> &#x27;<span class="attr">Katsuko</span> <span class="attr">Saruhashi</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">imageId:</span> &#x27;<span class="attr">YfeOqp2</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="事件">事件</h1>
<p><strong>React 假定你编写的每个组件都是纯函数。</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params">&#123; onClick, children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      // e 是事件</span></span><br><span class="line"><span class="language-xml">      // 停止传播, 否则会继续向父组件传递</span></span><br><span class="line"><span class="language-xml">      e.stopPropagation();</span></span><br><span class="line"><span class="language-xml">      onClick();</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Toolbar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Toolbar&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      alert(&#x27;You clicked on the toolbar!&#x27;);</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> alert(&#x27;Playing!&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Play Movie</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> alert(&#x27;Uploading!&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Upload Image</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="hooks"><a target="_blank" rel="noopener" href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">hooks</a></h1>
<p>There are two main usage rules the React core team stipulates you need to follow to use hooks which they outline in the <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-rules.html">hooks proposal documentation</a>.</p>
<ul>
<li><strong>Don’t call Hooks inside loops, conditions, or nested functions</strong></li>
<li><strong>Only Call Hooks from React Functions</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/202401142102450.png" alt="img" style="zoom:50%;" /></p>
<p>example but not real internal implementation</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = [];</span><br><span class="line"><span class="keyword">let</span> setters = [];</span><br><span class="line"><span class="keyword">let</span> firstRun = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">cursor</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">setterWithCursor</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    state[cursor] = newVal;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the pseudocode for the useState helper</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initVal</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (firstRun) &#123;</span><br><span class="line">    state.<span class="title function_">push</span>(initVal);</span><br><span class="line">    setters.<span class="title function_">push</span>(<span class="title function_">createSetter</span>(cursor));</span><br><span class="line">    firstRun = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> setter = setters[cursor];</span><br><span class="line">  <span class="keyword">const</span> value = state[cursor];</span><br><span class="line">  cursor++;</span><br><span class="line">  <span class="keyword">return</span> [value, setter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our component code that uses hooks</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RenderFunctionComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = <span class="title function_">useState</span>(<span class="string">&quot;Rudi&quot;</span>); <span class="comment">// cursor: 0</span></span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = <span class="title function_">useState</span>(<span class="string">&quot;Yardley&quot;</span>); <span class="comment">// cursor: 1</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setFirstName(&quot;Richard&quot;)&#125;&gt;Richard<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setFirstName(&quot;Fred&quot;)&#125;&gt;Fred<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is sort of simulating Reacts rendering cycle</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  cursor = <span class="number">0</span>; <span class="comment">// resetting the cursor</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">RenderFunctionComponent</span> /&gt;</span></span>; <span class="comment">// render</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state); <span class="comment">// Pre-render: []</span></span><br><span class="line"><span class="title class_">MyComponent</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state); <span class="comment">// First-render: [&#x27;Rudi&#x27;, &#x27;Yardley&#x27;]</span></span><br><span class="line"><span class="title class_">MyComponent</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state); <span class="comment">// Subsequent-render: [&#x27;Rudi&#x27;, &#x27;Yardley&#x27;]</span></span><br><span class="line"><span class="comment">// click the &#x27;Fred&#x27; button</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state); <span class="comment">// After-click: [&#x27;Fred&#x27;, &#x27;Yardley&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>So now it should be clear as to why you cannot call <code>use</code> hooks within conditionals or loops. Because we are dealing with <strong>a cursor pointing to a set of arrays</strong>, <strong>if you change the order of the calls within render, the cursor will not match up to the data and your use calls will not point to the correct data or handlers.</strong></p>
<h1 id="渲染">渲染</h1>
<p>渲染必须始终为 <a target="_blank" rel="noopener" href="https://react.nodejs.cn/learn/keeping-components-pure">纯计算</a>, 在 “严格模式” 开发时，React 会调用每个组件的函数两次，这可以帮助表面因函数不纯而导致的错误。</p>
<ol type="1">
<li><strong>触发</strong> 渲染（将客人的订单送到厨房）
<ol type="1">
<li>这是组件的 <strong>初始渲染。</strong></li>
<li>组件（或其祖级之一）的 <strong>状态已更新。</strong></li>
</ol></li>
<li><strong>渲染</strong> 组件（在厨房准备订单）
<ol type="1">
<li><strong>在初始渲染时，</strong> React 将调用根组件。</li>
<li><strong>对于后续渲染，</strong> React 将调用其状态更新触发渲染的函数组件。</li>
</ol></li>
<li><strong>提交</strong> 到 DOM（将订单放到桌上）
<ol type="1">
<li><strong>对于初始渲染，</strong> React 将使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Node/appendChild"><code>appendChild()</code></a> DOM API 将它创建的所有 DOM 节点放在屏幕上。</li>
<li><strong>对于重新渲染，</strong> React 将应用最少的必要操作（在渲染时计算！）以使 DOM 匹配最新的渲染输出。</li>
</ol></li>
<li>渲染完成并且 React 更新 DOM 后，浏览器将重新绘制屏幕。 尽管此过程称为 “浏览器渲染”，但我们将其称为 “绘制” 以避免在整个文档中造成混淆。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://react.nodejs.cn/learn/render-and-commit#step-2-react-renders-your-components">“渲染”</a> 表示 React 正在调用你的组件，这是一个函数。 从该函数返回的 JSX 就像 UI 的及时快照。 它的属性、事件处理程序和局部变量都经过计算， <strong>在渲染时使用它的状态。</strong> 当 React 重新渲染一个组件时：</p>
<ol type="1">
<li>React 再次调用你的函数。</li>
<li>你的函数返回一个新的 JSX 快照。</li>
<li>然后 React 更新屏幕以匹配函数返回的快照。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setNumber</span>(<span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setNumber</span>(<span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setNumber</span>(<span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">&#125;&#125;&gt;+<span class="number">3</span>&lt;/button&gt;</span><br><span class="line"><span class="comment">// 下一次渲染的 number 是 1 而不是 3</span></span><br></pre></td></tr></table></figure>
<p>状态变量的值在渲染中永远不会改变， 即使其事件处理程序的代码是异步的。 在处理状态更新之前，React 会等到事件处理程序中的所有代码都已运行 多个 setNumber()形成队列, 下一次渲染前依次调用</p>
<p>你应该 <strong>将你放入状态的任何 JavaScript 对象视为只读。</strong>可以做的是替换而不是改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  ...person, // 浅 Copy the old fields</span><br><span class="line">  firstName: e.target.value // But override this one</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr />
<p>https://juejin.cn/post/7297024168604057636</p>
<h1 id="react和vue区别">react和vue区别</h1>
<ol type="1">
<li>vue是双向数据绑定 react是单向数据流</li>
<li>在 Vue 中我们组合不同功能的方式是通过 mixin，而在React中我们通过 HoC (高阶组件）</li>
<li>组件传值不同 Vue中子组件向父组件传递消息有两种方式：事件和回调函数，而且Vue更倾向于使用事件。但是在 React 中我们都是使用回调函数的</li>
<li>React 是通过JSX渲染模板 而Vue是通过一种拓展的HTML语法进行渲染</li>
<li>vue有v-model语法糖等</li>
</ol>
<h1 id="react的设计思想">React的设计思想</h1>
<h2 id="组件化">1. 组件化</h2>
<p>每个组件都符合开放-封闭原则，封闭是针对渲染工作流来说的，指的是组件内部的状态都由自身维护，只处理内部的渲染逻辑。开放是针对组件通信来说的，指的是不同组件可以通过props（单项数据流）进行数据交互</p>
<h2 id="数据驱动视图">2. 数据驱动视图</h2>
<p>UI=f(data)</p>
<p>通过上面这个公式得出，如果要渲染界面，不应该直接操作DOM，而是通过修改数据(state或prop)，数据驱动视图更新</p>
<h2 id="虚拟dom">3. 虚拟DOM</h2>
<p>由浏览器的渲染流水线可知，DOM操作是一个昂贵的操作，很耗性能，因此产生了虚拟DOM。虚拟DOM是对真实DOM的映射，React通过新旧虚拟DOM对比，得到需要更新的部分，实现数据的增量更新</p>
<h1 id="react-生命周期">React 生命周期</h1>
<p>分为组件挂载阶段, 组件更新阶段, 组件卸载阶段</p>
<h2 id="挂载">1. 挂载</h2>
<ul>
<li>constructor</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h2 id="更新">2. 更新</h2>
<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<h2 id="卸载">3. 卸载</h2>
<ul>
<li>componentWillUnmount</li>
</ul>
<h1 id="react-严格模式有什么用">React 严格模式有什么用</h1>
<ul>
<li>识别不安全的生命周期</li>
<li>关于使用过时字符串 ref API 的警告</li>
<li>关于使用废弃的 findDOMNode 方法的警告</li>
<li>检测意外的副作用</li>
</ul>
<h1 id="react-中遍历的方法有哪些">React 中遍历的方法有哪些</h1>
<ol type="1">
<li>遍历数组：map &amp;&amp; forEach</li>
<li>遍历对象：map &amp;&amp; for in</li>
</ol>
<h1 id="在react中页面重新加载时怎样保留数据">在React中页面重新加载时怎样保留数据？</h1>
<p>这个问题就设计到了<strong>数据持久化，</strong> 主要的实现方式有以下几种：</p>
<ul>
<li><strong>Redux：</strong> 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；</li>
<li><strong>data.js：</strong> 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；</li>
<li><strong>sessionStorge：</strong> 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据</li>
<li><strong>history API：</strong> History API 的 <code>pushState</code> 函数可以给历史记录关联一个任意的可序列化 <code>state</code>，所以可以在路由 <code>push</code> 的时候将当前页面的一些信息存到 <code>state</code> 中，下次返回到这个页面的时候就能从 <code>state</code> 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景</li>
</ul>
<h1 id="什么是jsx-它和js有什么区别">什么是jsx, 它和js有什么区别</h1>
<p>JSX是react的语法糖，它允许在html中写JS，它不能被浏览器直接识别，需要通过webpack、babel之类的编译工具转换为JS执行。 JSX与JS的区别：</p>
<ol type="1">
<li>JS可以被打包工具直接编译，不需要额外转换，jsx需要通过babel编译，它是React.createElement的语法糖，使用jsx等价于React.createElement</li>
<li>jsx是js的语法扩展，允许在html中写JS；JS是原生写法，需要通过script标签引入</li>
</ol>
<h1 id="react必须使用jsx吗">React必须使用JSX吗？</h1>
<p>React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。 每个 JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。</p>
<h1 id="在react中怎么使用asyncawait">在React中怎么使用async/await？</h1>
<p>async/await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 <strong>regeneratorRuntime is not defined</strong> 的异常错误。那么我们就需要引入babel，并在babel中配置使用async/await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。</p>
<h1 id="react.children.map和js的map有什么区别">React.Children.map和js的map有什么区别？</h1>
<p>JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。</p>
<h1 id="react-中的高阶组件运用了什么设计模式">React 中的高阶组件运用了什么设计模式？</h1>
<p>使用了装饰器模式。</p>
<h1 id="react-中-keys-的作用是什么">React 中 keys 的作用是什么？</h1>
<p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
<p>在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。</p>
<h1 id="为什么调用-setstate-而不是直接改变-state">为什么调用 setState 而不是直接改变 state？</h1>
<p>如果您尝试直接改变组件的状态，React 将无法得知它需要重新渲染组件。通过使用<code>setState()</code>方法，React 可以更新组件的UI。</p>
<h1 id="props的变动是否会引起-state-hook-中数据的变动">props的变动，是否会引起 state hook 中数据的变动？</h1>
<p>React 组件的 props 变动，会让组件重新执行，但并不会引起 state 的值的变动。state 值的变动，只能由 setState() 来触发。因此若想在 props 变动时，重置 state 的数据，需要监听 props 的变动。</p>
<h1 id="react18-有哪些新变化">React18 有哪些新变化？</h1>
<ol type="1">
<li>并发渲染机制：根据用户的设备性能和网速对渲染过程进行适当的调整， 保证 React 应用在长时间的渲染过程中依旧保持可交互性，避免页面出现卡顿或无响应的情况，从而提升用户体验。</li>
<li>新的创建方式：现在是要先通过<code>createRoot()</code>创建一个 root 节点，然后该 root 节点来调用<code>render()</code>方法；</li>
<li>自动批处理优化：批处理： React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 setstate 事件合并）；在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 promise 链、setTimeout 等异步代码以及原生事件处理函数；</li>
<li>startTransition：主动降低优先级。比如「搜索引擎的关键词联想」，用户在输入框中的输入希望是实时的，而联想词汇可以稍稍延迟一会儿。我们可以用 startTransition 来降低联想词汇更新的优先级；</li>
<li>useId：主要用于 SSR 服务端渲染的场景，方便在服务端渲染和客户端渲染时，产生唯一的 id；</li>
</ol>
<h1 id="并发模式是如何执行的">并发模式是如何执行的？</h1>
<p>React 中的<code>并发</code>，并不是指同一时刻同时在做多件事情。因为 js 本身就是单线程的（同一时间只能执行一件事情），而且还要跟 UI 渲染竞争主线程。若一个很耗时的任务占据了线程，那么后续的执行内容都会被阻塞。为了避免这种情况，React 就利用 fiber 结构和时间切片的机制，将一个大任务分解成多个小任务，然后按照任务的优先级和线程的占用情况，对任务进行调度。</p>
<ul>
<li>对于每个更新，为其分配一个优先级 lane，用于区分其紧急程度。</li>
<li>通过 Fiber 结构将不紧急的更新拆分成多段更新，并通过宏任务的方式将其合理分配到浏览器的帧当中。这样就能使得紧急任务能够插入进来。</li>
<li>高优先级的更新会打断低优先级的更新，等高优先级更新完成后，再开始低优先级更新。</li>
</ul>
<h1 id="什么是受控组件和非受控组件">什么是受控组件和非受控组件</h1>
<ul>
<li>受控组件：只能通过 React 修改数据或状态的组件，就是受控组件；</li>
<li>非受控组件：与受控组件相反，如 input, textarea, select, checkbox 等组件，本身控件自己就能控制数据和状态的变更，而且 React 是不知道这些变更的；</li>
</ul>
<p>那么如何将非受控组件改为受控组件呢？那就是把上面的这些纯 html 组件数据或状态的变更，交给 React 来操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123; </span><br><span class="line">    <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>); </span><br><span class="line">    <span class="keyword">const</span> [checked, setChecked] = <span class="title function_">useState</span>(<span class="literal">false</span>); </span><br><span class="line">    <span class="keyword">return</span> ( <span class="language-xml"><span class="tag">&lt;&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onInput</span>=<span class="string">&#123;event</span> =&gt;</span> setValue(event.target.value)&#125; /&gt; </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&#123;checked&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> setChecked(event.target.checked)&#125; /&gt; </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span> </span><br><span class="line">        ); </span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="高阶组件">高阶组件？</h1>
<p>高阶组件通过包裹（wrapped）被传入的 React 组件，经过一系列处理，最终返回一个相对增强（enhanced）的 React 组件，供其他组件调用。</p>
<ol type="1">
<li>复用逻辑：高阶组件更像是一个加工 react 组件的工厂，批量对原有组件进行加工，包装处理。我们可以根据业务需求定制化专属的 HOC,这样可以解决复用逻辑。</li>
<li>强化 props：这个是 HOC 最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的 props,然后混入新的 props,来增强组件的功能。代表作 react-router 中的 withRouter。</li>
<li>赋能组件：HOC 有一项独特的特性，就是可以给被 HOC 包裹的业务组件，提供一些拓展功能，比如说额外的生命周期，额外的事件，但是这种 HOC，可能需要和业务组件紧密结合。典型案例 react-keepalive-router 中的 keepaliveLifeCycle 就是通过 HOC 方式，给业务组件增加了额外的生命周期。</li>
<li>控制渲染：劫持渲染是 hoc 一个特性，在 wrapComponent 包装组件中，可以对原来的组件，进行条件渲染，节流渲染，懒加载等功能，后面会详细讲解，典型代表做 react-redux 中 connect 和 dva 中 dynamic 组件懒加载。</li>
</ol>
<h1 id="hooks篇">Hooks篇</h1>
<h2 id="什么是react-hooks">什么是React hooks</h2>
<blockquote>
<p>Hook 是 React 团队在 React 16.8 版本中提出的新特性，在遵循函数式组件的前提下，为已知的 React 概念提供了更直接的 API：props，state，context，refs 以及声明周期，目的在于解决常年以来在 class 组件中存在的各种问题，实现更高效的编写 react 组件</p>
</blockquote>
<h2 id="react-hooks-解决了哪些痛点">React hooks 解决了哪些痛点</h2>
<h3 id="第一在组件之间复用状态逻辑很难">第一，在组件之间复用状态逻辑很难</h3>
<p>比如，你使用redux创建了一个状态仓库，而这段代码好多个组件都在用，在类组件中，你可能就得在每个组件中引入store，是可以解决问题，但是很繁琐，也有的人说，那我可以使用高阶组件来优化，是可以的。但是如果遇到那种需要多层嵌套使用的公用组件，不管是 高阶组件还是render props ，都会遇到嵌套地狱的问题，使你的代码难以理解。</p>
<p>React需要为共享状态逻辑提供一个更好的解决方案。</p>
<h3 id="第二-复杂组件变得难以理解">第二, 复杂组件变得难以理解</h3>
<p>随着你们项目越来越复杂，参与开发的人越来越多，你会发现，代码越来越难以理解。其中一条就是，因为类组件每个生命周期只能写一次，导致每个生命周期内都充斥这各种逻辑不同甚至不相关的代码，整个文件变得越来越臃肿，越来越难以理解，还容易出现各种各样的bug</p>
<h4 id="第三难以理解的-class">第三，难以理解的 class</h4>
<p>即使有很多有经验的 React 开发者，可能有时候也对类组件中的class搞不清楚，对于里面this的工作方式不清楚。很多初学者都会经常因为找不到this而发愁，而且，class组件也会给一些工具带来问题，比如不能很好的压缩，并且会使热重载出现不稳定的情况。</p>
<h3 id="usestate-为什么返回数组而不是对象">useState 为什么返回数组而不是对象</h3>
<h4 id="与数组解构一致">1. 与数组解构一致</h4>
<p>使用数组的返回值与 JavaScript 中的解构赋值更一致。这让新手更容易理解和学习。当我们想要从 Hook 中获取多个状态时，只需按照数组的方式来解构即可。</p>
<h4 id="灵活性">2. 灵活性</h4>
<p>返回数组允许我们在变量名上取自定义的名字。如果我们使用对象，那么我们只能使用特定的属性名。这会限制我们的自由度，因为我们不能随意选择变量名。</p>
<h4 id="减少重构成本">3. 减少重构成本</h4>
<p>假设 React 开发团队在将来决定要改变 useState 的返回值。如果一开始就返回对象，那么这个变化将会破坏所有使用了 useState 的代码。而如果返回数组，React 可以在不破坏现有代码的情况下，轻松地修改 Hook 的内部实现。</p>
<h4 id="类型推断">3. 类型推断</h4>
<p>返回数组的方式对 TypeScript 等类型系统更友好。它可以更容易地进行类型推断。</p>
<h3 id="为什么不能在循环判断内部使用hook">为什么不能在循环、判断内部使用Hook</h3>
<p>参考文档<a target="_blank" rel="noopener" href="https://juejin.cn/post/7236325900720013371">对线面试官：为什么不能在if和循环里调用Hooks - 掘金 (juejin.cn)</a></p>
<p>因为React的函数式组件每次渲染都会重新生成状态，且每一次渲染都有一个状态序列，如果在if里调用，就可能导致某次渲染的时候状态序列有缺失，从而出现异常。</p>
<h3 id="usecallback-和-usememo-的使用场景">useCallback 和 useMemo 的使用场景</h3>
<p>useCallback 和 useMemo 可以用来缓存函数和变量，提高性能，减少资源浪费。但并不是所有的函数和变量都需要用这两者来实现，他也有对应的使用场景。</p>
<p>我们知道 useCallback 可以缓存函数体，在依赖项没有变化时，前后两次渲染时，使用的函数体是一样的。它的使用场景是：</p>
<ul>
<li>函数作为其他 hook 的依赖项时（如在 useEffect()中）；</li>
<li>函数作为 React.memo()（或 shouldComponentUpdate ）中的组件的 props；</li>
</ul>
<p>主要是为了避免重新生成的函数，会导致其他 hook 或组件的不必要刷新。</p>
<p>useMemo 用来缓存函数执行的结果。如每次渲染时都要执行一段很复杂的运算，或者一个变量需要依赖另一个变量的运算结果，就都可以使用 useMemo()。</p>
<h3 id="usestate-的传参方式有什么区别">useState 的传参方式，有什么区别？</h3>
<p>useState()的传参有两种方式：纯数据和回调函数。这两者在初始化时，除了传入方式不同，没啥区别。但在调用时，不同的调用方式和所在环境，输出的结果也是不一样的。</p>
<figure>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f67fd115a734c8aafc78bc5e23fd59d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=470&amp;h=327&amp;s=15077&amp;e=png&amp;b=f6f6f6" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>上面的两种传入方式，最后得到的 count 结果是不一样的。为什么呢？因为在以数据的格式传参时，这 3 个使用的是同一个 count 变量，数值是一样的。相当于<code>setCount(0 + 1)</code>，调用了 3 次；但以回调函数的传参方式，React 则一般地会直接该回调函数，然后得到最新结果并存储到 React 内部，下次使用时就是最新的了。注意：这个最新值是保存在 React 内部的，外部的 count 并不会马上更新，只有在下次渲染后才会更新。</p>
<h1 id="hooks中-父组件调用子组件的方法">hooks中, 父组件调用子组件的方法</h1>
<p>子组件中使用useImperativeHandle 生成可被父组件调用的函数, 然后导出子组件时用forwardRef包裹子组件, 在父组件中通过可拿到子组件的ref,通过 子组件ref.current.xx, 来调用子组件中的函数。</p>
<h1 id="为什么在本地开发时组件会渲染两次">为什么在本地开发时，组件会渲染两次？</h1>
<p>在 React.StrictMode 模式下，如果用了 useState,usesMemo,useReducer 之类的 Hook，React 会故意渲染两次，为的就是将一些不容易发现的错误容易暴露出来，同时 React.StrictMode 在正式环境中不会重复渲染。</p>
<h1 id="虚拟-dom-有什么优点真实-dom-和虚拟-dom谁快">虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快？</h1>
<p>Virtual DOM 是以对象的方式来描述真实 dom 对象的，那么在做一些 update 的时候，可以在内存中进行数据比对，减少对真实 dom 的操作减少浏览器重排重绘的次数，减少浏览器的压力，提高程序的性能，并且因为 diff 算法的差异比较，记录了差异部分，那么在开发中就会帮助程序员减少对差异部分心智负担，提高了开发效率。</p>
<p>虚拟 dom 好多这么多，渲染速度上是不是比直接操作真实 dom 快呢？并不是。虚拟 dom 增加了一层内存运算，然后才操作真实 dom，将数据渲染到页面上。渲染上肯定会慢上一些。虽然虚拟 dom 的缺点在初始化时增加了内存运算，增加了首页的渲染时间，但是运算时间是以毫秒级别或微秒级别算出的，对用户体验影响并不是很大。</p>
<p>如果程序直接操作dom, 是比虚拟dom要快的。</p>
<h1 id="什么是合成事件与原生事件有什么区别">什么是合成事件，与原生事件有什么区别 ？</h1>
<p>React 中所有触发的事件，都是自己在其内部封装了一套事件机制。目的是为了实现全浏览器的一致性，抹平不同浏览器之间的差异性。</p>
<p>在 React17 之前，React 是把事件委托在 document 上的，React17 及以后版本不再把事件委托在 document 上，而是委托在挂载的容器上。React 合成事件采用的是事件冒泡机制，当在某具体元素上触发事件时，等冒泡到顶部被挂载事件的那个元素时，才会真正地执行事件。</p>
<p>而原生事件，当某具体元素触发事件时，会立刻执行该事件。因此若要比较事件触发的先后时机时，原生事件会先执行，React 合成事件会后执行。</p>
<h1 id="key-的作用是什么">key 的作用是什么？</h1>
<p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<p>当组件刷新时，React 内部会根据 key 和元素的 type，来对比元素是否发生了变化。若选做 key 的数据有问题，可能会在更新的过程中产生异常。</p>
<h1 id="多次执行-usestate会触发多次更新吗">多次执行 useState()，会触发多次更新吗？</h1>
<p>在 React18 中，无论是多个 useState()的 hook，还是操作（dispatch）多次的数据。只要他们在同一优先级，React 就会将他们合并到一起操作，最后再更新数据。</p>
<h1 id="usestate的-state-是否可以直接修改是否可以引起组件渲染">useState()的 state 是否可以直接修改？是否可以引起组件渲染？</h1>
<p>我们不应当直接修改 state 的值，一方面是无法刷新组件（无法将新数据渲染到页面中），再有可能会对下次的更新产生影响。</p>
<p>唯一有影响的，就是后续要使用该变量的地方，会使用到新数据。但若其他 useState() 导致了组件的刷新，刚才变量的值，若是基本类型（比如数字、字符串等），会重置为修改之前的值；若是复杂类型，基于 js 的 对象引用 特性，也会同步修改 React 内部存储的数据，但不会引起视图的变化。</p>
<h1 id="react-的-diff-过程">React 的 diff 过程</h1>
<ol type="1">
<li>React 只对比当前层级的节点，不跨层级进行比较；</li>
<li>根据不同的节点类型，如函数组件节点、类组件节点、普通 fiber 节点、数组节点等，进入不同的处理函数；</li>
<li>前后两个 fiber 节点进行对比，若 type 不一样，直接舍弃掉旧的 fiber 节点，创建新的 fiber 节点；若 key 不一样，则需要根据情况判断，若是单个元素，则直接舍弃掉，创建新的 fiber 节点；若是数字型的元素，则查找是否移动了位置，若没找到，则创建新的节点；若 key 和 type 都一样，则接着往下递归；</li>
<li>若是单个 fiber 节点，则直接返回；若是并列多个元素的 fiber 节点，这里会形成单向链表，然后返回头指针（该链表最前面的那个 fiber 节点）；</li>
</ol>
<p>通过上面的 diff 对比过程，我们也可以看到，当组件产生比较大的变更时，React 需要做更多的动作，来构建出新的 fiber 树，因此我们在开发过程中，若从性能优化的角度考虑，尤其要注意的是：</p>
<ol type="1">
<li>节点不要产生大量的越级操作：因为 React 是只进行同层节点的对比，若同一个位置的子节点产生了比较大的变动，则只会舍弃掉之前的 fiber 节点，从而执行创建新 fiber 节点的操作；React 并不会把之前的 fiber 节点移动到另一个位置；相应的，之前的 jsx 节点移动到另一个位置后，在进行前后对比后，同样会执行更多的创建操作；</li>
<li>不修改节点的 key 和 type 类型，如使用随机数做为列表的 key，或从 div 标签改成 p 标签等操作，在 diff 对比过程中，都会直接舍弃掉之前的 fiber 节点及所有的子节点（即使子节点没有变动），然后重新创建出新的 fiber 节点；</li>
</ol>
<h1 id="基于-react-框架的特点可以有哪些优化措施">基于 React 框架的特点，可以有哪些优化措施？</h1>
<ol type="1">
<li>使用 React.lazy 和 Suspense 将页面设置为懒加载，避免 js 文件过大；</li>
<li>使用 SSR 技术，提高首屏的渲染速度；</li>
<li>使用 useCallback 和 useMemo 缓存函数或变量；使用 React.memo 缓存组件；</li>
<li>尽量调整样式或 className 的变动，减少 jsx 元素上的变动，尽量使用与元素相关的字段作为 key，可以减少 diff 的时间（React 会尽量复用之前的节点，若 jsx 元素发生变动，就需要重新创建节点）；</li>
<li>对于不需要产生页面变动的数据，可以放到 useRef()中；</li>
</ol>
<h1 id="什么是fiberfiber解决了什么问题">什么是fiber，fiber解决了什么问题</h1>
<p>在React16以前，React更新是通过<strong>树的深度优先遍历</strong>完成的，遍历是不能中断的，当树的层级深就会产生栈的层级过深，页面渲染速度变慢的问题，为了解决这个问题引入了fiber，React fiber就是虚拟DOM，它是一个链表结构，返回了return、children、siblings，分别代表父fiber，子fiber和兄弟fiber，随时可中断</p>
<h1 id="fiber的可中断可恢复怎么实现的">Fiber的可中断、可恢复怎么实现的</h1>
<p><strong><em>fiber</em></strong>是协程，是比线程更小的单元，可以被人为中断和恢复，当react更新时间超过1帧时，会产生视觉卡顿的效果，因此我们可以通过fiber把浏览器渲染过程分段执行，每执行一会就让出主线程控制权，执行优先级更高的任务</p>
<p>fiber是一个链表结构，它有三个指针，分别记录了当前节点的下一个兄弟节点，子节点，父节点。当遍历中断时，它是可以恢复的，只需要保留当前节点的索引，就能根据索引找到对应的节点</p>
<h1 id="fiber更新机制">Fiber更新机制</h1>
<p><strong>初始化</strong></p>
<ol type="1">
<li>创建fiberRoot（React根元素）和rootFiber(通过ReactDOM.render或者ReactDOM.createRoot创建出来的)</li>
<li>进入beginWork</li>
</ol>
<p><strong>workInProgress</strong>:正在内存中构建的fiber树叫workInProgress fiber，在第一次更新时，所有的更新都发生在workInProgress树，在第一次更新后，workInProgress树上的状态是最新状态，它会替换current树</p>
<p><strong>更新</strong></p>
<ol type="1">
<li>重新创建workInProgress树，复用当前current树上的alternate，作为新的workInProgress</li>
</ol>
<p>渲染完成后，workInProgress树又变成current树。</p>
<p><strong>双缓冲模式</strong></p>
<p>react的current树和workInProgress树使用双缓冲模式，可以减少fiber节点的开销，减少性能损耗</p>
<h1 id="react渲染流程"><strong>React渲染流程</strong></h1>
<p>如图，React用JSX描述页面，JSX经过babel编译为render function，执行后产生VDOM，VDOM不是直接渲染的，会先转换为fiber，再进行渲染。vdom转换为fiber的过程叫reconcile，转换过程会创建DOM，全部转换完成后会一次性commit到DOM，这个过程不是一次性的，而是可打断的，这就是fiber架构的渲染流程</p>
<figure>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92bc550947f44dfc92cd31d6270b8469~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=992&amp;h=408&amp;s=105941&amp;e=png&amp;b=f9f5e6" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="react-router-和-react-router-dom-的有什么区别">react-router 和 react-router-dom 的有什么区别</h1>
<h4 id="api-方面">api 方面</h4>
<p>React-router： 提供了路由的核心 api。如 Router、Route、Switch 等，但没有提供有关 dom 操作进行路由跳转的 api； React-router-dom： 提供了 BrowserRouter、Route、Link 等 api，可以通过 dom 操作触发事件控制路由。 Link 组件，会渲染一个 a 标签；BrowserRouter 和 HashRouter 组件，前者使用 pushState 和 popState 事件构建路由，后者使用 hash 和 hashchange 事件构建路由。</p>
<h4 id="使用区别">使用区别</h4>
<p>react-router-dom 在 react-router 的基础上扩展了可操作 dom 的 api。 Swtich 和 Route 都是从 react-router 中导入了相应的组件并重新导出，没做什么特殊处理。 react-router-dom 中 package.json 依赖中存在对 react-router 的依赖，故此，不需要额外安装 react-router。</p>
<h1 id="redux-遵循的三个原则是什么">Redux 遵循的三个原则是什么？</h1>
<ol type="1">
<li>单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。</li>
<li>状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。</li>
<li>使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</li>
</ol>
<h1 id="你对单一事实来源有什么理解">你对“单一事实来源”有什么理解？</h1>
<p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p>
<h1 id="redux-有哪些优点">Redux 有哪些优点？</h1>
<p>Redux 的优点如下：</p>
<ul>
<li>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</li>
<li>可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构。</li>
<li>服务器端渲染 - 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。</li>
<li>开发人员工具 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。</li>
<li>社区和生态系统 - Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。</li>
<li>易于测试 - Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。</li>
<li>组织 - Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。</li>
</ul>
<h1 id="redux的缺点如下">Redux的缺点如下:</h1>
<p>繁重的代码模板：修改一个state可能要动四五个文件，可谓牵一发而动全身。</p>
<p>2）store 里状态残留：多组件共用 store 里某个状态时要注意初始化清空问题。</p>
<p>3）无脑的发布订阅：每次 dispatch 一个 action 都会遍历所有的 reducer，重新计算 connect，这无疑是一种损耗；</p>
<p>4）交互频繁时会有卡顿：如果 store 较大时，且频繁地修改 store，会明显看到页面卡顿。</p>
<h1 id="redux-mobx-rxjs的区别">Redux mobx rxjs的区别</h1>
<ol type="1">
<li>Redux采用函数式编程，使用了<strong>纯函数</strong>。函数获取输入，返回输出，并且没有其他依赖项，而是纯函数。纯函数始终使用相同的输入生成相同的输出，并且没有任何副作用。</li>
<li>Redux状态对象通常是不可变的（Immutable）,我们不能直接操作状态对象，而是始终返回一个新状态。</li>
</ol>
<p>MobX遵循的是面向对象编程原则，可以直接使用新值更新状态对象。在mobx最新的v6版本中，Mobx使用了<code>Proxy</code> 代理实现数据的响应式，这和 Vue 相似。由于 MobX 中的 State 用的是“响应式”数据，因此任何变动会被 MobX 感知并通知到 React，当状态更新后，<code>MobX</code> 会以一种高效且无障碍的方式处理好剩下的事情。像下面如此简单的语句，已经足够用来自动更新用户界面了。</p>
<p>而RxJS, 是一款使用函数响应式编程(Reactive Programming)来处理异步数据流的库。基于事件流（Event Stream），几乎可以将任何事件转化成数据源。</p>
<p>Redux是针对应用程序整个状态的管理，而RxJS则是处理异步数据流和事件的工具。在某些场景下，Redux和RxJS也可以结合使用，比如在React应用中结合rxjs和react-redux来处理数据订阅过程。</p>
<p>作者：那个阳光彩虹小白马 链接：https://juejin.cn/post/7297024168604057636 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2024/01/e6a15612f4ba.html">https://sinos_wei.gitee.io/2024/01/e6a15612f4ba.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover/IMG_4070.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/7f63baa7f30d.html" title="mysql面经"><img class="cover" src="/img/cover/0021.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">mysql面经</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">207</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://8.130.42.149:5230" target="_blank" title="memo"><i class="fab fa-heart"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jsx"><span class="toc-number">1.</span> <span class="toc-text">jsx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%B1%9E%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">传递属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hooks"><span class="toc-number">4.</span> <span class="toc-text">hooks</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">5.</span> <span class="toc-text">渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E5%92%8Cvue%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">react和vue区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">7.</span> <span class="toc-text">React的设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">1. 组件化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE"><span class="toc-number">7.2.</span> <span class="toc-text">2. 数据驱动视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">7.3.</span> <span class="toc-text">3. 虚拟DOM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">8.</span> <span class="toc-text">React 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-number">8.1.</span> <span class="toc-text">1. 挂载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-number">8.2.</span> <span class="toc-text">2. 更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">8.3.</span> <span class="toc-text">3. 卸载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">React 严格模式有什么用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-%E4%B8%AD%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.</span> <span class="toc-text">React 中遍历的方法有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8react%E4%B8%AD%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%80%8E%E6%A0%B7%E4%BF%9D%E7%95%99%E6%95%B0%E6%8D%AE"><span class="toc-number">11.</span> <span class="toc-text">在React中页面重新加载时怎样保留数据？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjsx-%E5%AE%83%E5%92%8Cjs%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">什么是jsx, 它和js有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8jsx%E5%90%97"><span class="toc-number">13.</span> <span class="toc-text">React必须使用JSX吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8react%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8asyncawait"><span class="toc-number">14.</span> <span class="toc-text">在React中怎么使用async&#x2F;await？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react.children.map%E5%92%8Cjs%E7%9A%84map%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">React.Children.map和js的map有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E8%BF%90%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">React 中的高阶组件运用了什么设计模式？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-%E4%B8%AD-keys-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">17.</span> <span class="toc-text">React 中 keys 的作用是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8-setstate-%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98-state"><span class="toc-number">18.</span> <span class="toc-text">为什么调用 setState 而不是直接改变 state？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#props%E7%9A%84%E5%8F%98%E5%8A%A8%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BC%95%E8%B5%B7-state-hook-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8A%A8"><span class="toc-number">19.</span> <span class="toc-text">props的变动，是否会引起 state hook 中数据的变动？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react18-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E5%8F%98%E5%8C%96"><span class="toc-number">20.</span> <span class="toc-text">React18 有哪些新变化？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">21.</span> <span class="toc-text">并发模式是如何执行的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">22.</span> <span class="toc-text">什么是受控组件和非受控组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">23.</span> <span class="toc-text">高阶组件？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hooks%E7%AF%87"><span class="toc-number">24.</span> <span class="toc-text">Hooks篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFreact-hooks"><span class="toc-number">24.1.</span> <span class="toc-text">什么是React hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-hooks-%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E7%97%9B%E7%82%B9"><span class="toc-number">24.2.</span> <span class="toc-text">React hooks 解决了哪些痛点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A4%8D%E7%94%A8%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%E5%BE%88%E9%9A%BE"><span class="toc-number">24.2.1.</span> <span class="toc-text">第一，在组件之间复用状态逻辑很难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C-%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3"><span class="toc-number">24.2.2.</span> <span class="toc-text">第二, 复杂组件变得难以理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84-class"><span class="toc-number">24.2.2.1.</span> <span class="toc-text">第三，难以理解的 class</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usestate-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">24.2.3.</span> <span class="toc-text">useState 为什么返回数组而不是对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E4%B8%80%E8%87%B4"><span class="toc-number">24.2.3.1.</span> <span class="toc-text">1. 与数组解构一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">24.2.3.2.</span> <span class="toc-text">2. 灵活性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%87%8D%E6%9E%84%E6%88%90%E6%9C%AC"><span class="toc-number">24.2.3.3.</span> <span class="toc-text">3. 减少重构成本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">24.2.3.4.</span> <span class="toc-text">3. 类型推断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8hook"><span class="toc-number">24.2.4.</span> <span class="toc-text">为什么不能在循环、判断内部使用Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usecallback-%E5%92%8C-usememo-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">24.2.5.</span> <span class="toc-text">useCallback 和 useMemo 的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usestate-%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">24.2.6.</span> <span class="toc-text">useState 的传参方式，有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hooks%E4%B8%AD-%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">25.</span> <span class="toc-text">hooks中, 父组件调用子组件的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E6%97%B6%E7%BB%84%E4%BB%B6%E4%BC%9A%E6%B8%B2%E6%9F%93%E4%B8%A4%E6%AC%A1"><span class="toc-number">26.</span> <span class="toc-text">为什么在本地开发时，组件会渲染两次？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-dom-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E7%9C%9F%E5%AE%9E-dom-%E5%92%8C%E8%99%9A%E6%8B%9F-dom%E8%B0%81%E5%BF%AB"><span class="toc-number">27.</span> <span class="toc-text">虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">什么是合成事件，与原生事件有什么区别 ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#key-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">29.</span> <span class="toc-text">key 的作用是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C-usestate%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%90%97"><span class="toc-number">30.</span> <span class="toc-text">多次执行 useState()，会触发多次更新吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#usestate%E7%9A%84-state-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%BC%95%E8%B5%B7%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">31.</span> <span class="toc-text">useState()的 state 是否可以直接修改？是否可以引起组件渲染？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-%E7%9A%84-diff-%E8%BF%87%E7%A8%8B"><span class="toc-number">32.</span> <span class="toc-text">React 的 diff 过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-react-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD"><span class="toc-number">33.</span> <span class="toc-text">基于 React 框架的特点，可以有哪些优化措施？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfiberfiber%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">34.</span> <span class="toc-text">什么是fiber，fiber解决了什么问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fiber%E7%9A%84%E5%8F%AF%E4%B8%AD%E6%96%AD%E5%8F%AF%E6%81%A2%E5%A4%8D%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">35.</span> <span class="toc-text">Fiber的可中断、可恢复怎么实现的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fiber%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">36.</span> <span class="toc-text">Fiber更新机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="toc-number">37.</span> <span class="toc-text">React渲染流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-router-%E5%92%8C-react-router-dom-%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">38.</span> <span class="toc-text">react-router 和 react-router-dom 的有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#api-%E6%96%B9%E9%9D%A2"><span class="toc-number">38.0.0.1.</span> <span class="toc-text">api 方面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">38.0.0.2.</span> <span class="toc-text">使用区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redux-%E9%81%B5%E5%BE%AA%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">39.</span> <span class="toc-text">Redux 遵循的三个原则是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E5%8D%95%E4%B8%80%E4%BA%8B%E5%AE%9E%E6%9D%A5%E6%BA%90%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3"><span class="toc-number">40.</span> <span class="toc-text">你对“单一事实来源”有什么理解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redux-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9"><span class="toc-number">41.</span> <span class="toc-text">Redux 有哪些优点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redux%E7%9A%84%E7%BC%BA%E7%82%B9%E5%A6%82%E4%B8%8B"><span class="toc-number">42.</span> <span class="toc-text">Redux的缺点如下:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redux-mobx-rxjs%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">43.</span> <span class="toc-text">Redux mobx rxjs的区别</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/a6f2ba33bf73.html" title="ts js html"><img src="/img/cover/00000085.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts js html"/></a><div class="content"><a class="title" href="/2023/07/a6f2ba33bf73.html" title="ts js html">ts js html</a><time datetime="2024-01-15T00:41:29.313Z" title="Updated 2024-01-15 08:41:29">2024-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/e6a15612f4ba.html" title="react"><img src="/img/cover/IMG_4070.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react"/></a><div class="content"><a class="title" href="/2024/01/e6a15612f4ba.html" title="react">react</a><time datetime="2024-01-15T00:41:26.572Z" title="Updated 2024-01-15 08:41:26">2024-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/4df836237f4a.html" title="计算机网络总结"><img src="/img/cover/00000051.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络总结"/></a><div class="content"><a class="title" href="/2020/09/4df836237f4a.html" title="计算机网络总结">计算机网络总结</a><time datetime="2024-01-11T12:29:15.372Z" title="Updated 2024-01-11 20:29:15">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/558c2ce4f43d.html" title="blogs"><img src="/img/cover/00000074.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="blogs"/></a><div class="content"><a class="title" href="/2023/03/558c2ce4f43d.html" title="blogs">blogs</a><time datetime="2024-01-11T12:01:53.268Z" title="Updated 2024-01-11 20:01:53">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/f05961026253.html" title="数据结构"><img src="/img/cover/00000090.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/2023/05/f05961026253.html" title="数据结构">数据结构</a><time datetime="2024-01-11T10:04:00.887Z" title="Updated 2024-01-11 18:04:00">2024-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>