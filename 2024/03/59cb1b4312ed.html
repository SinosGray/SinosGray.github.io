<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: undefined | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta property="og:type" content="article">
<meta property="og:title" content="cppdoc">
<meta property="og:url" content="https://sinos_wei.gitee.io/2024/03/59cb1b4312ed.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/00000075.jpg">
<meta property="article:published_time" content="2024-03-01T14:03:01.000Z">
<meta property="article:modified_time" content="2024-03-14T13:13:29.240Z">
<meta property="article:author" content="Sinos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/00000075.jpg"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="canonical" href="https://sinos_wei.gitee.io/2024/03/59cb1b4312ed.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?aeddd8219bc5c1e1efdcf5d9cc3218e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: undefined',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-14 21:13:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/00000075.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Sinos_wei's blog"><span class="site-name">Sinos_wei's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">cppdoc</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2024-03-14T13:13:29.240Z" title="Updated 2024-03-14 21:13:29">2024-03-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cppdoc"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>

</blockquote>
<span id="more"></span>
<h1 id="基础概念">基础概念</h1>
<h2 id="定义和-odrone-definition-rule">定义和 ODR(one definition rule)</h2>
<p>ODR: 一个翻译单元中只有一个定义 It consists of the contents of a single source file, plus the contents of any header files directly or indirectly included by it, minus those lines that were ignored using conditional preprocessing statements. A single translation unit can be compiled into an object file, library, or executable program.</p>
<h2 id="注释">注释</h2>
<p>注释在预处理之前去除</p>
<h2 id="对象">对象</h2>
<p>The following entities are not objects: value, reference, function, enumerator, type, non-static class member, template, class or function template specialization, namespace, parameter pack, and this.</p>
<p>For any two non-bit-field objects with overlapping lifetimes:</p>
<ul>
<li>If any of the following conditions is satisfied, they may <strong>have the same address</strong>: One of them is nested within the other. Any of them is a subobject of zero size, and their types are not similar. They are both potentially non-unique objects.</li>
<li>Otherwise, they always have distinct addresses and occupy disjoint bytes of storage.</li>
</ul>
<p>An object is a potentially <strong>non-unique object</strong> if it one of the following objects:</p>
<ul>
<li><p>A string literal object. <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/51592/is-there-a-need-to-destroy-char-string-or-char-new-char6/51607#51607">关于字面量的存储问题</a> If you do not use <code>malloc</code> or <code>new</code>, then the <code>char*</code> or string will be created on the stack or as a compile-time constant.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func s addr:&quot;</span>&lt;&lt;&amp;s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func s value:&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(s) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s addr:&quot;</span>&lt;&lt;&amp;s&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s value:&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(s)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">auto</span> s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    但是单个字符并不会分配同一地址</span></span><br><span class="line"><span class="comment">    static const char test1 = &#x27;x&#x27;;</span></span><br><span class="line"><span class="comment">    static const char test2 = &#x27;x&#x27;;</span></span><br><span class="line"><span class="comment">    const bool b = &amp;test1 != &amp;test2;      // always true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 addr:&quot;</span>&lt;&lt;&amp;s1 &lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s1 value:&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(s1)&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;123 addr:&quot;</span>&lt;&lt; &amp;<span class="string">&quot;123&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s addr:0x7ff7bf1f49f8</span></span><br><span class="line"><span class="comment">s value:0x100d0def0</span></span><br><span class="line"><span class="comment">s1 addr:0x7ff7bf1f49f0</span></span><br><span class="line"><span class="comment">s1 value:0x100d0def0</span></span><br><span class="line"><span class="comment">123 addr:0x100d0def0</span></span><br><span class="line"><span class="comment">func s addr:0x7ff7bf1f49d8</span></span><br><span class="line"><span class="comment">func s value:0x100d0def0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>The backing array of an initializer list.</p></li>
<li><p>A subobject of a potentially non-unique object.</p></li>
</ul>
<h2 id="范围">范围</h2>
<p>The locus of a name declared in a simple declaration is <strong>immediately</strong> after that name's <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/declarations#Declarators">declarator</a> and before its initializer, if any. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">32</span>; <span class="comment">// outer x is in scope</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = x; </span><br><span class="line">  <span class="comment">// inner x is in scope before the initializer (= x); this does not initialize inner x with the value of outer x (32); this initializes inner x with its own (indeterminate) value</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f = [&amp;](<span class="type">int</span> n)&#123; <span class="keyword">return</span> n &gt; <span class="number">1</span> ? n * <span class="built_in">f</span>(n - <span class="number">1</span>) : n; &#125;;</span><br><span class="line"><span class="comment">// the name of the function f is in scope in the lambda and can</span></span><br><span class="line"><span class="comment">// be correctly captured by reference, giving a recursive function</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">2</span>; <span class="comment">// outer x is in scope</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x[x] = &#123;&#125;; <span class="comment">// inner x is in scope before the initializer (= &#123;&#125;),</span></span><br><span class="line">                 <span class="comment">// but after the declarator (x[x])</span></span><br><span class="line">                 <span class="comment">// in the declarator, outer x is still in scope</span></span><br><span class="line">                 <span class="comment">// this declares an array of 2 int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="生命周期">生命周期</h2>
<p>一个对象的声明周期开始: 被分配存储空间的时刻 结束: 销毁(destroy 或析构); 空间释放 对象的生命周期&lt;=其存储的存在</p>
<p>引用的声明周期从初始化开始, 和标量一样结束 (如果被引用的对象先于引用结束, 则产生 dangling 引用)</p>
<p>Temporary objects are created in the following situations:</p>
<ul>
<li>binding a reference to a prvalue</li>
<li>initializing an object of type std::initializer_list<T> from a braced-init-list</li>
<li>returning a prvalue from a function</li>
<li>conversion that creates a prvalue (including T(a, b, c) and T{})</li>
<li>lambda expression</li>
<li>copy-initialization that requires conversion of the initializer,</li>
<li>reference-initialization to a different but convertible type or to a bitfield.</li>
<li>when throwing an exception</li>
</ul>
<p>There are the following exceptions from that:</p>
<ul>
<li>The lifetime of a temporary object may be extended by binding to a reference</li>
<li>当用于初始化或复制数组元素的默认或复制构造函数在评估其默认参数时创建的临时对象，其生命周期会在数组下一个元素开始初始化之前结束。</li>
</ul>
<h2 id="name-lookup">name lookup</h2>
<p>A qualified name is a name that appears on the <strong>right</strong> hand side of the scope resolution operator ::</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">std</span> &#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fail\n&quot;</span>; <span class="comment">// Error: unqualified lookup for &#x27;std&#x27; finds the struct</span></span><br><span class="line">    ::std::cout &lt;&lt; <span class="string">&quot;ok\n&quot;</span>; <span class="comment">// OK: ::std finds the namespace std</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For an unqualified name, that is a name that does not appear to the right of a scope resolution operator ::, name lookup examines the scopes as described below, <strong>until it finds at least one declaration of any kind, at which time the lookup stops and no further scopes are examined.</strong></p>
<h2 id="adlargument-dependent-lookup">ADL(Argument-dependent lookup)</h2>
<p>用于查找函数名 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">X</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Y</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(X)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">f</span>(i); <span class="comment">// Calls B::f (endless recursion)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(A::X x)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">g</span>(x); <span class="comment">// Error: ambiguous between B::g (ordinary lookup)</span></span><br><span class="line">            <span class="comment">//        and A::g (argument-dependent lookup)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(A::Y y)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">h</span>(y); <span class="comment">// Calls B::h (endless recursion): ADL examines the A namespace</span></span><br><span class="line">            <span class="comment">// but finds no A::h, so only B::h from ordinary lookup is used</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="phases-of-translation">Phases of translation</h2>
<ol type="1">
<li>字符转换</li>
<li>删去换行符</li>
<li>分解为 注释, 空白字符, 预处理符号</li>
<li>预处理, include 的文件递归步骤 1-4</li>
<li>所有字符串文字量转换编码</li>
<li>连接相邻字符串</li>
<li>token 在句法和语义上被分析并翻译为翻译单元。</li>
<li>处理模版?得到<em>instantiation units</em></li>
<li>Translation units, instantiation units, and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment.</li>
</ol>
<h2 id="main-函数">main 函数</h2>
<ul>
<li><p>It cannot be used anywhere in the program</p></li>
<li><p>The body of the main function <strong>does not need to contain the return statement</strong>: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.</p></li>
<li><p>Execution of the return (or the implicit return upon reaching the end of main) is equivalent to first leaving the function normally (which destroys the objects with automatic storage duration) and then calling std::exit with the same argument as the argument of the return (std::exit then destroys static objects and terminates the program).</p></li>
</ul>
<h2 id="类型">类型</h2>
<p><img src="https://raw.githubusercontent.com/SinosGray/picgo/master/test/202403012230333.svg" alt="cpp types.svg" style="zoom:50%;" /></p>
<p>Signedness: signed — target type will have signed representation (this is the default if omitted)(char 除外, char 是否带符号因编译器而异) unsigned — target type will have unsigned representation Size: short — target type will be <strong>optimized for space</strong> and will have width of at least 16 bits. long — target type will have width of at least 32 bits. long long — target type will have width of at least 64 bits.</p>
<p>type 类型</p>
<ul>
<li><p>The value of sizeof(bool) is implementation defined and might differ from 1.</p></li>
<li><p>char 是否带符号因编译器而异</p></li>
<li><p>wchar_t — type for wide character representation (see wide strings).it is 32 bits and holds UTF-32 on Linux and many other non-Windows systems, but 16 bits and holds UTF-16 code units on Windows.</p></li>
</ul>
<h1 id="关键字">关键字</h1>
<h2 id="auto">auto</h2>
<p>使用 Template argument deduction 方法检测类型 The placeholder auto may be accompanied by modifiers, such as const or &amp;, which will participate in the type deduction. 如果初始化表达式是引用，则去除引用语义 如果初始化表达式为const或volatile（或者两者兼有），则除去const/volatile语义。 如果auto关键字带上&amp;号，则不去除const语义。 初始化表达式为数组时，auto关键字推导类型为指针。 如果表达式为数组且auto带上&amp;，则推导类型为数组类型。</p>
<p>auto 的自动类型推断发生在编译期</p>
<h2 id="const-volatile">const volatile</h2>
<p>Any (possibly incomplete) type other than function type or reference type is a type in a group of the following four distinct but related types:</p>
<ol type="1">
<li>A cv-unqualified version.</li>
<li>A const-qualified version.</li>
<li>A volatile-qualified version.</li>
<li>A const-volatile-qualified version.</li>
</ol>
<p>These four types in the same group have the same representation and alignment requirements. Array types are considered to have the same cv-qualification as their element types.</p>
<p>When an object is first created, the cv-qualifiers used (which could be part of decl-specifier-seq or part of a declarator in a declaration, or part of type-id in a new-expression) determine the constness or volatility of the object, as follows:</p>
<p>A <strong>const object</strong> is</p>
<ol type="1">
<li>an object whose type is const-qualified, or</li>
<li>a non-mutable subobject of a const object.</li>
</ol>
<p>Such object cannot be modified: attempt to do so directly is a <strong>compile-time</strong> error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.</p>
<p>A <strong>volatile object</strong> is</p>
<ol type="1">
<li>an object whose type is volatile-qualified,</li>
<li>a subobject of a volatile object, or</li>
<li>a mutable subobject of a const-volatile object.</li>
</ol>
<p>volatile的主要作用是告知编译器变量可能会被无法预测的外部因素修改。例如，如果一个变量被内存映射到一个可以异步修改的硬件寄存器（比如在嵌入式系统中），使用volatile可以确保编译器始终从内存中读取和写入该变量，而不是将其值优化并缓存在寄存器中或执行其他优化。</p>
<p>A <strong>const volatile</strong> object is</p>
<ol type="1">
<li>an object whose type is const-volatile-qualified,</li>
<li>a non-mutable subobject of a const volatile object,</li>
<li>a const subobject of a volatile object, or</li>
<li>a non-mutable volatile subobject of a const object.</li>
</ol>
<p>Behaves as both a const object and as a volatile object.</p>
<h2 id="constexpr">constexpr</h2>
<blockquote>
<p>specifies that the value of a variable or function can appear in constant expressions The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time.</p>
</blockquote>
<p>A constexpr specifier used in an object declaration or non-static member function implies const. A constexpr specifier used in a function declaration implies inline. If any declaration of a function or function template has a constexpr specifier, then every declaration must contain that specifier.</p>
<p>A <strong>constexpr variable</strong> must satisfy the following requirements:</p>
<ul>
<li>its type must be a LiteralType</li>
<li>it must be immediately initialized</li>
<li>the full-expression of its initialization, including all implicit conversions, constructors calls, etc, must be a constant expression</li>
</ul>
<p>A <strong>constexpr function</strong> must satisfy the following requirements:</p>
<ul>
<li>it must not be virtual</li>
<li>it must not be a function-try-block</li>
<li>for constructor, the class must have no virtual base classes</li>
<li>its return value (if any) and each of its parameters must be of a LiteralType</li>
<li>there exists at least one set of argument values such that an invocation of the function could be an evaluated subexpression of a core constant expression (for constructors, use in a constant initializer is sufficient). No diagnostic is required for a violation of this bullet.</li>
<li>the function body must be either deleted or defaulted or contain only the following:
<ul>
<li>null statements (plain semicolons)</li>
<li>static_assert declarations</li>
<li>typedef declarations and alias declarations that do not define classes or enumerations</li>
<li>using declarations</li>
<li>using directives</li>
<li>if the function is not a constructor, exactly one return statement</li>
</ul></li>
</ul>
<h2 id="const-vs.-constexpr">const vs. constexpr</h2>
<blockquote>
<p>const 保证初始化后对象的值不变, 编译器可以利用这一点, 同时预防程序员修改 const 修饰 non-static成员函数(对函数也只能修饰non-static成员函数): 保证不修改 non-static 成员</p>
<p>constexpr declares an object as fit for use in what the Standard calls <em>constant expressions</em>. constexpr 修饰函数(普通函数, 成员函数, 构造函数等): 效果是符合 constant expressions 标准</p>
</blockquote>
<p>Declaring something as <code>constexpr</code> does not necessarily guarantee that it will be evaluated at compile time. It <em>can be used</em> for such, but it can be used in other places that are evaluated at run-time, as well.</p>
<h2 id="decltype">decltype</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">double</span> x; &#125;;</span><br><span class="line"><span class="type">const</span> A* a;</span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x) y;       <span class="comment">// type of y is double (declared type)</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x)) z = y; <span class="comment">// type of z is const double&amp; (lvalue expression)</span></span><br></pre></td></tr></table></figure>
<h2 id="new">new</h2>
<p>The <code>new</code> expression attempts to allocate storage and then attempts to construct and initialize either a single unnamed object, or an unnamed array of objects in the allocated storage. The new-expression returns a prvalue pointer to the constructed object or, if an array of objects was constructed, a pointer to the initial element of the array.</p>
<p>If initialization terminates by throwing an exception (e.g. from the constructor), the program looks up a matching <strong>deallocation</strong> function, then:</p>
<ul>
<li>If a suitable deallocation function can be found, the deallocation function is called to free the memory in which the object was being constructed. After that, the exception continues to propagate in the context of the new-expression.</li>
<li>If no unambiguous matching deallocation function can be found, propagating the exception does not cause the object’s memory to be freed. It is only appropriate if the called allocation function does not allocate memory, otherwise it is likely to result in a memory leak.</li>
</ul>
<p>new 返回 数据类型指针, malloc 返回 void* new 失败抛出bad_alloc异常, malloc 返回 null new 调用构造函数, malloc 不调用构造函数</p>
<h2 id="delete">delete</h2>
<p>只可以删除以下指针</p>
<ol type="1">
<li><p>ptr must be one of</p>
<ul>
<li><p>a null pointer,</p></li>
<li><p>a pointer to a non-array object created by a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/new">new-expression</a>, or</p></li>
<li><p>a pointer to a base subobject of a non-array object created by a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/new">new-expression</a>.</p></li>
</ul>
<p>The pointed-to type of ptr must be <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Similar_types">similar</a> to the type of the object (or of a base subobject). If ptr is anything else, including if it is a pointer obtained by the array form of <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/new">new-expression</a>, the behavior is <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/ub">undefined</a>.</p></li>
<li><p>ptr must be a null pointer or a pointer whose value is previously obtained by an array form of <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/new">new-expression</a> whose <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/new/operator_new">allocation function</a> was not a non-allocating form (i.e. overload (10)). The pointed-to type of ptr must be <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Similar_types">similar</a> to the element type of the array object. If ptr is anything else, including if it is a pointer obtained by the non-array form of <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/new">new-expression</a>, the behavior is <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/ub">undefined</a>.</p></li>
</ol>
<p>The result of the delete-expression always has type void.</p>
<p>If ptr is not a null pointer, the delete-expression invokes the <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a> (if any) for the object that is being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).</p>
<p>对于将函数定义为 delete, 任何调用都是不允许的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sometype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">sometype* p = <span class="keyword">new</span> sometype; <span class="comment">// error: attempts to call deleted sometype::operator new</span></span><br></pre></td></tr></table></figure>
<h2 id="explicit">explicit</h2>
<blockquote>
<p>Specifies that a constructor or conversion function is explicit, that is, it cannot be used for <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/implicit_cast">implicit conversions</a> and <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_initialization">copy-initialization</a>.</p>
<p>A constructor that is declared without the function specifier explicit is called a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/converting_constructor">converting constructor</a>.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) &#123; &#125;      <span class="comment">// converting constructor</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>) &#123; &#125; <span class="comment">// converting constructor (C++11)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK: copy-initialization selects A::A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects A::A(int)</span></span><br><span class="line">    A a3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a4 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// OK: copy-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (a1) &#123; &#125;    <span class="comment">// OK: A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na1 = a1; <span class="comment">// OK: copy-initialization selects A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1); <span class="comment">// OK: static_cast performs direct-initialization</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects B::B(int)</span></span><br><span class="line">    B b3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects B::B(int, int)</span></span><br><span class="line"><span class="comment">//  B b4 = &#123;4, 5&#125;; // error: copy-list-initialization does not consider B::B(int, int)</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (b2) &#123; &#125;    <span class="comment">// OK: B::operator bool()</span></span><br><span class="line"><span class="comment">//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> nb2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b2); <span class="comment">// OK: static_cast performs direct-initialization</span></span><br><span class="line"> </span><br><span class="line">    [](...)&#123;&#125;(a4, a5, na1, na2, b5, nb2); <span class="comment">// may suppress &quot;unused variable&quot; warnings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="friend">friend?</h2>
<p>The friend declaration appears in a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class">class body</a> and grants a function or another class access to private and protected members of the class where the friend declaration appears.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;                   <span class="comment">// friends have access to non-public, non-static</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> id&#123;<span class="number">6</span>&#125;; <span class="comment">// and static (possibly inline) members</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> MyClass&amp;);</span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; in, MyClass&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">change_id</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i = <span class="number">0</span>) : <span class="built_in">i</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> MyClass&amp; mc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">&quot;MyClass::id = &quot;</span> &lt;&lt; MyClass::id &lt;&lt; <span class="string">&quot;; i = &quot;</span> &lt;&lt; mc.i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; in, MyClass&amp; mc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> in &gt;&gt; mc.i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; MyClass::id = id; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">mc</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; mc &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//  mc.i = 333*2;  // error: i is a private member</span></span><br><span class="line">    std::<span class="built_in">istringstream</span>(<span class="string">&quot;100&quot;</span>) &gt;&gt; mc;</span><br><span class="line">    std::cout &lt;&lt; mc &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//  MyClass::id = 222*3;  // error: id is a private member</span></span><br><span class="line">    <span class="built_in">change_id</span>(<span class="number">9</span>);</span><br><span class="line">    std::cout &lt;&lt; mc &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inline">inline</h2>
<blockquote>
<p>A function defined entirely inside a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/classes">class/struct/union definition</a>, is implicitly an inline function.</p>
<p>A function declared <strong>constexpr</strong> on its first declaration is implicitly an inline function.</p>
</blockquote>
<p>Instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</p>
<p>Since this meaning of the keyword inline is non-binding, compilers are free to use inline substitution for any function that's not marked inline, and are free to generate function calls to any function marked inline. Those optimization choices do not change the rules regarding multiple definitions and shared statics listed above.</p>
<h2 id="类关键字">类关键字</h2>
<p>默认 private 继承, private 成员</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 42%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>关键字</th>
<th>类</th>
<th>成员</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public</td>
<td>基类的 public protected 成员保留到子类</td>
<td>任何地方都可以访问</td>
</tr>
<tr class="even">
<td>private</td>
<td>基类的 public protected 成员保留为 private 到子类</td>
<td>只能被成员访问</td>
</tr>
<tr class="odd">
<td>protected</td>
<td>基类的 public protected 成员保留为 protected 到子类</td>
<td>只能被成员或者 friend 访问; 或一级子类(不论如何继承)<br />多级子类需要看如何继承(继承后是否为 private)</td>
</tr>
</tbody>
</table>
<h2 id="sizeof">sizeof</h2>
<blockquote>
<p>Queries size of the object or type. return <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/size_t">std::size_t</a></p>
</blockquote>
<p>The following <code>sizeof</code> expressions always evaluate to 1:</p>
<ul>
<li>sizeof(char)</li>
<li>sizeof(signed char)</li>
<li>sizeof(unsigned char)</li>
</ul>
<p><code>sizeof</code> cannot be used with function types, incomplete types, or bit-field glvalues.</p>
<p>The result of <code>sizeof</code> is always nonzero, even if applied to an empty class type(sizeof(empty class) == 1).</p>
<p>When applied to an expression, sizeof does not evaluate the expression <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="function"><span class="keyword">sizeof</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span> (<span class="built_in">func</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<h2 id="virtual">virtual</h2>
<h1 id="存储关键字">存储关键字</h1>
<blockquote>
<p>默认情况下是<em>automatic</em> storage duration.</p>
</blockquote>
<p>storage duration</p>
<ul>
<li><strong>automatic storage duration.</strong> The storage for the object is allocated at the beginning of the enclosing code block and deallocated at the end. 生存在代码块范围内</li>
<li><strong>static storage duration.</strong> The storage for the object is allocated when the program begins and deallocated when the program ends. 生存在程序开始和程序结束之间. Only one instance of the object exists. All objects declared at namespace scope (including global namespace) have this storage duration, plus those declared with static or extern.</li>
<li><strong>thread storage duration.</strong> The storage for the object is allocated when the thread begins and deallocated when the thread ends. 生存在线程开始和线程结束之间. Each thread has its own instance of the object.</li>
<li><strong>dynamic storage duration.</strong> The storage for the object is allocated and deallocated upon request by using dynamic memory allocation functions. 生存范围手动决定 new delete</li>
</ul>
<p>linkage</p>
<ul>
<li><p>No linkage The name can be referred to only from the scope it is in. 一般在代码块内的无static extern 的都是 no linkage</p></li>
<li><p>Internal linkage The name can be referred to from all scopes in the current translation unit.</p>
<p>在命名空间内 variables of <strong>non-volatile const-qualified type</strong>, unless</p>
<ul>
<li>they are explicitly declared extern, or</li>
<li>they were previously declared and the prior declaration did not have internal linkage;</li>
</ul></li>
<li><p>External linkage The name can be referred to from the scopes in the other translation units. Variables and functions with external linkage also have language linkage, which makes it possible to link translation units written in different programming languages.</p>
<p>Any of the following names declared at namespace scope have external linkage, unless they are declared in an unnamed namespace:</p>
<ul>
<li>variables and functions not listed above (that is, functions not declared static, non-const variables not declared static, and any variables declared extern);</li>
<li>enumerations;</li>
<li>names of classes, their member functions, static data members (const or not), nested classes and enumerations, and functions first introduced with</li>
<li>friend declarations inside class bodies;</li>
<li>names of all templates not listed above (that is, not function templates declared static).</li>
<li>Any of the following names first declared at block scope have external linkage:
<ul>
<li>names of variables declared extern;</li>
<li>names of functions.</li>
</ul></li>
</ul></li>
</ul>
<h2 id="register">register</h2>
<blockquote>
<p>automatic storage duration. Also hints to the compiler to place the object in the processor's register. (已被遗弃)</p>
</blockquote>
<h2 id="static">static</h2>
<blockquote>
<p><em>static</em> or <em>thread</em> storage duration and <em>internal</em> linkage</p>
</blockquote>
<p>When used in a declaration of a class member, it declares a static member. When used in a declaration of an object, it specifies static storage duration (except if accompanied by thread_local). When used in a declaration at namespace scope, it specifies internal linkage.</p>
<h2 id="extern">extern</h2>
<blockquote>
<p><em>static</em> or <em>thread</em> storage duration and <em>external</em> linkage.</p>
</blockquote>
<p>It specifies external linkage it cannot be used in a definition of an automatic storage duration object, so all extern objects have static or thread durations.</p>
<h2 id="thread_local">thread_local</h2>
<blockquote>
<p>thread storage duration.</p>
</blockquote>
<p>It indicates that the object has thread storage duration. If thread_local is the only storage class specifier applied to a block scope variable, static is also implied. It can be combined with static or extern to specify internal or external linkage (except for static data members which always have external linkage) respectively.</p>
<h2 id="mutable">mutable</h2>
<blockquote>
<p>影响 const 和 volatile</p>
</blockquote>
<ul>
<li>mutable - permits modification of the class member declared mutable even if the containing object is declared const (i.e., the class member is mutable).</li>
</ul>
<h1 id="类型转换">类型转换</h1>
<h2 id="const_cast">const_cast</h2>
<h2 id="dynamic_cast">dynamic_cast</h2>
<p>Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.</p>
<p>如果成功, 返回对应类型的 value 如果失败</p>
<ul>
<li>如果是指针, 返回 null</li>
<li>如果是引用, throw std::bad_cast</li>
</ul>
<h1 id="表达式">表达式</h1>
<h2 id="constant-expressions">Constant expressions</h2>
<blockquote>
<p>定义编译时可以取得的值</p>
</blockquote>
<p>可以用于: 模版参数, 数组长度等</p>
<p>不包括以下所有计算的expression 是 core constant expression</p>
<ol type="1">
<li>this 指针(除了?)</li>
<li>static or thread-local <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/storage_duration">storage duration</a>?</li>
<li>不是 constexpr 的函数调用</li>
<li>左右值转换?</li>
<li>new delete</li>
<li>throw</li>
</ol>
<p>A constant expression is either</p>
<ul>
<li>an lvalue core constant expression that refers to
<ul>
<li>an object with static storage duration that is not a temporary, or</li>
<li>a function</li>
</ul></li>
<li>a prvalue core constant expression whose value satisfies the following constraints:
<ul>
<li>if the value is an object of class type, each non-static data member of reference type refers to an entity that satisfies the constraints for lvalues above</li>
<li>if the value is of pointer type, it holds
<ul>
<li>address of an object with static storage duration</li>
<li>address past the end of an object with static storage duration</li>
<li>address of a function</li>
<li>a null pointer value</li>
</ul></li>
<li>if the value is an object of class or array type, each subobject satisfies these constraints for values</li>
</ul></li>
</ul>
<h2 id="操作符">操作符</h2>
<h3 id="alignof">alignof</h3>
<p>If the type is reference type, the operator returns the alignment of referenced type; if the type is array type, alignment requirement of the element type is returned.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span>   i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">long</span> <span class="type">double</span>)) Foo2 &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alignment of&quot;</span>  <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- char            : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- pointer         : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>*)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- class Foo       : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- class Foo2      : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo2)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- empty class     : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty)   &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Alignment of</span></span><br><span class="line"><span class="comment">- char            : 1</span></span><br><span class="line"><span class="comment">- pointer         : 8</span></span><br><span class="line"><span class="comment">- class Foo       : 4</span></span><br><span class="line"><span class="comment">- class Foo2      : 16</span></span><br><span class="line"><span class="comment">- empty class     : 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="std">std</h1>
<h2 id="vector">vector</h2>
<ul>
<li><p>构造函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// C++11 initializer list syntax:</span></span><br><span class="line">    std::vector&lt;std::string&gt; words1&#123;<span class="string">&quot;the&quot;</span>, <span class="string">&quot;frogurt&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;also&quot;</span>, <span class="string">&quot;cursed&quot;</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1: &quot;</span> &lt;&lt; words1;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// words2 == words1</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">words2</span><span class="params">(words1.begin(), words1.end())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2: &quot;</span> &lt;&lt; words2;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// words3 == words1</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">words3</span><span class="params">(words1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3: &quot;</span> &lt;&lt; words3;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// words4 is &#123;&quot;Mo&quot;, &quot;Mo&quot;, &quot;Mo&quot;, &quot;Mo&quot;, &quot;Mo&quot;&#125;</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">words4</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;Mo&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4: &quot;</span> &lt;&lt; words4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>倒数第二个元素</p>
<p><code>int mySize = vec.size();</code></p>
<p><code>vec.at(mySize -2);比*(vec.end() - 2)</code></p></li>
<li><p><code>v.empty()</code></p></li>
<li><p><code>v.size()</code> 元素数量</p></li>
<li><p><code>v.clear()</code></p></li>
<li><p><code>v.insert()</code>都是在 pos 之前插入(如果要插到尾部用 pos=end())</p>
<ol type="1">
<li>iterator insert( const_iterator pos, const T&amp; value );</li>
<li>iterator insert( const_iterator pos, T&amp;&amp; value );</li>
<li>iterator insert( const_iterator pos, size_type count, const T&amp; value );</li>
<li>template&lt; class InputIt &gt;</li>
<li>iterator insert( const_iterator pos, InputIt first, InputIt last );</li>
<li>iterator insert( const_iterator pos, std::initializer_list<T> ilist );</li>
</ol></li>
<li><p><code>v.erase()</code></p>
<ol type="1">
<li>iterator erase( const_iterator pos );删除 pos 位置的元素</li>
<li>iterator erase( const_iterator first, const_iterator last );删除 [first, last) 位置的元素</li>
</ol></li>
<li><p><code>v.swap(vector&amp; other)</code> Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.</p></li>
<li><p><code>v.resize()</code></p>
<p>void resize( size_type count ); void resize( size_type count, const value_type&amp; value ); Resizes the container to contain count elements, does nothing if count == size().</p>
<p>If the current size is greater than count, the container is reduced to its first count elements.</p>
<p>If the current size is less than count,</p>
<ol type="1">
<li>additional default-inserted elements are appended.</li>
<li>additional copies of value are appended.</li>
</ol></li>
<li><p><code>void swap( std::vector&lt;T, Alloc&gt;&amp; lhs, std::vector&lt;T, Alloc&gt;&amp; rhs );</code></p></li>
</ul>
<h1 id="其他">其他</h1>
<h2 id="编译时-运行时">编译时 运行时</h2>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 48%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Compile-time constants</th>
<th>Run-time constants</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1.</td>
<td style="text-align: center;">A compile-time constant is a value that is computed at the compilation-time.</td>
<td>Whereas, A runtime constant is a value that is computed only at the time when the program is running.</td>
</tr>
<tr class="even">
<td style="text-align: center;">2.</td>
<td style="text-align: center;">A compile-time constant will have the same value each time when the source code is run.</td>
<td>A runtime constant can have a different value each time the source code is run.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">It is generally used while declaring an array size.</td>
<td>It is not preferred for declaring an array size.</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">If you use <strong>const int size = 5</strong> for defining a <strong>case expression</strong> it would run smoothly and won’t produce any compile-time error.</td>
<td>Here, if you use run-time constant in your source code for defining case expression then it will yield a compile-time error.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">It does not produces any compile time error when used for initializing an enumerator.</td>
<td>Same compilation error, if runtime constant is used for initializing an enumerator.</td>
</tr>
</tbody>
</table>
<h2 id="null-nullptr">null nullptr</h2>
<p>nullptr has type std::nullptr_t. It's implicitly convertible to any pointer type. Thus, it'll match std::nullptr_t or pointer types in overload resolution, but not other types such as int.</p>
<p>0 (aka. C's NULL bridged over into C++) could cause ambiguity in overloaded function resolution</p>
<h1 id="named-requirements">named requirements</h1>
<h1 id="literaltype">LiteralType</h1>
<p>A literal type is any of the following:</p>
<ul>
<li>scalar type;</li>
<li>reference type;</li>
<li>an array of literal type;</li>
<li>possibly cv-qualified class type that has all of the following properties:
<ul>
<li>has a trivial destructor,
<ul>
<li>is one of
<ul>
<li>an aggregate union type that
<ul>
<li>has no variant members, or</li>
<li>has at least one variant member of non-volatile literal type,</li>
</ul></li>
<li>a non-union aggregate type, and each of its anonymous union members
<ul>
<li>has no variant members, or</li>
<li>has at least one variant member of non-volatile literal type,</li>
</ul></li>
<li>a type with at least one constexpr (possibly template) constructor that is not a copy or move constructor,</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h1 id="cpp-memory-layout">cpp memory layout</h1>
<h2 id="整体分区">整体分区</h2>
<ol type="1">
<li><p>text segment Also, know as Code segment, Contains executable instructions. Usually, Text segment is sharable and hence only a single copy exists as well as its read-only.</p></li>
<li><p>data segment 分为两部分</p>
<ol type="1">
<li><p>初始化数据区</p>
<p>包括初始化了的 global 和 static 变量</p></li>
<li><p>未初始化数据区(BSS segment)</p>
<p>在程序执行前由 kernal 初始化为 0</p></li>
</ol></li>
<li><p>stack 存放临时变量和虚指针? stack frame: 一次函数调用 push 进 stack 的一组值</p></li>
<li><p>heap 动态分配</p></li>
</ol>
<h2 id="对象内存布局">对象内存布局</h2>
<h3 id="简单对象">简单对象</h3>
<ol type="1">
<li>stack
<ol type="1">
<li>成员变量</li>
</ol></li>
<li>text segment
<ol type="1">
<li>成员函数</li>
</ol></li>
</ol>
<h3 id="有-virtual-和-static-的对象">有 virtual 和 static 的对象</h3>
<ol type="1">
<li>stack
<ol type="1">
<li>成员变量</li>
<li>_vptr</li>
</ol></li>
<li>text segment
<ol type="1">
<li>成员函数</li>
<li>static 成员函数</li>
</ol></li>
<li>data segment
<ol type="1">
<li>静态成员变量</li>
</ol></li>
</ol>
<h3 id="有继承的对象">有继承的对象</h3>
<ol type="1">
<li>stack
<ol type="1">
<li>派生类和父类成员变量</li>
<li>_vptr</li>
</ol></li>
<li>text segment
<ol type="1">
<li>派生类父类成员函数</li>
</ol></li>
</ol>
<h3 id="多继承和虚函数的对象">多继承和虚函数的对象</h3>
<ol type="1">
<li>stack
<ol type="1">
<li>成员变量</li>
<li>每个父类对应一个 _vptr</li>
</ol></li>
<li>text segment
<ol type="1">
<li>成员函数</li>
</ol></li>
</ol>
<h1 id="表">表?</h1>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 15%" />
<col style="width: 35%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="header">
<th>类型</th>
<th>生存周期</th>
<th>linkage</th>
<th>其他</th>
<th>?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>local variable</td>
<td>automatic storage duration</td>
<td>No linkage</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>global variable</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>function</td>
<td></td>
<td>External linkage</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>member variable</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>member function</td>
<td></td>
<td>External linkage</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>class?</td>
<td></td>
<td>External linkage</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>static variable</td>
<td>static storage duration</td>
<td>Internal linkage</td>
<td>Only one instance of the object exists</td>
<td></td>
</tr>
<tr class="even">
<td>static function</td>
<td></td>
<td>Internal linkage</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>static member variable</td>
<td></td>
<td>External linkage</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>static member function</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>extern variable</td>
<td>static storage duration</td>
<td>External linkage</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>extern function</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>extern member variable</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>extern member function</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2024/03/59cb1b4312ed.html">https://sinos_wei.gitee.io/2024/03/59cb1b4312ed.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover/00000075.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/02/e58fa025421e.html" title="express"><img class="cover" src="/img/cover/IMG_2142.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">express</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SinosGray"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SinosGray" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1143474942@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://8.130.42.149:5230" target="_blank" title="memo"><i class="fab fa-heart"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C-odrone-definition-rule"><span class="toc-number">1.1.</span> <span class="toc-text">定义和 ODR(one definition rule)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4"><span class="toc-number">1.4.</span> <span class="toc-text">范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#name-lookup"><span class="toc-number">1.6.</span> <span class="toc-text">name lookup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#adlargument-dependent-lookup"><span class="toc-number">1.7.</span> <span class="toc-text">ADL(Argument-dependent lookup)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phases-of-translation"><span class="toc-number">1.8.</span> <span class="toc-text">Phases of translation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">main 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">2.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-volatile"><span class="toc-number">2.2.</span> <span class="toc-text">const volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constexpr"><span class="toc-number">2.3.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-vs.-constexpr"><span class="toc-number">2.4.</span> <span class="toc-text">const vs. constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">2.5.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new"><span class="toc-number">2.6.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete"><span class="toc-number">2.7.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-number">2.8.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#friend"><span class="toc-number">2.9.</span> <span class="toc-text">friend?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline"><span class="toc-number">2.10.</span> <span class="toc-text">inline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.11.</span> <span class="toc-text">类关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof"><span class="toc-number">2.12.</span> <span class="toc-text">sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual"><span class="toc-number">2.13.</span> <span class="toc-text">virtual</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">存储关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#register"><span class="toc-number">3.1.</span> <span class="toc-text">register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">3.2.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern"><span class="toc-number">3.3.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread_local"><span class="toc-number">3.4.</span> <span class="toc-text">thread_local</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutable"><span class="toc-number">3.5.</span> <span class="toc-text">mutable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const_cast"><span class="toc-number">4.1.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic_cast"><span class="toc-number">4.2.</span> <span class="toc-text">dynamic_cast</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#constant-expressions"><span class="toc-number">5.1.</span> <span class="toc-text">Constant expressions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alignof"><span class="toc-number">5.2.1.</span> <span class="toc-text">alignof</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std"><span class="toc-number">6.</span> <span class="toc-text">std</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">6.1.</span> <span class="toc-text">vector</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">7.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6-%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">7.1.</span> <span class="toc-text">编译时 运行时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null-nullptr"><span class="toc-number">7.2.</span> <span class="toc-text">null nullptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#named-requirements"><span class="toc-number">8.</span> <span class="toc-text">named requirements</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#literaltype"><span class="toc-number">9.</span> <span class="toc-text">LiteralType</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp-memory-layout"><span class="toc-number">10.</span> <span class="toc-text">cpp memory layout</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%88%86%E5%8C%BA"><span class="toc-number">10.1.</span> <span class="toc-text">整体分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">10.2.</span> <span class="toc-text">对象内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.2.1.</span> <span class="toc-text">简单对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89-virtual-%E5%92%8C-static-%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.2.2.</span> <span class="toc-text">有 virtual 和 static 的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.2.3.</span> <span class="toc-text">有继承的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.2.4.</span> <span class="toc-text">多继承和虚函数的对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">表?</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/59cb1b4312ed.html" title="cppdoc"><img src="/img/cover/00000075.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cppdoc"/></a><div class="content"><a class="title" href="/2024/03/59cb1b4312ed.html" title="cppdoc">cppdoc</a><time datetime="2024-03-14T13:13:29.240Z" title="Updated 2024-03-14 21:13:29">2024-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/f05961026253.html" title="数据结构"><img src="/img/cover/00000074.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/2023/05/f05961026253.html" title="数据结构">数据结构</a><time datetime="2024-03-05T06:20:26.634Z" title="Updated 2024-03-05 14:20:26">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/528ebafedd20.html" title="rfc笔记"><img src="/img/cover/32222.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rfc笔记"/></a><div class="content"><a class="title" href="/2024/01/528ebafedd20.html" title="rfc笔记">rfc笔记</a><time datetime="2024-03-05T04:21:10.802Z" title="Updated 2024-03-05 12:21:10">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/724d57ab8c34.html" title="操作系统"><img src="/img/cover/00000129.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2023/05/724d57ab8c34.html" title="操作系统">操作系统</a><time datetime="2024-03-05T03:24:13.030Z" title="Updated 2024-03-05 11:24:13">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/625740ff980e.html" title="git-tips"><img src="/img/cover/00000179.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git-tips"/></a><div class="content"><a class="title" href="/2023/08/625740ff980e.html" title="git-tips">git-tips</a><time datetime="2024-03-04T10:02:47.316Z" title="Updated 2024-03-04 18:02:47">2024-03-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>