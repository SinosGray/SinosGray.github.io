<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>课程提纲(乱) | Sinos_wei's blog</title><meta name="author" content="Sinos_wei"><meta name="copyright" content="Sinos_wei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="课程提纲(乱)">
<meta property="og:url" content="https://sinos_wei.gitee.io/2021/12/21/%E8%AF%BE%E7%A8%8B-%E6%80%BB/index.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/icon.JPG">
<meta property="article:published_time" content="2021-12-21T12:49:27.000Z">
<meta property="article:modified_time" content="2022-06-08T04:45:19.603Z">
<meta property="article:author" content="Sinos_wei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/icon.JPG"><link rel="shortcut icon" href="/img/icon.JPG"><link rel="canonical" href="https://sinos_wei.gitee.io/2021/12/21/%E8%AF%BE%E7%A8%8B-%E6%80%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '课程提纲(乱)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-08 12:45:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">31</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/icon.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Sinos_wei's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">课程提纲(乱)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-12-21T12:49:27.000Z" title="Created 2021-12-21 20:49:27">2021-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-06-08T04:45:19.603Z" title="Updated 2022-06-08 12:45:19">2022-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/class/">class</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="课程提纲(乱)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
</blockquote>
<span id="more"></span>

<h1 id="MOOC"><a href="#MOOC" class="headerlink" title="MOOC"></a>MOOC</h1><h2 id="第一章-计算机网络与因特网"><a href="#第一章-计算机网络与因特网" class="headerlink" title="第一章 计算机网络与因特网"></a>第一章 计算机网络与因特网</h2><ul>
<li><p>协议: 语法, 语义, 同步</p>
</li>
<li><p>C/S P2P</p>
</li>
<li><p>接入</p>
<ul>
<li>点对点<ul>
<li>电话线 ADSL 非对称数字用户环线（Asymmetrical Digital Subscriber Loop）双绞铜线</li>
<li>电缆/光纤混合线路 HFC (电视)</li>
<li>光纤到户 FTTH</li>
<li>卫星</li>
</ul>
</li>
<li>以太网/wifi<ul>
<li>有线以太网 双绞铜线</li>
<li>wifi</li>
</ul>
</li>
<li>广域无线网</li>
</ul>
</li>
<li><p>网络核心</p>
<ul>
<li>电路交换网络<ul>
<li>分频复用 FDM</li>
<li>时分复用 TDM</li>
</ul>
</li>
<li>报文交换</li>
<li>分组交换<ul>
<li>数据报网络(纯分组交换)</li>
<li>虚电路网络, 需要建立连接</li>
</ul>
</li>
</ul>
</li>
<li><p>时延丢包吞吐量</p>
<p>R 链路带宽, L 分组长度, a 平均分组到达速率</p>
<p>流量强度 L*a/R , 与 1 进行比较</p>
</li>
<li><p>层次化的网络体系</p>
<p>应用层, 传输层, 网络层, 链路层, 物理层</p>
<p>协议三要素: 语法, 语义, 同步</p>
<p>协议栈</p>
</li>
<li><p>网络体系结构模型</p>
<p>OSI: 表示层, 会话层(在应用层之上)</p>
</li>
<li><p>因特网中的复用和分解</p>
<ul>
<li><p>报文复用</p>
<p>时分复用带宽</p>
<p>频分复用带宽</p>
<p>同时使用</p>
</li>
<li><p>报文分解</p>
<ul>
<li><p>针对应用进程</p>
<p>套接字: ip 地址 + 端口号 -&gt; 标识进程</p>
</li>
<li><p>针对电路层</p>
<p>时分复用 –&gt; 统计时分复用(当 A 当前无传输, 就分给下一个)</p>
<p>频分复用</p>
<p>码分多址(CDMA) 码片? 互相之间正交, </p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据差错的检查</p>
</li>
</ul>
<h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><ul>
<li><p>应用层协议原理</p>
<p>CS 体系结构 p2p 体系结构 混合体系结构</p>
<p>应用层协议定义了</p>
<ul>
<li>交换报文的类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>进程何时, 如何发送报文及对报文进行响应</li>
</ul>
<p>服务</p>
</li>
<li><p>万维网与 http</p>
<ul>
<li><p>web 的构成</p>
<p>web 服务器</p>
<p>浏览器</p>
<p>协议: 信息表达的协议(html), 信息传输的协议(http)</p>
</li>
<li><p>web 内容的表达: html</p>
</li>
<li><p>web 内容的传输: tcp 端口 80</p>
<p>http1.0 非持久性链接 RTT * 2 + 文件传输时间</p>
<p>http1.1 持久性连接 分为: 非流水, 流水</p>
</li>
<li><p>http 报文类型</p>
<ul>
<li><p>http 请求报文</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjb6r2za4aj30y40fuwt9.jpg" alt="截屏2020-10-02 下午6.52.38"></p>
<p>定义的方法:</p>
<ul>
<li>get 向服务器请求指定url 的对象</li>
<li>post 向服务器提交表单数据, 也可以同时请求一个 web 页面</li>
<li>head 返回响应报文, 不包含请求的对象</li>
<li>put 上传的文件放在实体主体字段中, 目标路径由 url 字段标明</li>
<li>delete 删除 url 字段中指定的文件</li>
</ul>
</li>
<li><p>http 响应报文</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjb6vgjgthj31040e2nc8.jpg" alt="截屏2020-10-02 下午6.57.02"></p>
<p>响应状态码和短语</p>
<ul>
<li>200 ok, 请求成功, 被请求的对象在报文里</li>
<li>301 moved permanently 被请求的对象被移动过, 新的位置在报文中有说明(location)</li>
<li>400 bad request 服务器不懂请求报文</li>
<li>404 not found 服务器上找不到请求的对象</li>
<li>505 http version not supported 服务器不支持请求报文使用的 http 协议版本</li>
</ul>
</li>
<li><p>用户服务器交互 cookie</p>
<ul>
<li>目的: 限制用户的访问, 把内容和用户的身份关联起来</li>
<li>技术组成:<ul>
<li>在 http 响应报文中有一个 cookie 首部行</li>
<li>在 http 请求报文中也有一个 cookie 首部行</li>
<li>在用户的端系统保留了一个 cookie 文件, 由用户浏览器负责管理</li>
<li>在 web 站点有一个后端数据库</li>
</ul>
</li>
<li>私密性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>smtp</p>
<ul>
<li><p>电子邮件系统的构成</p>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>smtp 用在邮件服务器之间发送邮件<ul>
<li>客户端将邮件发到服务器</li>
<li>服务器接收和转发邮件</li>
</ul>
</li>
</ul>
</li>
<li><p>tcp 端口 25, 三个阶段: 握手, 报文传输, 结束 命令响应类型: 命令 ascii 码, 响应状态码和短语</p>
</li>
<li><p>邮件传输过程</p>
<ul>
<li>持续链接</li>
<li><strong>7 bit ascii 码</strong></li>
<li>crlf 表示邮件结束</li>
</ul>
</li>
<li><p>报文格式 rfc 822</p>
</li>
<li><p>客户机获取邮件的方法</p>
<ul>
<li><p>pop3 协议</p>
<p>认证, 交互(下载删除-下载保存), 退出</p>
<p>会话无状态</p>
</li>
<li><p>imap 协议</p>
<p>所有邮件保存在服务器上</p>
</li>
<li><p>http 协议</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>域名解析 DNS</p>
<ul>
<li><p>分布式数据库 运行在端到端系统, 使用 udp 端口 53 应用层</p>
</li>
<li><p>过程</p>
</li>
<li><p>ddos 攻击, 重定向攻击</p>
</li>
</ul>
</li>
<li><p>p2p 协议</p>
<ul>
<li>bittorrent</li>
</ul>
</li>
</ul>
<h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><ul>
<li><p>概述</p>
<p>网络层: 不同主机之间的逻辑通信</p>
<p>运输层: 应用进程之间的逻辑通信</p>
</li>
<li><p>端口和套接字</p>
</li>
<li><p>无连接传输UDP</p>
<p>1.多路复用, 多路分解</p>
<p>2.差错检查</p>
<p>数据报结构: </p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk46xm0jvyj30lq0botd5.jpg" alt="截屏2020-10-27 下午9.01.21"></p>
</li>
<li><p>可靠数据传输</p>
<ul>
<li><p>概述</p>
<p>可靠传输</p>
<ol>
<li>数据在传输过程中不会丢失</li>
<li>数据在传输过程中不会出错</li>
</ol>
<p>FSM 有限状态机</p>
</li>
<li><p>分类</p>
<ul>
<li><p>可靠信道上的可靠传输</p>
</li>
<li><p>比特受损, 但可按序接受不会丢失</p>
<p><strong>简单停等协议</strong></p>
<ol>
<li>差错检测</li>
<li>ƒ接收方反馈 ACK NAK</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk47cwe8paj30m20csdp0.jpg" alt="截屏2020-10-27 下午9.16.04"></p>
<p>问题: ack 和 nak 也会受损</p>
<p>方案: 编号, 对分组进行编号, 便于接收方识别重复分组, 区分连续的两个分组(0, 1)</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk47g4h758j30n40e8tje.jpg" alt=" "></p>
<p>改进: 只有 ack, 给 ack 加上编号, 接收方对最后一个正确收到的分组发送 ack, double ACK = NAK</p>
</li>
<li><p>数据会丢失</p>
<p><strong>实用停等协议</strong></p>
<p>问题: 如何检测丢包</p>
<p>方案: 等待, 计时器</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk47lx65jlj30na0fedrq.jpg" alt="截屏2020-10-27 下午9.24.31"></p>
</li>
<li><p><strong>滑动窗口协议</strong></p>
<p>问题: 解决硬件利用率不高的问题</p>
<p>方案: 允许发送方发送多个分组而无需等待确认</p>
<ol>
<li>必须增大序号范围</li>
<li>发送方和接收方需要对分组缓存</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk47v2aecsj30na06aadl.jpg" alt="截屏2020-10-27 下午9.33.30"></p>
<p>分组丢失了怎么办?</p>
<ul>
<li><p><strong>GBN</strong> <strong>协议</strong>: 其后的分组全部重传</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk47znelcfj30oa0fgqh0.jpg" alt="截屏2020-10-27 下午9.37.56"></p>
</li>
<li><p><strong>SR</strong> <strong>协议</strong>: 仅重传该分组</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk481a17asj30n60f0tl4.jpg" alt="截屏2020-10-27 下午9.39.31"></p>
</li>
<li><p>序号问题</p>
<p>发送窗口的序号和接受窗口的序号不能重复</p>
<p>两个窗口的序号均在 2^k^-1 内, 发送方+接收方 &lt;= 2^k^</p>
<p>GBN : 发送方&lt; 2^k^-1 接收方 = 1</p>
<p>SR: 接收方 = 发送方 &lt;= 2^k-1^</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP</p>
<ul>
<li><p>报文首部结构</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk487oge6jj30se0byq99.jpg" alt="截屏2020-10-27 下午9.45.39"></p>
<p>序号: 对字节流的编号, 在报文段数据中第一个字节在字节流中的编号</p>
<p>确认号: 期望号(ACK=1), 期待得到的下一个字节的 seq</p>
<p>窗口: 流量监测</p>
<p>紧急指针: URG, PSH 开关</p>
<p>tcp 没有规定如何处理乱序报文段, 由实现者实现</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk48ibp1ctj30o40bw44s.jpg" alt="截屏2020-10-27 下午9.55.51"></p>
</li>
<li><p>tcp 超时</p>
<p>样本 RTT </p>
<p>EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT</p>
<p>α = 0.125 第一次 EstimatedRTT = SampleRTT</p>
<p>偏差 RTT</p>
<p>DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|</p>
<p>β = 0.25 第一次 DevRTT = 0.5 * SampleRTT</p>
<p>TCP 中的超时间隔</p>
<p>TimeoutInterval = EstimatedRTT + 4 * DevRTT</p>
</li>
<li><p>TCP 的可靠数据传输</p>
<p>tcp 的确认永远是期待的分组</p>
<ul>
<li><p>快速重传: 在超时到来之前重传报文段</p>
<p>如果发送方收到一个数据的<strong>三个重复 ACK</strong>, 它会认为确认数据之后的报文段丢失</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk4zstl2kzj30c60eytdx.jpg" alt="截屏2020-10-28 下午1.40.03"></p>
<p>每一次 TCP 重传均将下一次超时间隔设为先前值的两倍</p>
</li>
</ul>
</li>
<li><p>TCP 流量控制</p>
<ul>
<li><p>可变流量窗口: 将接收方缓冲区的空闲空间发给发送方</p>
<p>剩余空间为 0 时, 为了避免假死, 发送方发送一个字节的试探报文</p>
</li>
</ul>
</li>
<li><p>TCP 连接管理</p>
<ul>
<li><p>TCP 链接的建立</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk500xl5iaj30li0b2jy5.jpg" alt="截屏2020-10-28 下午1.47.57"></p>
</li>
<li><p>TCP 连接的释放</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk5717czi7j30ms0dcdp7.jpg" alt="截屏2020-10-28 下午5.50.24"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk5721ezljj30ni0emn72.jpg" alt="截屏2020-10-28 下午5.51.11"></p>
</li>
<li><p>TCP 链接管理的状态序列</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk577xhb9gj30pa0cqwol.jpg" alt="截屏2020-10-28 下午5.56.52"></p>
<p>两个 establish 状态可能不同步</p>
</li>
</ul>
</li>
<li><p>拥塞控制</p>
<p>拥塞: 过多的源发送了过多的数据, 超出了网络的处理能力</p>
<p>和流量控制不同的是, 流量控制是发送方发送了过多的数据, 拥塞控制是过多数据积压在网络核心</p>
<p>现象: 延时长, 包丢失</p>
<p>拥塞的开销:</p>
<ol>
<li>发送方必须重传以补偿因为缓存溢出而丢失的分组</li>
<li>发送方在遇到大时延锁进行的不必要重传会引起路由器转发不必要的分组拷贝而占用其链路带宽</li>
<li>当分组被丢弃时, 该分组曾用到的所有上游传输容量被浪费了</li>
</ol>
<p>网络辅助的拥塞控制的方法</p>
<ol>
<li>直接网络反馈: 路由器以阻塞分组的形式通知发送方”网络堵塞了”</li>
<li>经由接收方的网络反馈: 路由器标识从发送方流向接收方分组的某个字段以知识拥塞产生, 由接收方通知发送方网络拥塞了</li>
</ol>
<p>端到端的拥塞控制</p>
<ol>
<li>网络层部位拥塞控制提供任何帮助和支持</li>
<li>端系统通过对网络行为观测判断网络是否发生拥塞</li>
<li>TCP 采用以上方法</li>
</ol>
</li>
<li><p>TCP 的拥塞控制</p>
<p>端到端的拥塞控制</p>
<ul>
<li><p>拥塞窗口</p>
<p>rate = (CongWin/RTT) bytes/sec</p>
</li>
<li><p>如何感受拥塞</p>
<p>超时, 三个冗余 ACK</p>
</li>
<li><p>拥塞控制算法(Reno 算法)</p>
<p>加性增, 乘性减(AIMD)</p>
<blockquote>
<p>mss 最大报文段长度</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk57t0k08kj30ng0emdqq.jpg" alt="截屏2020-10-28 下午6.17.07"></p>
<p>指数增加到一个门限值</p>
<p>指数增加阶段 -&gt; 慢启动, 线性增加阶段 -&gt; 拥塞避免</p>
<ul>
<li>对收到三个重复 ACK 的反应: 快速重传<ol>
<li>门限值设为当前 CongWin 的一半</li>
<li>将 CongWin 减为新的门限值+3 MSS</li>
<li>线性增加拥塞窗口</li>
</ol>
</li>
<li>超时时间的反应<ol>
<li>门限值设为当前 CongWin 的一半</li>
<li>将 CongWin 设为 1  MSS</li>
<li>窗口以指数速度增大</li>
<li>窗口增大到门限值以后, 在以线性速度增加</li>
</ol>
</li>
<li>Reno总结<ol>
<li>门限值 Threshold 决定出于慢启动阶段还是拥塞避免阶段</li>
<li>triple ACK 门限值变为一半, CongWin 设为门限值+3 MSS</li>
<li>超时 门限值变为一半, CongWin 设为 1 MSS</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><ul>
<li><p>网络层概述</p>
<p>实现主机到主机的通信</p>
<ol>
<li><p>如何选路</p>
</li>
<li><p>如何转发</p>
</li>
<li><p>确定是否可达</p>
</li>
</ol>
<p>为传输层提供选路转发服务</p>
<ol>
<li>虚电路服务<ol>
<li>收发双方的路径和电话线路一样</li>
<li>数据传输前呼叫建立, 传输后断开连接</li>
<li>每一个分组携带虚电路标识(而不是目的主机的地址)</li>
<li>路径上的每个路由器必须维持连接状态信息</li>
</ol>
</li>
<li>数据报服务<ol>
<li>在网络层没有建立连接过程</li>
<li>不维护连接状态信息</li>
<li>同一对主机的报文可能会走不同的路径</li>
</ol>
</li>
</ol>
</li>
<li><p>路由器的工作原理</p>
<p>网路程, 数据链路层, 物理层</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk58gzl5hdj30ng0ea7ec.jpg" alt="截屏2020-10-28 下午6.40.10"></p>
<ul>
<li><p>输入端口</p>
<ul>
<li>线头等待</li>
</ul>
</li>
<li><p>交换结构</p>
<ul>
<li><p>分类: 内存类, 总线类, 内联网络类</p>
<ul>
<li><p>内存交换: </p>
<ol>
<li>输入输出端口的交换是在路由器的直接控制下完成的</li>
<li>分组被拷贝到系统内存中, 在 cpu 控制下转发至输出端口</li>
<li>转发速度受限于内存带宽(每个分组走两次总线)</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6mdsjenrj30jg06k77d.jpg" alt="截屏2020-10-29 下午11.26.40"></p>
</li>
<li><p>总线交换</p>
<ol>
<li>输入报文经共享总线将分组直接转发到输出端口</li>
<li>总线交换速度受限于总线带宽</li>
<li>Cisco5600 内置 32Gbps 总线, 能满足大多接入网或企业网的路由转发速率需求</li>
</ol>
</li>
<li><p>内联网络</p>
<ol>
<li>克服总线带宽限制</li>
<li>Banyan 网络: 用于计算机体系结构中多处理机互连</li>
<li>固定分组转发: 将长度变化的 ip 分组拆分为固定尺寸的信元, 通过交换网络进行转发</li>
<li>Cisco 12000: 通过内联网络交换速度为 60Gbps</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>输出端口</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6mjektnzj30l60emqc4.jpg" alt="截屏2020-10-29 下午11.32.23"></p>
</li>
<li><p>缓存区?</p>
<p>RFC 3439: B = RTT * R</p>
<p>对于有 n 条 tcp 链接的链路: B = RTT * R / n^1/2^ </p>
<p>分组排队丢弃策略: </p>
<ul>
<li>被动管理<ol>
<li>弃尾策略</li>
<li>删除一个或者多个已排队分组</li>
</ol>
</li>
<li>主动管理–随机早期检测 RED<ol>
<li>随机计算平均队列长度 avg<del>th</del></li>
<li>最小阈值 min<del>th</del> 最大阈值 max<del>th</del></li>
<li>avg<del>th</del> 小于 min<del>th</del>, 允许分组入列</li>
<li>avg<del>th</del> 大于 max<del>th</del>, 分组被标记或丢弃</li>
<li>avg<del>th</del> 在 min<del>th</del> 和 max<del>th</del> 之间, 按照概率标记或丢弃分组</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ip 数据报格式</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6n6j8572j30nc0esdnj.jpg" alt="截屏2020-10-29 下午11.54.39"></p>
<p>版本: IPv4 IPv5 IPv6</p>
<p>服务类型: 报文处理方式</p>
<p>生存时间: 控制数据转发的跳数</p>
<p>报头校验和, 只检查首部</p>
<p>协议: 1ICMP 2IGMP 4IP 6TCP 8EGP 17UDP 41IPV6</p>
<p>源地址: 32bit</p>
<p>目的地址: 32bit</p>
<p>首部长度</p>
<p>总长度: 实际长度 = 总长度 - 首部长度, 以太网链路报文只允许 1500 字节</p>
<p>分片相关的字段(MTU)</p>
<p>​    标识: 网络层服务的上层传输层的同一次报文使用相同的表示, 相当于每次会话使用相同表示</p>
<p>​    标志: 1 位保留, 2 位表示能否分片, 3 位表示分片是否结束(1 未结束, 0 结束)</p>
<p>​    片偏移: 每个分片在整个报文中的位置</p>
</li>
<li><p>IP 地址</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6nkk5p1ej30ng0bijwn.jpg" alt="截屏2020-10-30 上午12.08.08"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6nmqs2l5j30nc09wtea.jpg" alt="截屏2020-10-30 上午12.10.16"></p>
<p>NAT</p>
<p>ipv6 报文结构</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6nuwuduwj30no0d4guu.jpg" alt="截屏2020-10-30 上午12.18.02"></p>
</li>
<li><p>子网划分</p>
<p>从主机号中抽取一部分作为子网号, 进行子网划分</p>
<p>子网掩码</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6o2k52w8j30qc0gm7ej.jpg" alt="截屏2020-10-30 上午12.25.25"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6o420nlzj30p00fm49h.jpg" alt="截屏2020-10-30 上午12.26.52"></p>
<ol>
<li>H<del>1</del>先将本子网的子网掩码与分组的 ip 地址相”与”, 不匹配给路由器</li>
<li>路由器根据路由表找到目的网络地址, 进行转发</li>
</ol>
</li>
<li><p>CIDR 无类别域间路由(classless interdomain routing)</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6ofdc3oqj30j007on25.jpg" alt="截屏2020-10-30 上午12.37.45"></p>
<p>/之后是掩码的位数</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6orahcgpj30l00ecn6t.jpg" alt="截屏2020-10-30 上午12.49.10"></p>
</li>
<li><p>网络地址转换 NAT</p>
<ul>
<li><p>解决的问题</p>
<ol>
<li>外网获取的 ip 地址资源有限</li>
<li>内网 ip 地址变动无需告知外网</li>
<li>更换 ISP 后内网 ip 地址不变</li>
<li>内网主机外网不可见</li>
</ol>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk6otwecwaj30oe0c6qar.jpg" alt="截屏2020-10-30 上午12.51.42"></p>
</li>
<li><p>改变</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk9hls0rvzj30ji08i43n.jpg" alt="截屏2020-11-01 上午10.58.23"></p>
</li>
</ul>
</li>
<li><p>ICMP 协议(差错与控制报文协议)</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk9hv8j3abj30o60f8thp.jpg" alt="截屏2020-11-01 上午11.07.31"></p>
<ul>
<li><p>ICMP 报文格式</p>
<ul>
<li><p>信息报文不可达</p>
<ol>
<li>信宿机硬件出现故障或者关机</li>
<li>发送者指定的地址不存在</li>
<li>网关不知道去往信宿的路径</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk9hyeqkgvj30jm06sn10.jpg" alt="截屏2020-11-01 上午11.10.34"></p>
</li>
<li><p>参数出错报文</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk9hzax62lj30ji05ytcd.jpg" alt="截屏2020-11-01 上午11.11.14"></p>
</li>
<li><p>重定向报文</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk9hzmirtsj30km07owik.jpg" alt="截屏2020-11-01 上午11.11.44"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>路由协议概述</p>
<p>好的路由: 无自环, 可收敛, 路径好</p>
<ul>
<li>AS<ul>
<li>AS 内</li>
<li>AS 外</li>
</ul>
</li>
</ul>
</li>
<li><p>选路算法</p>
<ul>
<li><p>OSPF 基于路径成本最优, 是一种 LS 协议</p>
<p>迪克斯特拉算法构造最短路径树, 只记录下一跳的节点, 不记录整个路径</p>
</li>
<li><p>RIP 基于路径距离最短, 是一种 DV 协议</p>
<p>相邻节点</p>
</li>
<li><p>BGP-4 协议</p>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-链路层和局域网"><a href="#第五章-链路层和局域网" class="headerlink" title="第五章 链路层和局域网"></a>第五章 链路层和局域网</h2><ul>
<li><p>ALOHA</p>
</li>
<li><p>CSMA</p>
<ul>
<li>非坚持</li>
<li>1 坚持</li>
<li>p 坚持</li>
</ul>
</li>
<li><p>信道划分协议</p>
<ul>
<li>TDMA</li>
<li>FDMA</li>
</ul>
</li>
<li><p>随机访问协议</p>
</li>
<li><p>轮流协议</p>
</li>
<li><p>令牌传递协议</p>
</li>
<li><p>MAC 地址</p>
<p>48bit 链路层标识</p>
</li>
<li><p>ARP 协议 地址解析协议</p>
</li>
<li><p>以太网</p>
<ul>
<li><p>总线式</p>
</li>
<li><p>交换式</p>
</li>
<li><p>帧: 数据字段, 前同步码, 地址, 类型, CRC</p>
</li>
<li><p>集线器(转发器)</p>
</li>
<li><p>网桥 mac 层 lan 互连</p>
</li>
</ul>
</li>
<li><p>交换机</p>
</li>
<li><p>web:</p>
<p>dhcp dns arp </p>
</li>
</ul>
<h2 id="第六章-wifi"><a href="#第六章-wifi" class="headerlink" title="第六章 wifi"></a>第六章 wifi</h2><h1 id="实验-1-socket-编程"><a href="#实验-1-socket-编程" class="headerlink" title="实验 1 socket 编程"></a>实验 1 socket 编程</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>ip, 端口, 主目录</p>
<p>处理请求, 穿件套接字</p>
<p>确定网页文件</p>
<p>响应报文</p>
<p>tcp</p>
<p>关闭启动</p>
<p>*多媒体的网页</p>
<p>输出请求来源</p>
<p>输出处理结果</p>
<p>显示错误原因, 异常处理</p>
<h1 id="实验-2-rdt-协议"><a href="#实验-2-rdt-协议" class="headerlink" title="实验 2 rdt 协议"></a>实验 2 rdt 协议</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>序号, 窗口大小</p>
<p>Rdt 协议的发送方 RdtSender 和 Rdt 协议的接收方则是学生需要实现的功能，它们共同</p>
<p>实现了 Rdt 协议。其中 RdtSender 必须实现三个函数：send(Message)、receive(Packet)、</p>
<p>timeoutHandler(int seqNum)；RdtReceiver 则必须实现一个函数：receive(Packet)</p>
<p>单向传输, 指定编码报文序号的二进制位数和窗口大小</p>
<p>要求三: </p>
<ul>
<li><p>报文段序号按照报文段为单位进行编号</p>
</li>
<li><p>单一的超时计时器, 指定 timeout 参数</p>
</li>
<li><p>支持快速重传和超时重传</p>
</li>
<li><p>确认号为收到的最后一个报文段序号</p>
</li>
</ul>
<h2 id="模拟环境"><a href="#模拟环境" class="headerlink" title="模拟环境"></a>模拟环境</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RdtSender::<span class="built_in">Send</span>(Message)&#123;</span><br><span class="line">	<span class="built_in">sendToNetworkLayer</span>(Packet);</span><br><span class="line">  <span class="built_in">startTimer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RdtReceiver::<span class="built_in">Receive</span>(Message)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rightdata)</span><br><span class="line">    <span class="built_in">stopTimer</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">startTimer</span>();</span><br><span class="line">  <span class="keyword">if</span>(timeout)</span><br><span class="line">    <span class="built_in">timeoutHandler</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><ul>
<li><p>接收方</p>
<p>属性: base nextseq, N</p>
<p>send: 检查窗口是否已满, 未满则 send, 更新变量</p>
<p>收到 ack: </p>
<p>timeout: 重传所以已经发送但未确认的分组</p>
<p>定时器: 最早发送还未确认的定时器</p>
</li>
<li><p>发送方</p>
<p>按序发送 ack, 否则发送上一个 ack</p>
</li>
</ul>
<h3 id="rdt"><a href="#rdt" class="headerlink" title="rdt"></a>rdt</h3><ul>
<li><p>rdt 1.0 无差错</p>
<p>发送接收</p>
</li>
<li><p>rdt 2.0 比特差错</p>
<p>checksum, ack, nak</p>
<p>除非接收方接收到了正确的数据, 否则发送方不会发送新的数据–停等协议</p>
</li>
<li><p>rdt 2.1 ack 或者 nak 受损</p>
<p>增加序号(sequence number)可以让接收方知道发送方是否在重传一个分组</p>
</li>
<li><p>rdt 2.2 冗余 ack</p>
<p>用两个 ack 表示 nak</p>
</li>
<li><p>rdt 3.0 丢包</p>
<p>等待与重传, 定时器</p>
<p>每发送一个分组就启动定时器</p>
</li>
<li><p>流水线 解决 RTT 占比过多的问题</p>
<p>每一个分组都要有自己的序号, 接收方和发送方要有缓冲区, 对于损坏的分组如何处理(GBN, SR)</p>
</li>
</ul>
<h1 id="cpp-实验tips"><a href="#cpp-实验tips" class="headerlink" title="cpp 实验tips"></a>cpp 实验tips</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><h3 id="struct-中的-const-成员"><a href="#struct-中的-const-成员" class="headerlink" title="struct 中的 const 成员"></a>struct 中的 const 成员</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj7iqelf3jj30rm0digmj.jpg" alt="截屏2020-09-29 下午2.45.05"></p>
<h3 id="初始化-struct"><a href="#初始化-struct" class="headerlink" title="初始化 struct"></a>初始化 struct</h3><p>结构体是常用的自定义构造类型，是一种很常见的数据打包方法。结构体对象的初始化有多种方式，分为顺序初始化、指定初始化、构造函数初始化。假如有如下结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">	int b;</span><br><span class="line">	int c;</span><br><span class="line">&#125;;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>（1）顺序初始化因为书写起来较为简约，是我们最常用的初始化方式，但相对于指定初始化，无法变更数据成员初始化顺序，灵活性较差，而且表现形式不直观，不能一眼看出 struct 各个数据成员的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234</span></span><br><span class="line">A a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 点号+赋值符号</span></span><br><span class="line">A a = &#123;.b = <span class="number">1</span>, .c = <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//冒号</span></span><br><span class="line">A a = &#123;b:<span class="number">1</span>, c:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="要注意后面是不是-0-if-检验"><a href="#要注意后面是不是-0-if-检验" class="headerlink" title="% /  要注意后面是不是 0 if 检验"></a>% /  要注意后面是不是 0 if 检验</h3><h3 id="null-与-nullptr-的区别"><a href="#null-与-nullptr-的区别" class="headerlink" title="null 与 nullptr 的区别"></a>null 与 nullptr 的区别</h3><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>delete 运算符只能作用于 new 返回的指针或者nullptr, delete 指针后不会自动设置为 nullptr, 指针的值不变</p>
<h3 id="处有未经处理的异常-0xC0000005-读取位置-0xcccccccc-时发生访问冲突"><a href="#处有未经处理的异常-0xC0000005-读取位置-0xcccccccc-时发生访问冲突" class="headerlink" title="处有未经处理的异常: 0xC0000005: 读取位置 0xcccccccc 时发生访问冲突"></a>处有未经处理的异常: 0xC0000005: 读取位置 0xcccccccc 时发生访问冲突</h3><p>具体原因是在 destroy 的时候删除了 p 本身(题目未要求删除)</p>
<p>解决方法：在debug下，未初始化的指针的地址为0xcccccccc ， 检查下有没有什么地方使用了未初始化的指针，定位后应该是data指针没有初始化，应对其初始化：</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><h3 id="amp-amp-运算符"><a href="#amp-amp-运算符" class="headerlink" title="&amp;&amp;运算符"></a>&amp;&amp;运算符</h3><h3 id="Invalid-address-specified-to-RtlValidateHea"><a href="#Invalid-address-specified-to-RtlValidateHea" class="headerlink" title="Invalid address specified to RtlValidateHea"></a>Invalid address specified to RtlValidateHea</h3><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94588204">std::move()</a></h3><p>前段时间和朋友聊天的过程中说到了右值和std::move以及项目代码里面不合时宜的使用std::move。以及前段时间，华为开源了方舟编译器，大神们讨论方舟编译器，有人贴出里面乱用std::move，看了一下它的源码，是有随意使用std::move的现象。因此，对右值引用和std::move做了一下回顾。</p>
<p>说到<strong>右值</strong>，先看一下什么是右值，在c++中，一个值要么是右值，要么是左值，<em>左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。所有的具名变量或者对象都是左值，而右值不具名。</em></p>
<p>比如：</p>
<p>常见的右值：“abc”,123等都是右值。</p>
<p><strong>右值引用，</strong>用以引用一个右值，可以延长右值的生命期，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; i = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; j = std::<span class="built_in">move</span>(i);</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; k = i;<span class="comment">//编译不过，这里i是一个左值，右值引用只能引用右值</span></span><br></pre></td></tr></table></figure>

<p>可以通过下面的代码，更深入的体会左值引用和右值引用的区别：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int&amp;&amp; j = i++;</span><br><span class="line">int&amp;&amp; k = ++i;</span><br><span class="line">int&amp; m = i++;</span><br><span class="line">int&amp; l = ++i;</span><br><span class="line"></span><br><span class="line">move.cpp: In function ‘int main()’:</span><br><span class="line">move.cpp:72:14: error: cannot bind ‘int’ lvalue to ‘int&amp;&amp;’</span><br><span class="line">  int&amp;&amp; k = ++i;</span><br><span class="line">              ^</span><br><span class="line">move.cpp:73:15: error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’</span><br><span class="line">     int&amp; m = i++;</span><br></pre></td></tr></table></figure>

<p><strong>为什么需要右值引用</strong></p>
<p>C++引入右值引用之后，可以通过右值引用，充分使用临时变量，或者即将不使用的变量即右值的资源，减少不必要的拷贝，提高效率。如下代码，均会产生临时变量：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class RValue &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RValue get() &#123;</span><br><span class="line">    return RValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void put(RValue)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>为了充分利用右值的资源，减少不必要的拷贝，C++11引入了右值引用(&amp;&amp;)，移动构造函数，移动复制运算符以及std::move。</p>
<p><strong>右值引用(&amp;&amp;)，移动构造函数，移动复制运算符以及std::move</strong></p>
<p>将上面的类定义补充完整：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ut&lt;&lt;#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct RValue &#123;</span><br><span class="line">	RValue():sources(&quot;hello!!!&quot;)&#123;&#125;</span><br><span class="line">	RValue(RValue&amp;&amp; a) &#123;</span><br><span class="line">		sources = std::move(a.sources);</span><br><span class="line">		cout&lt;&lt;&quot;&amp;&amp; RValue&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RValue(const RValue&amp; a) &#123;</span><br><span class="line">		sources = a.sources;</span><br><span class="line">		cout&lt;&lt;&quot;&amp; RValue&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void operator=(const RValue&amp;&amp; a) &#123;</span><br><span class="line">		sources = std::move(a.sources);</span><br><span class="line">		cout&lt;&lt;&quot;&amp;&amp; ==&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void operator=(const RValue&amp; a) &#123;</span><br><span class="line">		sources = a.sources;</span><br><span class="line">		cout&lt;&lt;&quot;&amp; ==&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string sources;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RValue get() &#123;</span><br><span class="line">        RValue a;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void put(RValue)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	RValue a = get();</span><br><span class="line">        cout&lt;&lt;&quot;---------------&quot;&lt;&lt;endl;</span><br><span class="line">	put(RValue());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，当运行的时候却发现没有任何输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move </span><br></pre></td></tr></table></figure>

<p>这是因为，编译器做了优化，编译的时候加上-fno-elide-constructors，去掉优化</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ move.cpp -std=c++11 -fno-elide-constructors -o move</span><br><span class="line"> ./move </span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">---------------</span><br><span class="line">&amp;&amp; RValue</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，可以看出，在没有加-fno-elide-constructors选项时，编译器做了优化，没有临时变量的生成。在加了-fno-elide-constructors选项时，get产生了两次临时变量，二put生成了一次临时变量。</p>
<p>将get函数稍微修改一下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RValue get() &#123;</span><br><span class="line">	RValue a;</span><br><span class="line">	return std::move(RValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move </span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">//加编译选项</span><br><span class="line">g++ move.cpp -std=c++11 -fno-elide-constructors -o move</span><br><span class="line"> ./move </span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">---------------</span><br><span class="line">&amp;&amp; RValue</span><br></pre></td></tr></table></figure>

<p>只是简单的修改了一下，std::move(a)，在编译器做了优化的情况下，用了std::move，反而多做了一次拷贝。</p>
<p>其实，RValue如果在没有定义移动构造函数，重复上面的操作，生成临时变量的次数还是一样的，只不过，调用的时拷贝构造函数了而已。</p>
<p>通过get函数可以知道，乱用std::move在编译器开启构造函数优化的场景下反而增加了不必要的拷贝。那么，std::move应该在什么场景下使用？</p>
<p><strong>std::move使用场景</strong></p>
<p>1、移动构造函数的原理</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjouc37bo1j30cm095my6.jpg" alt="image-20201014142110913"></p>
<p>通过移动构造，b指向a的资源，a不再拥有资源，这里的资源，可以是动态申请的内存，网络链接，打开的文件，也可以是本例中的string。<strong>这时候访问a的行为时未定义的</strong>，比如，如果资源是动态内存，a被移动之后，再次访问a的资源，根据移动构造函数的定义，可能是空指针，如果是资源上文的string，移动之后，a的资源为空字符串（string被移动之后，为空字符串）。</p>
<p>可以通过下面代码验证，修改main函数：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	RValue a, b;</span><br><span class="line">	RValue a1 = std::move(a);</span><br><span class="line">	cout&lt;&lt;&quot;a.sources:&quot;&lt;&lt;a.sources&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;a1.sources:&quot;&lt;&lt;a1.sources&lt;&lt;endl;</span><br><span class="line">	RValue b1(b);</span><br><span class="line">	cout&lt;&lt;&quot;b.sources:&quot;&lt;&lt;b.sources&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;b1.sources:&quot;&lt;&lt;a1.sources&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move </span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">a.sources:</span><br><span class="line">a1.sources:hello!!!</span><br><span class="line">&amp; RValue</span><br><span class="line">b.sources:hello!!!</span><br><span class="line">b1.sources:hello!!!</span><br></pre></td></tr></table></figure>

<p>通过移动构造函数之后，a的资源为空，b指向了a的资源。通过拷贝构造函数，b<strong>复制</strong>了a的资源。</p>
<p>2、std::move的原理</p>
<p>std::move的定义：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjoueoadnuj30hn027dh4.jpg" alt="image-20201014142341508"></p>
<p>这里，T&amp;&amp;是通用引用，需要注意和右值引用（比如int&amp;&amp;）区分。通过move定义可以看出，move并没有”移动“什么内容，<strong>只是将传入的值转换为右值</strong>，此外没有其他动作。std::move+移动构造函数或者移动赋值运算符，才能充分起到减少不必要拷贝的意义。</p>
<p>3、std::move的使用场景</p>
<p>在之前的项目中看到有的同事到处使用std::move，好像觉得使用了std::move就能移动资源，提升性能一样，在我看来，std::move主要使用在以下场景：</p>
<ul>
<li><strong>使用前提：1 定义的类使用了资源并定义了移动构造函数和移动赋值运算符，2 该变量即将不再使用</strong></li>
<li>使用场景</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RValue a, b;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//对a,b坐一系列操作之后，不再使用a,b，但需要保存到智能指针或者容器之中</span></span><br><span class="line"><span class="function">unique_ptr&lt;RValue&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> RValue(std::move(a)))</span></span>;</span><br><span class="line">vector&lt;RValue*&gt; vr;</span><br><span class="line">vr.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">RValue</span>(std::<span class="built_in">move</span>(b)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//临时容器中保存的大量的元素需要复制到目标容器之中	</span></span><br><span class="line">vector&lt;RValue&gt; vrs_temp;</span><br><span class="line">vrs_temp.<span class="built_in">push_back</span>(<span class="built_in">RValue</span>());</span><br><span class="line">vrs_temp.<span class="built_in">push_back</span>(<span class="built_in">RValue</span>());</span><br><span class="line">vrs_temp.<span class="built_in">push_back</span>(<span class="built_in">RValue</span>());</span><br><span class="line"><span class="function">vector&lt;RValue&gt; <span class="title">vrs</span><span class="params">(std::move(vrs_temp))</span></span>;</span><br><span class="line">	</span><br><span class="line">RValue c;</span><br><span class="line"><span class="built_in">put</span>(std::<span class="built_in">move</span>(c));</span><br></pre></td></tr></table></figure>

<ul>
<li>在没有右值引用之前，为了使用临时变量，通常定义const的左值引用，比如const string&amp;，在有了右值引用之后，为了使用右值语义，不要把参数定义为常量左值引用，否则，传递右值时调用的时拷贝构造函数</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void put(const RValue&amp; c)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;----------&quot;&lt;&lt;endl;</span><br><span class="line">	unique_ptr&lt;RValue&gt; up(new RValue(std::move(c)));</span><br><span class="line">	cout&lt;&lt;&quot;----------&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RValue c;</span><br><span class="line">put(std::move(c));</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move </span><br><span class="line">----------</span><br><span class="line">&amp; RValue</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>不使用左值常量引用：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void put(RValue c)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;----------&quot;&lt;&lt;endl;</span><br><span class="line">	unique_ptr&lt;RValue&gt; up(new RValue(std::move(c)));</span><br><span class="line">	cout&lt;&lt;&quot;----------&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RValue c;</span><br><span class="line">put(std::move(c));</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move </span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">----------</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>这是因为，根据通用引用的定义，std::move(c)过程中，模板参数被推倒为const RValue&amp;，因此，调用拷贝构造函数。</p>
<p><strong>总结</strong></p>
<p>通过简绍右值和右值引用以及std::move和移动构造函数，总结右值引用，移动构造函数和移动赋值运算符和std::move的用法和注意事项。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    Test &amp; <span class="keyword">operator</span>++()<span class="comment">// 前置++</span></span><br><span class="line">    &#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Test &amp; <span class="keyword">operator</span>--()<span class="comment">// 前置--</span></span><br><span class="line">    &#123;</span><br><span class="line">        a--;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置++</span></span><br><span class="line">    <span class="comment">// 通过一个站位参数来和前置++区分开来</span></span><br><span class="line">    <span class="comment">// 实现上，多了一个 tmp 变量，来实现先操作，后自增的效果</span></span><br><span class="line">    Test <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Test <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;   </span><br><span class="line">    Test <span class="keyword">operator</span>--(<span class="keyword">int</span>) <span class="comment">// 后置--</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Test <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置后置</span></span><br><span class="line">A &amp;<span class="keyword">operator</span>++( )&#123; a++; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;<span class="comment">//单目，前置运算 --a</span></span><br><span class="line">A <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123; <span class="keyword">return</span> <span class="built_in">A</span>(a++); &#125;<span class="comment">//双目，后置运算</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="cpp-课件"><a href="#cpp-课件" class="headerlink" title="cpp 课件"></a>cpp 课件</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>x– 是右值</p>
<p>–x 是左值</p>
<p>C++primer中对 <strong>对象</strong>的定义：<strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间<br>一个<strong>对象</strong>a，它有<strong>值</strong>和<strong>地址&amp;a</strong>，运行程序时，计算机会为该对象分配存储空间，来存储该对象的值，我们通过该对象的地址，来访问存储空间中的值</p>
<p><strong>指针</strong>p也是<strong>对象</strong>，它同样有地址&amp;p和存储的值p，只不过，<strong>p存储的数据类型是数据的地址</strong>。如果我们要以p中存储的数据为地址，来访问对象的值，则要在p前加解引用操作符”<em>“,即</em>p。</p>
<p>对象有常量（const）和变量之分，既然指针本身是对象，那么指针所存储的地址也有常量和变量之分，指针常量是指，指针这个对象所存储的地址是不可以改变的，而指向常量的指针的意思是，不能通过该指针来改变这个指针所指向的对象。</p>
<p><font color = "red"><strong>我们可以把引用理解成变量的别名</strong>。</font></p>
<p>定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。计算机必须<strong>在声明r的同时就要对它初始化</strong>，并且，<strong>r一经声明，就不可以再和其它对象绑定在一起了。</strong></p>
<p>实际上，你也可以把引用看做是通过一个<strong>常量指针</strong>来实现的，它只能绑定到初始化它的对象上。</p>
<p>关于指针和引用的对比，可以参看&lt;&lt;more effective C++&gt;&gt;中的第一条条款，引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率</p>
<p>比如下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,*p,&amp;r=a;<span class="comment">//正确</span></span><br><span class="line">r=<span class="number">3</span>;<span class="comment">//正确：等价于a=3</span></span><br><span class="line"><span class="keyword">int</span> &amp;rr;<span class="comment">//出错：引用必须初始化</span></span><br><span class="line">p=&amp;a;<span class="comment">//正确：p中存储a的地址，即p指向a</span></span><br><span class="line">*p=<span class="number">4</span>;<span class="comment">//正确：p中存的是a的地址，对a所对应的存储空间存入值4</span></span><br><span class="line">p=&amp;b<span class="comment">//正确：p可以多次赋值，p存储b的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>引用必须初始化</strong><br>引用变量中存放的是被引用变量的地址, 本质是指针<br>使用引用对象, 操作对象都是被引用的对象</p>
<p>引用一旦被初始化为指向一个对象，就不能再改变为另一个对象的引用；指针是可变的</p>
<p><strong>int &amp;x = ……;</strong> <strong>引用变量</strong></p>
<p><strong>void f(int &amp;x) ;</strong> <strong>引用参数</strong> 引用经常被用作函数参数, 使得函数中的变量名成为调用程序中的变量的别名. </p>
<ul>
<li><p>新建临时变量: </p>
<p>条件: 1. 实参的类型正确, 但不是左值, 2. 实参的类型不正确, 但可以转换为正确的类型</p>
<p>如果接受引用参数的函数的意图是修改作为参数传递的变量, 那么创建临时变量将阻止这种意图, 所以当引用为 const 时创建临时变量不会影响</p>
</li>
</ul>
<p><strong>Int &amp; f(……) ;</strong> <strong>返回结果引用</strong> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> swap（<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t=x;</span><br><span class="line">  x=y;</span><br><span class="line">  y=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">f</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不要像这样返回一个局部变量的引用, 一般返回一个作为参数传递给函数的引用, 但是可以返回 new 出来的变量的引用</span></span><br><span class="line"><span class="comment">//lea eax,[t]  返回地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">f</span><span class="params">(<span class="keyword">int</span> t )</span> </span>&#123;</span><br><span class="line">  t=t+<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="built_in">f</span>(<span class="number">10</span>)+<span class="built_in">f</span>(<span class="number">20</span>) ;</span><br><span class="line"><span class="comment">// 显示 a = 60</span></span><br><span class="line">b = <span class="built_in">f</span>(<span class="number">20</span>)+<span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 显示 b = 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*a=f(10)+f(20)</span></span><br><span class="line"><span class="comment">先执行 f(10), </span></span><br><span class="line"><span class="comment">返回 函数f中变量t 的地址</span></span><br><span class="line"><span class="comment">再执行 f(20)</span></span><br><span class="line"><span class="comment">返回 函数f中变量t 的地址</span></span><br><span class="line"><span class="comment">根据第1个返回地址，取相</span></span><br><span class="line"><span class="comment">应单元的内容，为 30</span></span><br><span class="line"><span class="comment">根据第2个返回地址，取相</span></span><br><span class="line"><span class="comment">应单元的内容，为 30</span></span><br><span class="line"><span class="comment">故 a =60*/</span></span><br></pre></td></tr></table></figure>

<p>左值引用 vs 右值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;y =x; <span class="comment">// x 是一个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;z = x*<span class="number">2</span>; <span class="comment">//错误，无法从 int 转换为 int &amp;</span></span><br><span class="line"><span class="comment">// z 定义为一个引用，z 中应存放一个地址</span></span><br><span class="line"><span class="comment">// 而 x*2 会对应一个值，无法取其地址，送入 z 中。</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; w = x*<span class="number">2</span>; <span class="comment">// 右值引用；x*2是一个右值；</span></span><br><span class="line"><span class="comment">// 将 x*2 存放在一个临时单元中；将该单元的地址送入 w 中</span></span><br></pre></td></tr></table></figure>

<p>const引用可以读取但是不可以被修改引用对象，任何对const引用进行赋值都是不合法的，它适用指向const对象的引用，而非const的引用不适用于指向const对象的引用。</p>
<p>函数返回一个引用可以使得函数成为左值(c 语言中没有引用, 函数返回值只能作为右值)</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单目:: 指定为全局标识符</span></span><br><span class="line"><span class="comment">全局类型名、全局变量名、全局函数名等*/</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">:: x = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line">x =<span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::*q = &amp;Student::number; <span class="comment">// q 数据成员指针</span></span><br><span class="line">cout &lt;&lt; xu.*q&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>取函数地址时，有无 <strong>&amp;</strong> 一样；</p>
<p>用函数指针是，有无 ***** 一样</p>
<p>普通成员指针是一个偏移量，存放的不是成员地址，故不能移动：</p>
<p>普通成员指针不能进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::*p;</span><br><span class="line">p=p+<span class="number">1</span>; <span class="comment">// 非法 , 不能移动指针</span></span><br><span class="line"><span class="keyword">int</span> *q; q = q+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="类中的关键字"><a href="#类中的关键字" class="headerlink" title="类中的关键字"></a>类中的关键字</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TUTOR</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> sex; <span class="comment">//性别为只读成员</span></span><br><span class="line"><span class="keyword">int</span> wage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TUTOR</span>(<span class="keyword">const</span> <span class="keyword">char</span> *n, <span class="keyword">char</span> g, <span class="keyword">int</span> s): <span class="built_in">sex</span>(g), <span class="built_in">wage</span>(s)</span><br><span class="line">&#123; <span class="built_in">strcpy_s</span>(name,n); &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getname</span><span class="params">( )</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="comment">//函数体不能修改当前对象 函数的返回类型有 const 修饰</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">setname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">strcpy_s</span>(name, n); <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TUTOR <span class="title">xu</span><span class="params">(“xuxy”,’M’,<span class="number">2000</span>)</span></span>;</span><br><span class="line">*xu.<span class="built_in">getname</span>()=‘X’; <span class="comment">// 不能给常量赋值</span></span><br><span class="line">*xu.<span class="built_in">setname</span>(“xuxiangyang”) =‘X’; <span class="comment">// name 的首字母变成X</span></span><br><span class="line"><span class="built_in">strcpy_s</span>(xu.<span class="built_in">setname</span>(“xu123”), <span class="number">6</span>, “hello”); <span class="comment">//name 改为hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1 </span><br><span class="line">p1=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pc;</span><br><span class="line">pc = p1;</span><br><span class="line"><span class="comment">//legal, p1 指向的字符串可以通过 p1 修改, 但不能通过 pc 修改</span></span><br></pre></td></tr></table></figure>

<p>当const在函数名前面的时候修饰的是函数返回值。</p>
<p>当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。</p>
<p>volatile 关键字: 优化器不对该变量的读取进行优化，用到该变量时重</p>
<p>新读取。</p>
<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable:"></a>mutable:</h3><p>可变的</p>
<p>➢ 是const 的反义词</p>
<p>➢ 为突破 const的限制而设置的</p>
<p>➢ 被mutable 修饰的变量永远处于可变得状态，即使在const函数中</p>
<p>➢ mutable只能用来修饰数据成员</p>
<p>➢ 不能与 const、volatile 或 static 同时出现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="keyword">const</span> <span class="keyword">int</span> b; <span class="comment">//b为const成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">( )</span></span>&#123;a++; <span class="keyword">return</span> a; &#125; <span class="comment">//this类型为： A * const this</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">( )</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> a; &#125; <span class="comment">//this类型为：const A * const this。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">( )</span><span class="keyword">volatile</span></span>&#123;<span class="keyword">return</span> a++; &#125; <span class="comment">//this类型为：volatile A * const this</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">( )</span><span class="keyword">const</span> <span class="keyword">volatile</span></span>&#123; <span class="keyword">return</span> a; &#125;<span class="comment">//this类型为：const volatile A* const this</span></span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">int</span> x) ：<span class="built_in">b</span>(x) &#123; a=x; &#125; <span class="comment">//不可在函数体内对b赋值修改</span></span><br><span class="line">&#125; <span class="built_in">x</span>(<span class="number">3</span>); <span class="comment">//等价于A x(3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">y</span><span class="params">(<span class="number">6</span>)</span></span>; <span class="comment">// y 不可修改</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">volatile</span> A <span class="title">z</span><span class="params">(<span class="number">8</span>)</span></span>; <span class="comment">// z 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">x.<span class="built_in">f</span>( ); <span class="comment">//普通对象x调用int f( ): this指向的对象可修改</span></span><br><span class="line">y.<span class="built_in">f</span>( ); <span class="comment">//只读对象y调用int f( )const:this指向的对象不可修改</span></span><br><span class="line">z.<span class="built_in">f</span>( ); <span class="comment">//只读挥发对象z调用int f( )const volatile:this指向的对象不可修改、挥发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const 成员函数和 non-const 成员函数是两个函数, 会区分调用(取决于 this 是 const 还是 non-const)</p>
<!--more-->

<h1 id="PA报告"><a href="#PA报告" class="headerlink" title="PA报告"></a>PA报告</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="课程目的"><a href="#课程目的" class="headerlink" title="课程目的"></a>课程目的</h3><p>理解”程序如何在计算机上运行”的根本途径是从”零”开始实现一个完整的计算机系统. 指导学生实现一个经过简化但功能完备的x86/mips32/riscv32模拟器NEMU(NJU EMUlator), 最终在NEMU上运行游戏”仙剑奇侠传”, 让学生探究”程序在计算机上运行”的基本原理. </p>
<h3 id="课程任务"><a href="#课程任务" class="headerlink" title="课程任务"></a>课程任务</h3><p>PA包括一个准备实验(配置实验环境)以及5部分连贯的实验内容:</p>
<ul>
<li>图灵机与简易调试器</li>
<li>冯诺依曼计算机系统</li>
<li>批处理系统</li>
<li>分时多任务</li>
<li>程序性能优化</li>
</ul>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>CPU架构: x64</li>
<li>操作系统: GNU/Linux</li>
<li>编译器: GCC</li>
<li>编程语言: C语言</li>
</ul>
<h2 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h2><h3 id="PA1-1-基础设施"><a href="#PA1-1-基础设施" class="headerlink" title="PA1.1 基础设施"></a>PA1.1 基础设施</h3><h4 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h4><p>熟悉 nemu 框架, 实现单步执行, 打印寄存器, 扫描内存三种基本指令</p>
<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件: </p>
<p>nemu/src/monitor/debug/ui.c</p>
<p>nemu/src/isa/riscv32/reg.c </p>
</li>
<li><p>具体实现</p>
<p>新增三个指令 cmd_si, cmd_info, cmd_x, 分别对应单步执行, 打印寄存器, 扫描内存. </p>
<p>单步执行主要是通过 cpu_exec API 实现, 通过控制单步执行的指令数量实现调试步幅.</p>
<p>打印寄存器主要是通过 isa_reg_display API 实现, 当收到 “r” 参数时打印所有寄存器状态.</p>
<p>扫描内存主要是通过访问虚拟内存实现, 首先分离出内存位置和需要打印的空间大小, 然后通过 vaddr_read 接口读取内存内容并打印.</p>
</li>
</ol>
<h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><ol>
<li><p>help 指令测试, 如图 1-1 所示新增了si, info, x 三种指令.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6c6ttu64j30ko0gan1c.jpg" alt="截屏2022-01-08 下午2.33.41"></p>
<center style="font-size:14px;text-decoration:underline">图 1-1 help 指令测试</center> </li>
<li><p>si 指令测试, 无参数 si 指令测试如图 1-2 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6cdi7gfwj30l8068my1.jpg" alt="截屏2022-01-08 下午2.34.10"></p>
<center style="font-size:14px;text-decoration:underline">图 1-2 无参数 si 指令测试</center> 

<p>有参数 si 指令测试如图 1-3 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6ces9zocj30hg02et8u.jpg" alt="截屏2022-01-08 下午2.34.34"></p>
</li>
<li><p>info r 指令测试如图 1-4 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6cfdxdfkj30kg0h8ac1.jpg" alt="截屏2022-01-08 下午2.38.34"></p>
<p>​    </p>
</li>
</ol>
<h3 id="PA-1-2-表达式求值"><a href="#PA-1-2-表达式求值" class="headerlink" title="PA 1.2 表达式求值"></a>PA 1.2 表达式求值</h3><h4 id="实验要求-2"><a href="#实验要求-2" class="headerlink" title="实验要求"></a>实验要求</h4><p>实现 p 表达式求值指令.</p>
<h4 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件: </p>
<p>nemu/src/monitor/debug/ui.c, nemu/src/monitor/debug/expr.c</p>
</li>
<li><p>具体实现: </p>
<p>首先要对 token 进行正确的识别, 具体为实现 rule 数组并使用正则表达式提取 token.</p>
<p>之后将表达式求值拆分为符号优先级判断, 括号判断, 求值等几个部分分别实现. 最后的表达式计算接口由 p 指令调用.</p>
</li>
</ol>
<h4 id="实验测试-1"><a href="#实验测试-1" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 1-5 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6cvosla9j30ki0aqtar.jpg" alt="截屏2022-01-08 下午3.18.52 1"></p>
<h3 id="PA-1-3-监视点"><a href="#PA-1-3-监视点" class="headerlink" title="PA 1.3 监视点"></a>PA 1.3 监视点</h3><h4 id="实验要求-3"><a href="#实验要求-3" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>使用完善监视点池.</li>
<li>实现 w, d, info w 指令</li>
</ul>
<h4 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件:  </p>
<p>nemu/src/monitor/debug/ui.c,  nemu/src/monitor/debug/watchpoint.c,  nemu/include/monitor/watchpoint.h</p>
</li>
<li><p>具体设计:</p>
<p>首先完善监视点结构, 增加符号的名称和值两个字段. </p>
<p>之后实现监视点池的 new_wp, free_wp, print_wp 接口, 分别代表新建监视点, 释放监视点, 打印监视点. </p>
<p>然后实现 w, d 指令, 分别代表创建监视点和删除监视点, 分别调用 new_wp 和 free_wp 接口, 最后实现 info w 指令, 调用 print_wp 接口打印监视点内容.</p>
</li>
</ol>
<h4 id="实验测试-2"><a href="#实验测试-2" class="headerlink" title="实验测试"></a>实验测试</h4><p>监视点测试如图 1-6 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6d3r3k9tj30kk096dh8.jpg" alt="截屏2022-01-08 下午3.45.30"></p>
<h3 id="PA-1-问答"><a href="#PA-1-问答" class="headerlink" title="PA 1 问答"></a>PA 1 问答</h3><p>你需要在实验报告中回答下列问题:</p>
<ul>
<li><p>送分题 我选择的ISA是 <em><strong>riscv32</strong></em> .</p>
</li>
<li><p>理解基础设施 我们通过一些简单的计算来体会简易调试器的作用. 首先作以下假设:</p>
<ul>
<li>假设你需要编译500次NEMU才能完成PA.</li>
<li>假设这500次编译当中, 有90%的次数是用于调试.</li>
<li>假设你没有实现简易调试器, 只能通过GDB对运行在NEMU上的客户程序进行调试. 在每一次调试中, 由于GDB不能直接观测客户程序, 你需要花费30秒的时间来从GDB中获取并分析一个信息.</li>
<li>假设你需要获取并分析20个信息才能排除一个bug.</li>
</ul>
<p>那么这个学期下来, 你将会在调试上花费多少时间?</p>
<p><em><strong>500 * 0.9 * 30 * 20 = 270000s</strong></em></p>
<p>由于简易调试器可以直接观测客户程序, 假设通过简易调试器只需要花费10秒的时间从中获取并分析相同的信息. 那么这个学期下来, 简易调试器可以帮助你节省多少调试的时间?</p>
<p><em><strong>500 * 0.9 * 20 * (30-10) = 180000s</strong></em></p>
<p>事实上, 这些数字也许还是有点乐观, 例如就算使用GDB来直接调试客户程序, 这些数字假设你能通过10分钟的时间排除一个bug. 如果实际上你需要在调试过程中获取并分析更多的信息, 简易调试器这一基础设施能带来的好处就更大.</p>
</li>
<li><p>查阅手册</p>
<p>理解了科学查阅手册的方法之后, 请你尝试在你选择的ISA手册中查阅以下问题所在的位置, 把需要阅读的范围写到你的实验报告里面:</p>
<ul>
<li><p>riscv32</p>
<ul>
<li><p>riscv32有哪几种指令格式?</p>
<p><em><strong>R, I, S, B, U, J</strong></em></p>
</li>
<li><p>LUI指令的行为是什么?</p>
<p><em><strong>将 20 位常量加载到寄存器的高 20 位.</strong></em></p>
</li>
<li><p>mstatus寄存器的结构是怎么样的?</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6ddrpfhoj30wc0bw0vb.jpg" alt="截屏2022-01-08 下午5.00.13"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>shell命令 完成PA1的内容之后, <code>nemu/</code>目录下的所有.c和.h和文件总共有多少行代码? 你是使用什么命令得到这个结果的? 和框架代码相比, 你在PA1中编写了多少行代码? (Hint: 目前<code>pa1</code>分支中记录的正好是做PA1之前的状态, 思考一下应该如何回到”过去”?) 你可以把这条命令写入<code>Makefile</code>中, 随着实验进度的推进, 你可以很方便地统计工程的代码行数, 例如敲入<code>make count</code>就会自动运行统计代码行数的命令. 再来个难一点的, 除去空行之外, <code>nemu/</code>目录下的所有<code>.c</code>和<code>.h</code>文件总共有多少行代码?</p>
<p><em><strong>使用 <code>find . -name &quot;*[.h|.c]&quot; |xargs cat|wc -l </code>命令, 5392 行</strong></em></p>
<p><em><strong>使用<code>find . -name &quot;*[.h|.c]&quot; | xargs cat|grep -v ^$ |wc -l  </code>命令, 4410 行</strong></em></p>
</li>
<li><p>使用man 打开工程目录下的<code>Makefile</code>文件, 你会在<code>CFLAGS</code>变量中看到gcc的一些编译选项. 请解释gcc中的<code>-Wall</code>和<code>-Werror</code>有什么作用? 为什么要使用<code>-Wall</code>和<code>-Werror</code>?</p>
<p><em><strong>-Wall 的作用是打开 gcc 所有警告。</strong></em></p>
<p><em><strong>-Werror 的作用是要求 gcc 将所有警告当成错误处理。</strong></em></p>
</li>
</ul>
<h2 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h2><h3 id="PA-2-1-运行第一个-C-程序"><a href="#PA-2-1-运行第一个-C-程序" class="headerlink" title="PA 2.1 运行第一个 C 程序"></a>PA 2.1 运行第一个 C 程序</h3><h4 id="实验要求-4"><a href="#实验要求-4" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>准备交叉编译环境</li>
<li>完成部分指令, 运行 dummy 程序</li>
</ul>
<h4 id="实验过程-3"><a href="#实验过程-3" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件: </p>
<p>nemu/src/isa/riscv32/</p>
</li>
<li><p>首先运行 dummy 程序, 根据 build 目录下的 dummy-riscv32-nemu.txt 反汇编文件找到需要实现的指令, 其中有部分伪指令如 ret 是由其他指令实现的, 最终确定需要实现的指令有 auipc, addi, jal, jalr.</p>
<p>在 all-instr.h 文件中定义执行函数, 在 opcode_table 添加新指令, 在 decode.c 和 control.c 中实现执行辅助函数.</p>
</li>
</ol>
<h4 id="实验测试-3"><a href="#实验测试-3" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 2.1 所示, dummy 正常运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r4m0pkhj30km0d0tbx.jpg" alt="截屏2022-01-09 下午3.33.12"></p>
<h3 id="PA-2-2"><a href="#PA-2-2" class="headerlink" title="PA 2.2"></a>PA 2.2</h3><h4 id="实验要求-5"><a href="#实验要求-5" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>运行 string test</li>
<li>运行 hello-str test</li>
<li>进行 run-all 测试</li>
</ul>
<h4 id="实验过程-4"><a href="#实验过程-4" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件</p>
<p>nemu/src/isa/riscv32/</p>
<p>nexus-am/libs/klib/src/stdio.c</p>
<p>nexus-am/libs/klib/src/string.c</p>
</li>
<li><p>同 PA 2.1, 依照反汇编文件找出所有需要实现的指令, 依次注册实现.<br>stdio.c 中的输出函数和 string.c 中的字符串处理函数需要参考手册中的说明进行实现, 同时要考虑多种异常情况下输出情况是否与手册中描述的一致.</p>
<p>最后进行一键回归测试.</p>
</li>
</ol>
<h4 id="实验测试-4"><a href="#实验测试-4" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 2.2 所示, string test 成功运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r5u1hckj30ku0aemzt.jpg" alt="截屏2022-01-09 下午8.58.23"></p>
<p>如图 2.3 所示, hello-str test 成功运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r5xsb06j30kq0bmjuf.jpg" alt="截屏2022-01-09 下午8.58.50"></p>
<p>如图 2.4 所示, 回归测试全部通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r6jon69j30l60jitb2.jpg" alt="截屏2022-01-09 下午9.16.44"></p>
<h3 id="PA-2-3"><a href="#PA-2-3" class="headerlink" title="PA 2.3"></a>PA 2.3</h3><h4 id="实验要求-6"><a href="#实验要求-6" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现串口, 时钟, 键盘, VGA四种 I/O 设备程序.</li>
<li>分别测试时钟, 键盘, VGA 功能.</li>
<li>运行 slide 程序和 typing 打字游戏.</li>
<li>microbench 跑分.</li>
</ul>
<h4 id="实验过程-5"><a href="#实验过程-5" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件:</p>
<p>nexus-am/am/src/nemu-common/</p>
</li>
<li><p>分别在 nemu-timer.c, nemu-input.c, nemu-video.c 中实现时钟, 键盘, VGA 的功能. </p>
<p>在运行 typing 时出现了 assert 错误, 显示 draw.c 51 行<code>assert(x + j &lt; W &amp;&amp; y + i &lt; H);</code>断言错误, 但是之前的 VGA 测试结果正确, 所以初步判断是 PA2.1 或者 PA2.2 中实现的指令有问题, 调试过程发现 x 的值会等于 W, 于是寻找 x 的来源, 确定是<code>draw_string(hit, W - strlen(hit) * 8, 0, 0x00ff00);</code> 的<code>W - strlen(hit)</code>, 发现 <code>strlen(hit)</code>的大小为 0, 然而 <code>hit</code> 的值为 0 是没有问题的, 于是想到问题可能出在自己实现的<code>strlen</code>, 最后发现是返回了 0 而不是字符串的大小. 修改后解决.</p>
</li>
</ol>
<h4 id="实验测试-5"><a href="#实验测试-5" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 2.5 所示, 时间测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8rud7gtrj30km0da0vo.jpg" alt="截屏2022-01-10 下午4.49.26"></p>
<p>如图 2.6 所示, 键盘测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8rudmwwwj30ka0dc0uu.jpg" alt="截屏2022-01-10 下午4.49.45"></p>
<p>如图 2.7 所示, VGA测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8rue6kr4j30m40hstb3.jpg" alt="截屏2022-01-10 下午4.11.33"></p>
<p>如图 2.8 所示, slide 程序测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8ruccbp9j30mm0hk0un.jpg" alt="截屏2022-01-10 下午5.23.29"></p>
<p>如图 2.9 所示, typing 游戏测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8ruersqyj30my0iajry.jpg" alt="截屏2022-01-10 下午6.15.31"></p>
<p>如图 2.10 所示, microbench 分数为 683.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8s2y2hbwj30h40c2jtu.jpg" alt="截屏2022-01-10 下午6.59.59"></p>
<h3 id="PA-2-问答"><a href="#PA-2-问答" class="headerlink" title="PA 2 问答"></a>PA 2 问答</h3><ul>
<li><p>RTFSC 请整理一条指令在NEMU中的执行过程. (我们其实已经在PA2.1阶段提到过这道题了)</p>
<p><em><strong>首先通过 instr_fetch 取指令, 根据 opcode_table 查找指令对应的译码辅助函数和执行辅助函数, 将译码信息保存在 decinfo, 执行指令, 最后通过 update_pc 更新 PC 值.</strong></em></p>
</li>
<li><p>编译与链接 在<code>nemu/include/rtl/rtl.h</code>中, 你会看到由<code>static inline</code>开头定义的各种RTL指令函数. 选择其中一个函数, 分别尝试去掉<code>static</code>, 去掉<code>inline</code>或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生/不发生? 你有办法证明你的想法吗?</p>
<p><em><strong>static 和 inline 同时去掉时会报错, 重复定义, static 存在时函数作用域仅限本文件, inline 存在时函数在预编译就会展开, 都不会重复定义.</strong></em></p>
</li>
<li><p>编译与链接</p>
<ol>
<li><p>在<code>nemu/include/common.h</code>中添加一行<code>volatile static int dummy;</code> 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个<code>dummy</code>变量的实体? 你是如何得到这个结果的?</p>
<p><em><strong>使用 grep 命令, 81 个</strong></em></p>
</li>
<li><p>添加上题中的代码后, 再在<code>nemu/include/debug.h</code>中添加一行<code>volatile static int dummy;</code> 然后重新编译NEMU. 请问此时的NEMU含有多少个<code>dummy</code>变量的实体? 与上题中<code>dummy</code>变量实体数目进行比较, 并解释本题的结果.</p>
<p><em><strong>使用 grep 命令, 82 个</strong></em></p>
</li>
<li><p>修改添加的代码, 为两处<code>dummy</code>变量进行初始化:<code>volatile static int dummy = 0;</code> 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)</p>
<p><em><strong>编译报错, 两个强符号冲突</strong></em></p>
</li>
</ol>
</li>
<li><p>了解Makefile</p>
<p>请描述你在<code>nemu/</code>目录下敲入<code>make</code>后, <code>make</code>程序如何组织.c和.h文件, 最终生成可执行文件<code>nemu/build/$ISA-nemu</code>. (这个问题包括两个方面: <code>Makefile</code>的工作方式和编译链接的过程.) 关于<code>Makefile</code>工作方式的提示:</p>
<ul>
<li><code>Makefile</code>中使用了变量, 包含文件等特性</li>
<li><code>Makefile</code>运用并重写了一些implicit rules</li>
<li>在<code>man make</code>中搜索<code>-n</code>选项, 也许会对你有帮助</li>
<li>RTFM</li>
</ul>
<p>敲入 make 后, 会将 makefile 文件中第一个目标文件作为最终的目标文件,  如果文件不存在, 就会重新编译; 如果目标文件依赖的.o 文件也不存在, 就根据这个.o 文件的生成规则生成, 然后生成上一层.o 文件, 中间某一步出错就会直接报错.</p>
</li>
</ul>
<h2 id="PA-3-自陷操作"><a href="#PA-3-自陷操作" class="headerlink" title="PA 3 自陷操作"></a>PA 3 自陷操作</h2><h3 id="PA-3-1"><a href="#PA-3-1" class="headerlink" title="PA 3.1"></a>PA 3.1</h3><h4 id="实验要求-7"><a href="#实验要求-7" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现自陷操作.</li>
<li>重新组织<code>_Context</code>结构体的成员.</li>
<li>在<code>__am_irq_handle()</code>中通过异常号识别出自陷异常, 并打包成编号为<code>_EVENT_YIELD</code>的自陷事件.</li>
<li>在<code>do_event()</code>中识别出自陷事件<code>_EVENT_YIELD</code>, 然后输出一句话即可.</li>
</ul>
<h4 id="实验过程-6"><a href="#实验过程-6" class="headerlink" title="实验过程"></a>实验过程</h4><p>涉及文件:</p>
<p>nemu/src/isa/riscv32/intr.c</p>
<p>nanos-lite/src/irq.c</p>
<p>nexus-am/am/src/riscv32/nemu/cte.c</p>
<p>nexus-am/am/include/arch/riscv32-nemu.h</p>
<p>nemu/src/isa/riscv32/exec/system.c</p>
<p>具体过程:</p>
<p>首先在 nemu/src/isa/riscv32/exec/system.c 文件中实现新增的指令 csrrs, csrrw, ecall, sret. 在 nemu/src/isa/riscv32/intr.c 文件中编写 raise_intr, 将当前的 PC 存入 sepc 寄存器, 在 scause 寄存器中保存异常号, 跳转到异常入口地址. </p>
<p>之后重新组织_Context 结构体, 根据 trap.s 重新给结构体成员排序.</p>
<p>最后在 nexus-am/am/src/riscv32/nemu/cte.c 文件中的 __am_irq_handle 函数中实现事件的分发和打包, 在 nanos-lite/src/irq.c 文件的 do_event 函数中处理事件, 对于自陷事件简单的输出 “self trap!” 提示.</p>
<h4 id="实验测试-6"><a href="#实验测试-6" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 3.1 所示, 输出 self trap! 提示表示自陷成功. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya4tct39fj30kc03g3z1.jpg" alt="截屏2022-01-11 下午11.06.08"></p>
<center style="font-size:14px;text-decoration:underline">图 3-1 自陷 dummy 测试</center> 

<h3 id="PA-3-2-系统调用与程序加载"><a href="#PA-3-2-系统调用与程序加载" class="headerlink" title="PA 3.2 系统调用与程序加载"></a>PA 3.2 系统调用与程序加载</h3><h4 id="实验要求-8"><a href="#实验要求-8" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现 loader 函数加载功能.</li>
<li>在<code>nexus-am/am/include/arch/$ISA-nemu.h</code>中实现正确的<code>GPR</code>宏, 让它们从上下文<code>c</code>中获得正确的系统调用参数寄存器.</li>
<li>运行 hello 测试程序. </li>
<li>实现<code>SYS_brk</code>系统调用.</li>
</ul>
<h4 id="实验过程-7"><a href="#实验过程-7" class="headerlink" title="实验过程"></a>实验过程</h4><p>涉及文件:</p>
<p>nanos-lite/src/loader.c</p>
<p>nexus-am/am/include/arch/riscv32-nemu.h</p>
<p>nexus-am/am/src/riscv32/nemu/trap.S</p>
<p>navy-apps/libs/libos/src/nanos.c</p>
<p>nanos-lite/src/proc.c</p>
<p>nanos-lite/src/irq.c</p>
<p>具体过程:</p>
<p>首先在 loader 函数中实现程序的加载, 一开始使用 ramdisk, 后来有了文件系统更新为使用文件操作, 最后返回程序的入口, 通过 naive_uload 进入程序. 在 irq.c 文件中实现 do_event 函数将事件分发给系统调用, 再在 syscall.c 文件中实现 do_syscall 跳转到各个系统调用.</p>
<p>其次, 根据 trap.S 文件实现正确的 GPR 宏, 并添加系统调用完成_sbrk 实现堆区管理. </p>
<h4 id="实验测试-7"><a href="#实验测试-7" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 3.2 所示, hello 程序正常运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya56uu4e2j30km0aodir.jpg" alt="截屏2022-01-11 下午11.01.53"></p>
<center style="font-size:14px;text-decoration:underline">图 3-2 hello 测试</center> 

<h3 id="PA-3-3-文件系统与仙剑奇侠传"><a href="#PA-3-3-文件系统与仙剑奇侠传" class="headerlink" title="PA 3.3 文件系统与仙剑奇侠传"></a>PA 3.3 文件系统与仙剑奇侠传</h3><h4 id="实验要求-9"><a href="#实验要求-9" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现文件读写操作. </li>
<li>修改 loader 加载用户程序的方式. </li>
<li>实现设备函数. </li>
<li>运行仙剑奇侠传</li>
</ul>
<h4 id="实验过程-8"><a href="#实验过程-8" class="headerlink" title="实验过程"></a>实验过程</h4><p>涉及文件:</p>
<p>/Users/akunda/project/ics2019_1/nanos-lite/src/device.c</p>
<p>/Users/akunda/project/ics2019_1/nanos-lite/src/syscall.c</p>
<p>/Users/akunda/project/ics2019_1/nanos-lite/src/fs.c</p>
<p>具体过程:</p>
<p>首先需要实现基本的文件读写.</p>
<p>其次修改之前的 loader 函数, 更新为使用文件系统加载程序. </p>
<p>之后扩展 IOE, 实现 device.c 里的各个接口.</p>
<p>最后运行仙剑奇侠传.</p>
<h4 id="实验测试-8"><a href="#实验测试-8" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 3.3 所示, text 测试正常. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5aum7i1j30ko058t9f.jpg" alt="截屏2022-01-11 下午11.05.15"></p>
<center style="font-size:14px;text-decoration:underline">图 3-3 text 测试</center> 

<p>如图 3.4 所示, event 测试正常. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5btoj9fj30ke0ag41l.jpg" alt="截屏2022-01-11 下午11.23.54"></p>
<center style="font-size:14px;text-decoration:underline">图 3-4 event 测试</center> 

<p>如图 3.5 所示, bmptest 测试正常. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5chkyn9j30mq0hsq3h.jpg" alt="截屏2022-01-11 下午11.24.32"></p>
<center style="font-size:14px;text-decoration:underline">图 3-5 bmptest 测试</center> 

<p>如图 3.6 所示, 仙剑奇侠传测试正常</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5efs8ojj30m60hkmyr.jpg" alt="截屏2022-01-11 下午11.26.24"></p>
<center style="font-size:14px;text-decoration:underline">图 3-6 仙剑奇侠传测试</center> 

<h3 id="PA-3-问答"><a href="#PA-3-问答" class="headerlink" title="PA 3 问答"></a>PA 3 问答</h3><p>你会在<code>__am_irq_handle()</code>中看到有一个上下文结构指针<code>c</code>, <code>c</code>指向的上下文结构究竟在哪里?这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? <code>$ISA-nemu.h</code>, <code>trap.S</code>, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</p>
<p><em><strong>由 trap.S 运行进行赋值的.</strong></em> </p>
<p><em><strong>riscv-nemu.h 定义了相关的结构, trap.S 对上下文结构体进行赋值, 讲义讲清了流程, 实现的指令使自陷操作顺利执行.</strong></em></p>
<p>从Nanos-lite调用<code>_yield()</code>开始, 到从<code>_yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, Nanos-lite)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码/C代码的行为, 尤其是一些比较关键的指令/变量. </p>
<p><em><strong>nanos-lite 调用中断, am 发起自陷指令, 保存上下文, 转入 cpu 自陷指令的内存部分, 执行完后恢复上下文, 返回运行环境</strong></em></p>
<p>我们知道<code>navy-apps/tests/hello/hello.c</code>只是一个C源文件, 它会被编译链接成一个ELF文件. 那么, hello程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? hello程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?</p>
<p><em><strong>elf 位于 ramdisk 中, 通过 naive_uload 读入内存并放置在指定位置, 字符通过系统调用 SYS_write 输出.</strong></em></p>
<p>运行仙剑奇侠传时会播放启动动画, 动画中仙鹤在群山中飞过. 这一动画是通过<code>navy-apps/apps/pal/src/main.c</code>中的<code>PAL_SplashScreen()</code>函数播放的. 阅读这一函数, 可以得知仙鹤的像素信息存放在数据文件<code>mgo.mkf</code>中. 请回答以下问题: 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从<code>mgo.mkf</code>文件中读出仙鹤的像素信息, 并且更新到屏幕上? 换一种PA的经典问法: 这个过程究竟经历了些什么?</p>
<p><em><strong>操作系统通过可函数读出像素信息, 画面通过 vga 输出, vga 被操作系统看做设备文件, fs_write 函数调用了 draw_rect 函数, draw_rect 函数把像素信息写到 vga 对应的地址空间中, 最后通过 update_screen 函数将画面显示到屏幕上.</strong></em></p>
<p>&lt;&gt;</p>
<h1 id="PA实验"><a href="#PA实验" class="headerlink" title="PA实验"></a>PA实验</h1><p>course.cunok.cn都替换成course1.istratus.cn、scripts都替换成scripts1。反之亦然。</p>
<p>校园网外访问：<br><a target="_blank" rel="noopener" href="https://course1.istratus.cn/projects/pa/wiki">https://course1.istratus.cn/projects/pa/wiki</a></p>
<h2 id="PA0"><a href="#PA0" class="headerlink" title="PA0"></a>PA0</h2><h2 id="PA1-1"><a href="#PA1-1" class="headerlink" title="PA1"></a>PA1</h2><p><strong>realpath ./</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_START&#96;(也就是&#96;0x100000)</span><br></pre></td></tr></table></figure>

<p>因此, 我们把内置客户程序放在<code>nemu/src/isa/$ISA/init.c</code>中, 同时抽象出<code>uint8_t isa_default_img[]</code>和<code>long isa_default_img_size</code>这两个变量作为API来给monitor使用.</p>
<p>例如如果mips32的CPU打算访问内存地址<code>0x80001234</code>, 我们最终会让它访问<code>pmem[0x1234]</code>.</p>
<ul>
<li><code>Log()</code>是<code>printf()</code>的升级版, 专门用来输出调试信息, 同时还会输出使用<code>Log()</code>所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置</li>
<li><code>Assert()</code>是<code>assert()</code>的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息</li>
<li><code>panic()</code>用于输出信息并结束程序, 相当于无条件的assertion fail</li>
</ul>
<p>总是使用<code>vaddr_read()</code>和<code>vaddr_write()</code>访问模拟的内存. vaddr, paddr分别代表虚拟地址和物理地址. </p>
<p>debug</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>格式</th>
<th>使用举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>帮助(1)</td>
<td><code>help</code></td>
<td><code>help</code></td>
<td>打印命令的帮助信息</td>
</tr>
<tr>
<td>继续运行(1)</td>
<td><code>c</code></td>
<td><code>c</code></td>
<td>继续运行被暂停的程序</td>
</tr>
<tr>
<td>退出(1)</td>
<td><code>q</code></td>
<td><code>q</code></td>
<td>退出NEMU</td>
</tr>
<tr>
<td>单步执行</td>
<td><code>si [N]</code></td>
<td><code>si 10</code></td>
<td>让程序单步执行<code>N</code>条指令后暂停执行, 当<code>N</code>没有给出时, 缺省为<code>1</code></td>
</tr>
<tr>
<td>打印程序状态</td>
<td><code>info SUBCMD</code></td>
<td><code>info r</code> <code>info w</code></td>
<td>打印寄存器状态 打印监视点信息</td>
</tr>
<tr>
<td>表达式求值</td>
<td><code>p EXPR</code></td>
<td><code>p $eax + 1</code></td>
<td>求出表达式<code>EXPR</code>的值, <code>EXPR</code>支持的 运算请见<a target="_blank" rel="noopener" href="https://course1.istratus.cn/pa/doc2019/1.6.html">调试中的表达式求值</a>小节</td>
</tr>
<tr>
<td>扫描内存(2)</td>
<td><code>x N EXPR</code></td>
<td><code>x 10 $esp</code></td>
<td>求出表达式<code>EXPR</code>的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的<code>N</code>个4字节</td>
</tr>
<tr>
<td>设置监视点</td>
<td><code>w EXPR</code></td>
<td><code>w *0x2000</code></td>
<td>当表达式<code>EXPR</code>的值发生变化时, 暂停程序执行</td>
</tr>
<tr>
<td>删除监视点</td>
<td><code>d N</code></td>
<td><code>d 2</code></td>
<td>删除序号为<code>N</code>的监视点</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nemu&#x2F;src&#x2F;isa&#x2F;$ISA&#x2F;reg.c</span><br><span class="line">void isa_reg_display(void);</span><br></pre></td></tr></table></figure>

<p>你需要将<code>nemu_state.state</code>变量设置为<code>NEMU_STOP</code>来达到暂停的效果. 最后输出一句话提示用户触发了监视点, 并返回到<code>ui_mainloop()</code>循环中等待用户的命令.</p>
<h2 id="PA2-1"><a href="#PA2-1" class="headerlink" title="PA2"></a>PA2</h2><p>PA2中（<a target="_blank" rel="noopener" href="https://course.cunok.cn/pa/doc2019/2.2.html%EF%BC%89%E6%8F%90%E5%88%B0%E7%9A%84riscv32">https://course.cunok.cn/pa/doc2019/2.2.html）提到的riscv32</a> centos64版本的交叉编译器链接的github地址已经失效，请下载课程网站wiki页面中“相关资源”9. RISC-V Cross-compiler所提供的编译器。版本与文档中稍有差别，PATH路径对应修改一下。</p>
<ol>
<li>在<code>opcode_table</code>中填写正确的译码辅助函数, 执行辅助函数以及操作数宽度</li>
<li>用RTL实现正确的执行辅助函数, 需要注意使用RTL伪指令时要遵守上文提到的小型调用约定</li>
</ol>
<p>exec_once() nemu/src/cpu/cpu.c</p>
<p>isa_exec() nemu/src/isa/$ISA/exec/exec.c</p>
<p>idex() nemu/include/cpu/exec.h</p>
<p>make_DHelper nemu/include/cpu/decode.h nemu/src/isa/x86/decode/decode.c</p>
<p>make_DopHelper </p>
<p>make_EHelper nemu/include/cpu/exec.h</p>
<p>在<code>nexus-am/tests/cputest/</code>目录下键入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=<span class="variable">$ISA</span>-nemu ALL=dummy run</span><br></pre></td></tr></table></figure>



<p>具体地, 在<code>exec_once()</code>中, 框架代码首先将当前的PC保存到全局译码信息<code>decinfo</code>的成员<code>seq_pc</code>中. 其中:</p>
<ul>
<li><code>decinfo</code>结构在<code>nemu/src/cpu/cpu.c</code>中定义, 它用于记录一些全局译码信息供后续使用, 包括操作数的类型, 宽度, 值等信息. 还有一些信息是ISA相关的, NEMU用一个结构类型<code>struct ISADecodeInfo</code>来对这些信息进行抽象, 具体的定义在<code>nemu/src/isa/$ISA/include/isa/decode.h</code>中.</li>
<li><code>seq</code>代表顺序(sequential)的意思</li>
</ul>
<p>然后<code>decinfo.seq_pc</code>的地址将被作为参数送进<code>isa_exec()</code>函数(在<code>nemu/src/isa/$ISA/exec/exec.c</code>中定义)中. <code>isa_exec()</code>显然是一个用于屏蔽ISA差异的API: 不同ISA的指令行为天然不同.</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>nemu/include/macro.h</code></td>
<td></td>
</tr>
<tr>
<td><code>str(x)</code></td>
<td>字符串<code>&quot;x&quot;</code></td>
</tr>
<tr>
<td><code>concat(x, y)</code></td>
<td>token<code>xy</code></td>
</tr>
<tr>
<td><code>nemu/include/cpu/decode.h</code></td>
<td></td>
</tr>
<tr>
<td><code>id_src</code></td>
<td>全局变量<code>decinfo</code>中源操作数成员的地址</td>
</tr>
<tr>
<td><code>id_src2</code></td>
<td>全局变量<code>decinfo</code>中2号源操作数成员的地址</td>
</tr>
<tr>
<td><code>id_dest</code></td>
<td>全局变量<code>decinfo</code>中目的操作数成员的地址</td>
</tr>
<tr>
<td><code>make_DHelper(name)</code></td>
<td>名为<code>decode_name</code>的译码辅助函数的原型说明</td>
</tr>
<tr>
<td><code>nemu/src/isa/$ISA/decode.c</code></td>
<td></td>
</tr>
<tr>
<td><code>make_DopHelper(name)</code></td>
<td>名为<code>decode_op_name</code>的操作数译码辅助函数的原型说明</td>
</tr>
<tr>
<td><code>nemu/include/cpu/exec.h</code></td>
<td></td>
</tr>
<tr>
<td><code>make_EHelper(name)</code></td>
<td>名为<code>exec_name</code>的执行辅助函数的原型说明</td>
</tr>
<tr>
<td><code>print_asm(...)</code></td>
<td>将反汇编结果的字符串打印到缓冲区<code>log_asmbuf</code>中</td>
</tr>
<tr>
<td><code>suffix_char(width)</code></td>
<td>操作数宽度<code>width</code>对应的后缀字符(仅x86使用)</td>
</tr>
<tr>
<td>`print_asm_template[1</td>
<td>2</td>
</tr>
</tbody></table>
<ul>
<li><p>不同ISA的通用寄存器(在<code>nemu/src/isa/$ISA/include/isa/reg.h</code>中定义)</p>
</li>
<li><p><code>id_src</code>, <code>id_src2</code>和<code>id_dest</code>中的访存地址<code>addr</code>和操作数内容<code>val</code>(在<code>nemu/include/cpu/decode.h</code>中定义). 从概念上看, 它们分别与<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_address_register">MAR</a>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_data_register">MDR</a>有异曲同工之妙</p>
</li>
<li><p>临时寄存器<code>s0, s1, t0, t1</code>和<code>ir</code>(在<code>nemu/src/cpu/cpu.c</code>中定义)</p>
</li>
<li><p>立即数读入<code>rtl_li</code></p>
</li>
<li><p>寄存器传输<code>rtl_mv</code></p>
</li>
<li><p>32位寄存器-寄存器类型的算术/逻辑运算, 包括<code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])</code>, 这些运算的定义用到了<code>nemu/include/rtl/c_op.h</code>中的C语言运算</p>
</li>
<li><p>被除数为64位的除法运算<code>rtl_i?div64_[q|r]</code></p>
</li>
<li><p>guest内存访问<code>rtl_lm</code>和<code>rtl_sm</code></p>
</li>
<li><p>host内存访问<code>rtl_host_lm</code>和<code>rtl_host_sm</code></p>
</li>
<li><p>关系运算<code>rtl_setrelop</code>, 具体可参考<code>nemu/src/cpu/relop.c</code></p>
</li>
<li><p>跳转, 包括直接跳转<code>rtl_j</code>, 间接跳转<code>rtl_jr</code>和条件跳转<code>rtl_jrelop</code></p>
</li>
<li><p>终止程序<code>rtl_exit</code>(在<code>nemu/src/monitor/cpu-exec.c</code>中定义)</p>
</li>
<li><p>实现RTL伪指令的时候, 尽可能不使用<code>dest</code>之外的寄存器存放中间结果. 由于<code>dest</code>最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.</p>
</li>
<li><p>实在需要使用临时寄存器的时候, 按照以下约定来使用:</p>
<ul>
<li><code>ir</code>(immediate register) - 只能作为<code>rtl_li</code>的目的RTL寄存器</li>
<li><code>t0</code>, <code>t1</code> - 只能在RTL伪指令的实现过程中存放中间结果</li>
<li><code>s0</code>, <code>s1</code> - 只能在译码辅助函数和执行辅助函数的实现过程中存放中间结果</li>
</ul>
</li>
</ul>
<p>这个例子也展示了运行时环境的一种普遍的存在方式: 库. 通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些API, 就能使用运行时环境提供的相应功能.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AM &#x3D; TRM + IOE + CTE + VME + MPE</span><br></pre></td></tr></table></figure>

<ul>
<li>TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力</li>
<li>IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力</li>
<li>CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力</li>
<li>VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力</li>
<li>MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)</li>
</ul>
<h2 id="PA3"><a href="#PA3" class="headerlink" title="PA3"></a>PA3</h2><p>riscv32提供<code>ecall</code>指令作为自陷指令, 并提供一个stvec寄存器来存放异常入口地址. 为了保存程序当前的状态, riscv32提供了一些特殊的系统寄存器, 叫控制状态寄存器(CSR寄存器). 在PA中, 我们只使用如下3个CSR寄存器:</p>
<ul>
<li>sepc寄存器 - 存放触发异常的PC</li>
<li>sstatus寄存器 - 存放处理器的状态</li>
<li>scause寄存器 - 存放触发异常的原因</li>
</ul>
<p>riscv32触发异常后硬件的响应过程如下:</p>
<ol>
<li>将当前PC值保存到sepc寄存器</li>
<li>在scause寄存器中设置异常号</li>
<li>从stvec寄存器中取出异常入口地址</li>
<li>跳转到异常入口地址</li>
</ol>
<p>你需要实现<code>SYS_exit</code>系统调用, 它会接收一个退出状态的参数, 用这个参数调用<code>_halt()</code>即可. 实现成功后, 再次运行dummy程序, 你会看到<code>HIT GOOD TRAP</code>的信息.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -15,2 +15,2 @@</span></span><br><span class="line"><span class="deletion">-SINGLE_APP = $(NAVY_HOME)/tests/dummy</span></span><br><span class="line"><span class="addition">+SINGLE_APP = $(NAVY_HOME)/tests/hello</span></span><br><span class="line"> SINGLE_APP_FILE = $(FSIMG_PATH)/bin/$(notdir $(SINGLE_APP))</span><br></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- nanos-lite/Makefile</span></span><br><span class="line"><span class="comment">+++ nanos-lite/Makefile</span></span><br><span class="line"><span class="meta">@@ -36,2 +36,2 @@</span></span><br><span class="line"><span class="deletion">-update: update-ramdisk-single src/syscall.h</span></span><br><span class="line"><span class="addition">+update: update-ramdisk-fsimg src/syscall.h</span></span><br><span class="line">  @touch src/initrd.S</span><br></pre></td></tr></table></figure>

<p>然后运行<code>make clean</code>清除<code>build/ramdisk.img</code>. 之后编译Nanos-lite就会自动编译Navy-apps里面的所有程序, 并把<code>navy-apps/fsimg/</code>目录下的所有内容整合成ramdisk镜像, 同时生成这个ramdisk镜像的文件记录表<code>nanos-lite/src/files.h</code>. 需要注意的是, 并不是Navy-apps里面的所有程序都能在Nanos-lite上运行, 有些程序需要更多系统调用的支持才能运行, 例如NWM和NTerm, 我们并不打算在PA中运行这些程序.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -6,4 +6,5 @@</span></span><br><span class="line"> typedef struct &#123;</span><br><span class="line">   char *name;         // 文件名</span><br><span class="line">   size_t size;        // 文件大小</span><br><span class="line">   size_t disk_offset;  // 文件在ramdisk中的偏移</span><br><span class="line"><span class="addition">+  size_t open_offset;  // 文件被打开之后的读写指针</span></span><br></pre></td></tr></table></figure>



<!--more-->

<h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h2><p>一个编译程序就是一个语言翻译程序,它把一种语言(称作源语言)书写的程序翻译成另一种语言(称作目标语言)的等价的程序.</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>划分出单词符号串</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>表示出语法树</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>上下文相关性, 类型匹配, 类型转换</p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>三元式, 四元式, p-code, c-code</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h3 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h3><p>生成汇编码</p>
<h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="*符号表管理"></a>*符号表管理</h3><p>记录高中符号名称, 属性</p>
<h2 id="解释程序"><a href="#解释程序" class="headerlink" title="解释程序"></a>解释程序</h2><p>​    编译方式是先翻译后执行，即将整个源程序翻译完毕，再执行目标程序，只需要保存完整的目标程序而无需保存源程序。一次翻译后无需再翻译，可多次执行。<br>​    解释方式是边翻译边执行，即翻译一句就执行一句，翻译完毕也执行完毕，只保存源程序无需保存完整的目标程序。执行一次需要翻译一次。 </p>
<p>不产生目标程序文件<br>不区别翻译阶段和执行阶段<br>翻译源程序的每条语句后直接执行<br>程序执行期间一直有解释程序守候<br>常用于实现虚拟机<br>著名的解释程序有Basic语言解释程序 ,Lisp语言解释程序,UNIX命令语言解释程序(shell),数据库查询语言SQL 解释程序以及bytecode解释程序.</p>
<h2 id="PL-O-语言编译系统"><a href="#PL-O-语言编译系统" class="headerlink" title="PL/O 语言编译系统"></a>PL/O 语言编译系统</h2><h1 id="第二章-文法与语言"><a href="#第二章-文法与语言" class="headerlink" title="第二章 文法与语言"></a>第二章 文法与语言</h1><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><p>文法是阐述语法的一个工具，语句是语法的实例 </p>
<p>符号:</p>
<p> <code>::=</code> …是由…组成的</p>
<p><code>|</code>或者</p>
<p><code>=&gt;</code>推导</p>
<p>文法G定义为一个四元组（V<del>N</del>，V<del>T</del>，P，S），记为G＝（V<del>N</del>，V<del>T</del>，P，S）。其中，<br> ① V<del>N</del>是非空有穷集合，称为非终结符集，其元素称为非终结符；<br> ② V<del>T</del>是有穷集合，称为终结符集，其元素称为终结符；<br> ③ P是非空有穷集合，称为规则集，其元素是字母表V<del>N</del>∪V<del>T</del>上的规则，V<del>N</del>∪V<del>T</del>称为文法的字母表V，且V<del>N</del>∩V<del>T</del>＝∅；<br> ④ S∈V<del>N</del>，称为开始符。</p>
<p>直接推导, 直接归约<br>eg. a S bSb =&gt; a aSb bSb (α＝S，β＝aSb，γ＝a，δ＝bSb )</p>
<p>多步推导, 多步归约</p>
<h2 id="符号和符号串"><a href="#符号和符号串" class="headerlink" title="符号和符号串"></a>符号和符号串</h2><p>字母表<code>∑</code>, 其元素称为符号, 空串记为<code>ε</code></p>
<p>符号串<code>α</code>, 符号串α的长度<code>|α|</code>, 符号串集合<code>A</code></p>
<p>符号串连接运算<code>z=x·y</code>  符号串乘方运算 x^0^ = ε, x^1^ = x</p>
<p>符号串集连接, 符号串集方幂</p>
<p>符号串集正闭包运算 设A是字母表∑上的符号串集， A+是A的正闭包，则:  A+＝A^1^∪A^2^∪A^3^∪···∪A^n^···<br>符号串集闭包运算  设A是字母表∑上的符号串集， A*是A的闭包，则 :  A* ＝A^0^∪A+ ，即：A* ＝A^0^∪A^1^∪A^2^∪A^3^∪···∪A^n^···<br>例：设字母表∑＝｛a，b｝，A＝｛aa，bb｝，B＝ ｛ab，ba｝，C＝｛a｝，则<br>                A·B＝｛aaab，aaba，bbab，bbba｝，<br>                A^2^   ＝｛aaaa，aabb，bbaa，bbbb｝，<br>                C+   ＝｛a，aa，aaa，···｝＝｛a^n^︱n≥1｝，<br>                C*  ＝｛ε,a，aa，aaa，···｝＝｛a^n^︱n≥0｝。</p>
<p>规则是字母表V上形如 α∷＝β的式子，可以简写成α→β。其中，符号串α∈V+称为规则的左部，符号串β∈V*称为规则的右部。规则也称为重写规则、产生式或生成式。<br>特别地，α∷＝ε（ε空串）称为α的空规则<br>对于相同左部的多个规则，可以使用符号|简写。如，规则α∷＝β和a∷＝δ，简写成α∷＝β|δ。 简写为α→β|δ</p>
<!--more-->

<blockquote>
<p>简介</p>
<p>第1章：Amdahl定律，CPU时间/CPI/MIPS</p>
<p>第3章：时空图，流水线分类，性能指标，单功能非线性流水线调度, 相关，定向，MIPS流水线</p>
<p>第5章：超标量/超长指令字/超流水，分支预测</p>
<p>第7章：存储系统性能，两级Cache，不命中类型，伪相联，Cache性能改进，全相联/直接相联/组相联，查找方法，写策略，虚拟存储器，TLB</p>
<p>第8章：RAID系统，可靠性模型与量化指标</p>
<p>第9章：性能指标，单级互连网络，多级互连网络</p>
<p>第10章：并行处理面临的挑战</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbhsx1afpj30kq0ciaan.jpg" alt="C158860121CB11859CBAEB3809185D18"></p>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h2><ul>
<li><p>加速比: $S_n = \frac{新速度}{老速度} = \frac{T_o}{T_n}$</p>
<p>$S_n = \frac{1}{(1-F_e) + \frac{F_e}{S_e}}$</p>
<p>推导: $T_n = T_o(1-F_e+\frac{F_e}{S_e})$</p>
<p>S<del>e</del> 改进部分的部件加速比</p>
<p>F<del>e</del> 改进部分原执行时间占原总时间的百分比</p>
<ul>
<li>加快经常性时间</li>
<li>Huffman 编码</li>
</ul>
</li>
</ul>
<h2 id="CPU-性能公式"><a href="#CPU-性能公式" class="headerlink" title="CPU 性能公式"></a>CPU 性能公式</h2><ul>
<li><p>CPU 时间: 一个程序在 CPU 上运行的时间, 不包括 I/O 时间</p>
<ul>
<li>时钟周期时间</li>
<li>程序的时钟周期数<ul>
<li>指令周期数 CPI = 执行程序所需时钟周期数/IC </li>
<li>IC: 执行指令条数</li>
</ul>
</li>
</ul>
<p>CPU 时间 = 执行程序所需的时钟周期数 * 时钟周期时间</p>
<p>CPU 时间 = IC * CPI * 时钟周期时间</p>
<p>CPU 时间 = IC * CPI / 时钟频率</p>
</li>
</ul>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><ul>
<li>时间</li>
<li>空间 </li>
</ul>
<h2 id="系统评价指标"><a href="#系统评价指标" class="headerlink" title="系统评价指标"></a>系统评价指标</h2><ul>
<li><p>响应时间: 完成一个任务的全部时间(用户角度)</p>
</li>
<li><p>吞吐率: 单位时间内完成的任务数(管理员)</p>
</li>
<li><p>$MIPS = \frac{指令条数}{执行时间 \times 10^6} = \frac{f}{CPI \times 10^6}$</p>
<ul>
<li>依赖于指令集</li>
<li>程序不同 MPIS 不同</li>
<li>唯一可靠的是测真实程序的执行时间</li>
</ul>
</li>
<li><p>基准测试程序: Benchmark</p>
<p>实际应用程序, 修正的(脚本化的)应用程序, 核心测试程序, 小测试程序, 合成测试程序</p>
</li>
<li><p>成本</p>
<p>部件成本, 直接成本, 毛利润, 平均折扣</p>
</li>
<li><p>功耗</p>
</li>
<li><p>可靠性和可用性</p>
<ul>
<li>可靠性: MTTF(平均故障时间) </li>
<li>可用性:$ \frac{MTTF}{MTTF+MTTR}$ MTTR(平均修复时间)</li>
</ul>
</li>
</ul>
<h2 id="系统结构的发展"><a href="#系统结构的发展" class="headerlink" title="系统结构的发展"></a>系统结构的发展</h2><ul>
<li>冯诺依曼<ul>
<li>以计算器为中心</li>
<li>存储器中数据和指令同等对待</li>
<li>存储器按地址访问, 按线性编址, 每个单元位数固定</li>
<li>指令的执行时顺序的</li>
</ul>
</li>
<li>冯诺依曼的发展<ul>
<li>输入输出的改进<ul>
<li>程序控制<ul>
<li>程序等待: 轮巡 i/o 设备</li>
<li>程序中断</li>
</ul>
</li>
<li>DMA(Direct Memory Access) 直接存储器访问: 减少 CPU 对 i/o 的干预, 通过硬件为RAM和IO设备开辟一条直接传输数据的通道</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/starter_____/article/details/101615848">i/o 处理机</a><br><img src="https://img-blog.csdnimg.cn/20190928144959429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0ZXJfX19fXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>并行技术<ul>
<li>指令内部并行</li>
<li>指令级并行</li>
<li>线程级并行</li>
<li>任务级, 过程级并行</li>
<li>作业, 程序级并行</li>
</ul>
</li>
<li>存储器组织结构<ul>
<li>相联存储器</li>
<li>通用寄存器</li>
<li>高速缓存 Cache</li>
</ul>
</li>
<li>指令系统<ul>
<li>CISC</li>
<li>RISC</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="器件对系统结构的影响"><a href="#器件对系统结构的影响" class="headerlink" title="器件对系统结构的影响"></a>器件对系统结构的影响</h2><ul>
<li><p>1945-1954 ENIAC</p>
<ul>
<li>电子管和继电器</li>
<li>机器语言, 汇编语言</li>
<li>存储程序, 计算机程序控制 i/o</li>
</ul>
</li>
<li><p>1955-1964 IBM7030</p>
<ul>
<li>晶体管</li>
<li>浮点数表示, 寻址技术, 中断, i/o 处理机</li>
<li>高级语言, 编译, 批处理监控系统</li>
</ul>
</li>
<li><p>1965-1974 IBM370</p>
<ul>
<li><p>SSI(小规模集成电路), MSI(中规模集成电路), 多层印刷电路, 微程序</p>
</li>
<li><p>流水线, cache, 先行处理, 系列机</p>
</li>
<li><p>多道程序, 分时操作系统</p>
</li>
</ul>
</li>
<li><p>1975-1991 Cray-1</p>
<ul>
<li>LSI(大规模集成电路), VLSI(超大规模集成电路), 半导体存储器</li>
<li>向量处理, 分布式存储器</li>
<li>并行, 分布处理</li>
</ul>
</li>
<li><p>1991-</p>
<ul>
<li>高性能微处理器, 高密度电路</li>
<li>超标量, 超流水线, SMP, MP, MPP, 机群</li>
<li>大规模, 可扩展性, 并行, 分布处理</li>
</ul>
</li>
</ul>
<h1 id="第三章-流水线技术"><a href="#第三章-流水线技术" class="headerlink" title="第三章 流水线技术"></a>第三章 流水线技术</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>分类:</p>
<ul>
<li><p>单功能流水线</p>
</li>
<li><p>多功能流水线</p>
<p>多功能流水线又可分为</p>
<ul>
<li>静态流水线</li>
<li>动态流水线</li>
</ul>
</li>
</ul>
<p>还可分为线性流水线, 非线性流水线(有反馈回路)</p>
<p>顺序流水线, 乱序流水线(允许后进来的任务先完成)</p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="吞吐率TP"><a href="#吞吐率TP" class="headerlink" title="吞吐率TP"></a>吞吐率TP</h3><p>$TP = \frac{n}{T_k}$  任务数/处理完 n 个任务的时间(从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，在MSDN中称之为挂钟时间（wal-clock）)</p>
<p>$TP = \frac{n}{(k+n-1)\times △t}$ n 个任务, k 个段, </p>
<p>$TP_{max} = \frac{1}{△t}$</p>
<p>$TP = \frac{n}{k+n-1}TP_{max}$</p>
<p>流水线中执行时间最长的段称为 瓶颈段</p>
<p>$TP = \frac{n}{\sum_{i=1}^{k}△t_i + (n-1)max(△t_1, △t_2, △t_3)} = \frac{n}{一个任务的时间 + (n-1)瓶颈段的时间}$</p>
<p>拆分瓶颈段, 重复设置瓶颈段</p>
<h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><p>加速比: $S = \frac{T_s}{T_k}$</p>
<p>不使用流水线所用的时间与使用流水线所用的时间比</p>
<p>$S = \frac{nk}{k+n-1}$</p>
<p>时间不等时</p>
<p>$S = \frac{n\sum_{i=1}^{k}△t_i}{\sum_{i=1}^{k}△t_i + (n-1)max(△t_1, △t_2, △t_3)}$</p>
<h3 id="效率-E"><a href="#效率-E" class="headerlink" title="效率(E)"></a>效率(E)</h3><p>效率: 设备实际使用时间/整个运行时间 &lt; 1</p>
<p>$e_1 = e_2 = … = e_k  = \frac{n}{k+n-1} $</p>
<p>$E = \frac{e_1+e_2+…+e_k}{k} = \frac{nk}{(k+n-1)k}= TP△t = \frac{S}{k}$</p>
<p>时间间隔不等</p>
<p>$E= \frac{n\sum_{i=1}^{k}△t_i}{k[\sum_{i=1}^{k}△t_i + (n-1)max(△t_1, △t_2, △t_3)]}$</p>
<h2 id="单功能非线性流水线的调度"><a href="#单功能非线性流水线的调度" class="headerlink" title="单功能非线性流水线的调度"></a>单功能非线性流水线的调度</h2><ul>
<li><p>非线性流水线: 任务在流水线中可能会流经某些段多次</p>
</li>
<li><p>启动距离: 向一条非线性流水线输入端 连续输入两个任务 之间的时间间隔</p>
</li>
<li><p>禁用启动距离: 会引起 非线性流水线 功能段使用冲突的 启动距离</p>
</li>
<li><p>预约表</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp1z4hobarj30vi0bgwvb.jpg" alt="截屏2021-03-30 下午3.41.39"></p>
</li>
<li><p>禁止表 F: 由禁用启动距离构成的集合</p>
<ul>
<li><p>根据预约表写出禁止表</p>
<p>对于预约表每一行的任意一对√, 用他们所在的列号相减(大-小)列出各种可能的差值, 差值的集合就是禁止表的元素</p>
<p>对上图: {8, 1, 5, 6}</p>
</li>
</ul>
</li>
<li><p>冲突向量 C: N 位二进制串</p>
<ul>
<li><p>根据禁止表 F 写出初始冲突向量 C<del>0</del></p>
<p>设$C_0 = (c_N c_{N-1} … c_i … c_2 c_1)$</p>
<p>则 $ c_i=<br>\begin{cases}<br>1, i \in F\<br>0, i \notin F<br>\end{cases}$</p>
<p>C<del>0</del>的意义是当第一个任务进入流水线后, C<del>0</del> 决定了下一个任务需要多少时间间隔才可以流入</p>
<p>对于 C<del>k</del> , 假设 j 个时钟周期后送入第二个任务, 则 $C_{k+1} = SHR^{(j)} (C_k) \vee C_0 $</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp1ztoxmbyj30rw0bu1ad.jpg" alt="截屏2021-03-30 下午4.05.56"></p>
</li>
</ul>
</li>
<li><p>流水线状态转移图</p>
<ul>
<li>流水线状态集合(所有冲突向量)</li>
<li>有向弧</li>
<li>弧上的数字</li>
</ul>
</li>
</ul>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ul>
<li><p>数据相关: 对于 i, j 两条指令</p>
<ul>
<li>j 使用 i 的结果</li>
<li>j 与指令 k 数据相关, k 与指令 i 数据相关</li>
</ul>
<p>具有传递性</p>
</li>
<li><p>名相关: 指令访问的寄存器或存储单元名称</p>
<ul>
<li>反相关(先读后写): 指令 j 写的名 = 指令 i 读的名</li>
<li>输出相关: 指令 j 写的名 = 指令 i 写的名</li>
</ul>
</li>
<li><p>控制相关: 分支指令</p>
</li>
</ul>
<h2 id="流水线冲突"><a href="#流水线冲突" class="headerlink" title="流水线冲突"></a>流水线冲突</h2><ul>
<li>流水线冲突: 由于相关等原因存在, 使得指令流中的下一条指令不能再指定的时间周期执行</li>
<li>分类<ul>
<li>结构冲突: 硬件资源无法满足</li>
<li>数据冲突: 指令间结果冲突<ul>
<li>写后读 RAW (常见)</li>
<li>写后写 WAW</li>
<li>读后写 WAR</li>
</ul>
</li>
<li>控制冲突: 分支指令</li>
</ul>
</li>
</ul>
<h1 id="第五章-指令级并行-ILP"><a href="#第五章-指令级并行-ILP" class="headerlink" title="第五章 指令级并行(ILP)"></a>第五章 指令级并行(ILP)</h1><h2 id="指令的动态调度"><a href="#指令的动态调度" class="headerlink" title="指令的动态调度"></a>指令的动态调度</h2><blockquote>
<p>指令的静态调度: 编译时调度</p>
<p>指令动态调度: 通过硬件</p>
</blockquote>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>将 5 段流水线的译码阶段分为</p>
<ul>
<li>流出 Issue IS</li>
<li>读操作数 Read Operands RO</li>
</ul>
<p>引入指令缓冲区, 直到冲突消除</p>
<p>部署更多执行部件, 使多条指令能同时执行或访存</p>
<p>但会新出现 WAR 和 WAW 冲突</p>
<h3 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h3><h2 id="动态分支预测技术"><a href="#动态分支预测技术" class="headerlink" title="动态分支预测技术"></a>动态分支预测技术</h2><p>在程序运行时, 根据分支指令过去的表现来预测其将来的行为</p>
<h3 id="BHT-branch-history-table"><a href="#BHT-branch-history-table" class="headerlink" title="BHT branch history table"></a>BHT branch history table</h3><p>用 BHT 来记录分支指令最近几次的执行情况</p>
<h3 id="BTB-branch-target-buffer"><a href="#BTB-branch-target-buffer" class="headerlink" title="BTB branch target buffer"></a>BTB branch target buffer</h3><p>分支开销降为 0</p>
<h2 id="多指令流出技术"><a href="#多指令流出技术" class="headerlink" title="多指令流出技术"></a>多指令流出技术</h2><p>理想 CPI &lt; 1</p>
<h3 id="超标量"><a href="#超标量" class="headerlink" title="超标量"></a>超标量</h3><p>每周期流出指令数量</p>
<h3 id="超长指令字-VLIW"><a href="#超长指令字-VLIW" class="headerlink" title="超长指令字 VLIW"></a>超长指令字 VLIW</h3><p>流出指令数量固定, 构成一个长指令或指令包</p>
<h3 id="超流水线"><a href="#超流水线" class="headerlink" title="超流水线"></a>超流水线</h3><p>每一个流水线段细分</p>
<h1 id="第七章-存储系统"><a href="#第七章-存储系统" class="headerlink" title="第七章 存储系统"></a>第七章 存储系统</h1><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><h3 id="三种类型的不命中"><a href="#三种类型的不命中" class="headerlink" title="三种类型的不命中"></a>三种类型的不命中</h3><h4 id="强制不命中-第一次启动"><a href="#强制不命中-第一次启动" class="headerlink" title="强制不命中: 第一次启动"></a>强制不命中: 第一次启动</h4><p>增加块大小</p>
<p>预取</p>
<h4 id="容量不命中-容量不足"><a href="#容量不命中-容量不足" class="headerlink" title="容量不命中: 容量不足"></a>容量不命中: 容量不足</h4><p>增加容量</p>
<h4 id="冲突不命中-冲突"><a href="#冲突不命中-冲突" class="headerlink" title="冲突不命中: 冲突"></a>冲突不命中: 冲突</h4><p>增加相联度</p>
<h3 id="降低-cache-不命中率的方法"><a href="#降低-cache-不命中率的方法" class="headerlink" title="降低 cache 不命中率的方法"></a>降低 cache 不命中率的方法</h3><h4 id="增加-cache-块大小"><a href="#增加-cache-块大小" class="headerlink" title="增加 cache 块大小"></a>增加 cache 块大小</h4><p>对于给定 cache 容量, 块大小增加, 不命中率先下降后上升</p>
<p>原因: 降低强制不命中, 但是会增加冲突不命中</p>
<h4 id="增加-cache-容量"><a href="#增加-cache-容量" class="headerlink" title="增加 cache 容量"></a>增加 cache 容量</h4><p>成本</p>
<h4 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h4><p>增加命中时间</p>
<p>2:1 cache 经验规则<br>容量为 N 的直接映射 cache 的不命中率和容量为 N/2 的两路组相联 cache 不命中率差不多</p>
<h4 id="伪相联-cache"><a href="#伪相联-cache" class="headerlink" title="伪相联 cache"></a>伪相联 cache</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpgan2zqazj30sq0a8gz0.jpg" alt="截屏2021-04-12 上午12.58.04"></p>
<h4 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h4><h4 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h4><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><h4 id="“牺牲”-cache"><a href="#“牺牲”-cache" class="headerlink" title="“牺牲” cache"></a>“牺牲” cache</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpgatl3ihnj30ti0amh13.jpg" alt="截屏2021-04-12 上午1.04.22"></p>
<h3 id="减小不命中开销"><a href="#减小不命中开销" class="headerlink" title="减小不命中开销"></a>减小不命中开销</h3><h4 id="采用两级-cache"><a href="#采用两级-cache" class="headerlink" title="采用两级 cache"></a>采用两级 cache</h4><h4 id="读不命中优先于写"><a href="#读不命中优先于写" class="headerlink" title="读不命中优先于写"></a>读不命中优先于写</h4><h4 id="写缓冲合并"><a href="#写缓冲合并" class="headerlink" title="写缓冲合并"></a>写缓冲合并</h4><p>在写缓冲的地方合并</p>
<h4 id="非阻塞-cache-技术"><a href="#非阻塞-cache-技术" class="headerlink" title="非阻塞 cache 技术"></a>非阻塞 cache 技术</h4><h3 id="减小命中时间"><a href="#减小命中时间" class="headerlink" title="减小命中时间"></a>减小命中时间</h3><h4 id="虚拟-cache-并行-mmu"><a href="#虚拟-cache-并行-mmu" class="headerlink" title="虚拟 cache(并行 mmu)"></a>虚拟 cache(并行 mmu)</h4><p>虚拟冲突</p>
<h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><h4 id="踪迹-cache"><a href="#踪迹-cache" class="headerlink" title="踪迹 cache"></a>踪迹 cache</h4><h3 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h3><p>高位交叉</p>
<p>低位交叉</p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h1 id="第六章-i-o-系统"><a href="#第六章-i-o-系统" class="headerlink" title="第六章 i/o 系统"></a>第六章 i/o 系统</h1><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>MTTF 平均无故障时间</p>
<p>MTTR 平均修复时间</p>
<p> $系统可用性 = \frac{MTTF}{MTTF + MTTR}$</p>
<h2 id="串并联系统可靠性模型"><a href="#串并联系统可靠性模型" class="headerlink" title="串并联系统可靠性模型"></a>串并联系统可靠性模型</h2><p>F(t) + R(t) = 1</p>
<h3 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a>串联系统</h3><p>$R_s = {\prod_{i=1}^{n}}R_i $</p>
<h3 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a>并联系统</h3><p>$R_s = 1-{\prod_{i=1}^{n}}(1-R_i) $</p>
<h2 id="raid"><a href="#raid" class="headerlink" title="raid"></a>raid</h2><ul>
<li>raid0 一个数据分成 n 份, 带宽提高 n 倍, 最不安全, 速度最快</li>
<li>raid1 自动备份, 最安全, 空间利用最低, 速度不增</li>
<li>raid2 海明校验, 在 raid0 基础上增加纠错功能</li>
<li>raid3 raid0 + 一个存储恢复码的磁盘, 数据拆分</li>
<li>raid4 raid0 + 一个存储恢复码的磁盘, 数据不拆分</li>
<li>raid5 raid34 可能会因为恢复盘而制约性能, raid5 把恢复码分散到所有磁盘中</li>
<li>raid6 raid345 只能容灾一个磁盘, raid6 在 raid5 基础上使用两个容灾磁盘</li>
</ul>
<h1 id="第七章-互联网络"><a href="#第七章-互联网络" class="headerlink" title="第七章 互联网络"></a>第七章 互联网络</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>通信时延 = 软件开销+通道时延+选路时延+竞争时延</p>
<p>网络时延 = 通道时延+选路时延</p>
<h2 id="互连函数"><a href="#互连函数" class="headerlink" title="互连函数"></a>互连函数</h2><p>I 恒等函数</p>
<p>E 交换函数: 第 k 位取反</p>
<p>σ 均匀洗牌函数: 把输入端二进制标号循环左移一位</p>
<p>逆函数, 子函数(低 k 位), 超函数(高 k 位)</p>
<p>β 蝶式函数: 最高位最低位交换</p>
<p>ρ 反位序函数: 二进制位序颠倒</p>
<p>移数函数: α(x)=（x±k）mod N</p>
<p>PM2I 函数: x +- 2^i^ mod N </p>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><h3 id="通道时延"><a href="#通道时延" class="headerlink" title="通道时延"></a>通道时延</h3><ol>
<li>软件开销</li>
<li>通道时延 = 消息长度/通道带宽</li>
<li>选路时延</li>
<li>竞争时延</li>
</ol>
<h3 id="网络时延"><a href="#网络时延" class="headerlink" title="网络时延"></a>网络时延</h3><p>通道时延+选路时延</p>
<h2 id="静态互联网络"><a href="#静态互联网络" class="headerlink" title="静态互联网络"></a>静态互联网络</h2><p>线性阵列(单向环, 双向环, 带弦环)</p>
<p>全连接网络</p>
<p>循环移数网络, 2整数幂之间有弦</p>
<p>树形</p>
<p>星形</p>
<p>胖树</p>
<p>网格型, 环网形</p>
<p>illiac 网络</p>
<h2 id="总线网络"><a href="#总线网络" class="headerlink" title="总线网络"></a>总线网络</h2><h2 id="交叉开关网络"><a href="#交叉开关网络" class="headerlink" title="交叉开关网络"></a>交叉开关网络</h2><h1 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h1><h2 id="cache-的一致性"><a href="#cache-的一致性" class="headerlink" title="cache 的一致性"></a>cache 的一致性</h2><h3 id="监听式协议"><a href="#监听式协议" class="headerlink" title="监听式协议"></a>监听式协议</h3><p>监听总线</p>
<p>作废</p>
<h3 id="目录式协议"><a href="#目录式协议" class="headerlink" title="目录式协议"></a>目录式协议</h3><blockquote>
<p>数据库原理课程</p>
</blockquote>
<!--more-->

<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>组成要素: 数据结构, 数据操作, 完整性约束</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><h4 id="er-模型"><a href="#er-模型" class="headerlink" title="er 模型"></a>er 模型</h4><p>实体: 学生</p>
<p>属性: 学号 姓名</p>
<p>实体型: 学生(学号, 姓名)</p>
<p>码: 学号</p>
<h4 id="E-R图-entity-relationship-model"><a href="#E-R图-entity-relationship-model" class="headerlink" title="E-R图 entity relationship model"></a>E-R图 entity relationship model</h4><p>矩形: 实体型</p>
<p>菱形: 联系</p>
<p>椭圆形: 实体型与联系类型的属性</p>
<p>直线: 实体与属性间, 实体型与联系之间用直线相连, 线旁标注联系的种类(1:1, 1:N, M:N)</p>
<p>码: 属性加下划线</p>
<h3 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h3><p>层次模型, 树 冗余节点, 虚拟节点</p>
<p>网状模型</p>
<p>关系模型, 表 </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs61d4undoj30t60lmn94.jpg" alt="截屏2021-07-05 下午2.02.26"></p>
<p>面向对象模型</p>
<h2 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h2><p>模式=型<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs61jw7qtxj30t60fogrg.jpg" alt="截屏2021-07-05 下午2.08.59"></p>
<p>外模式(子模式, 用户模式), 数据库用户使用的局部数据结构, 应用程序可以直接访问, 一个应用程序只有一个外模式</p>
<p>内模式(存储模式, 物理模式)</p>
<h1 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2 关系数据库"></a>2 关系数据库</h1><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>笛卡尔积</p>
<p>候选码, 主码, 外码</p>
<h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设有如下四个关系：</span><br><span class="line">T(TNO,TNAME,TITLE)——描述某院系的各个教师的工作证号、姓名和职称；</span><br><span class="line">S(SNO,SNAME,SYEAR,TNO)——描述该院系的各个学生的学号、姓名、入学年份和学业导师的工作证号；</span><br><span class="line">P(PNO,PNAME,PYEAR)——描述该院系的各个科研项目的项目编号、项目名称和立项年份；</span><br><span class="line">TP(TNO,PNO)——描述教师参与科研项目的情况；</span><br><span class="line">SPT(SNO,PNO,TNO)——描述学生参与各个项目并在每个项目中的指导教师。</span><br><span class="line">请写出下列关系代数表达式</span><br></pre></td></tr></table></figure>

<h4 id="σ选择"><a href="#σ选择" class="headerlink" title="σ选择"></a>σ选择</h4><p>对关系R, σ<del>A&lt;5</del>(R) 代表A&lt;5的R 的子集, σ<del>A&lt;5^C=7</del>(R)</p>
<h4 id="π投影"><a href="#π投影" class="headerlink" title="π投影"></a>π投影</h4><p>从 R 中选出若干元素组成新关系π<del>B,C</del>(R)</p>
<h4 id="θ连接"><a href="#θ连接" class="headerlink" title="θ连接"></a>θ连接</h4><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqdx6r2ihbj30ji044gmv.jpg" alt="截屏2021-05-11 上午3.01.48" style="zoom:25%;" />

<p>等值连接-&gt;自然连接, 全左右外连接</p>
<h4 id="÷除法"><a href="#÷除法" class="headerlink" title="÷除法"></a>÷除法</h4><p>R(X, Y)÷S(Y, Z), 得到R 中 Y 与 S 中 Y 相等的R 中除Y 以外的投影</p>
<h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>主属性不能取空值</p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>假设, R中的F是S的主码, 则F是R的外码, R参照关系, S目标关系</p>
<p>参照完整性: R中每个元组在F上的值或者为空, 或者为S中某个元组的主码值</p>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><p>语义要求</p>
<h1 id="3-sql"><a href="#3-sql" class="headerlink" title="3 sql"></a>3 sql</h1><h2 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h2><p>类似命名空间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> schema schema_name <span class="keyword">authorization</span> user_name</span><br><span class="line"><span class="keyword">drop</span> schema cascade <span class="comment">--cascade表级联</span></span><br></pre></td></tr></table></figure>

<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">    id <span class="type">int</span>(<span class="keyword">constraint</span> PK_person <span class="keyword">primary</span> key),</span><br><span class="line">  	cno <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span>(<span class="keyword">references</span> course(cno)),</span><br><span class="line">    fullname <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    telephone <span class="type">char</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_person <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">  	<span class="keyword">constraint</span> fk_person_cno <span class="keyword">foreign</span> key(cno) <span class="keyword">references</span> cource(cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>primary key 不可为空 </p>
<p>unique 可有一个空 </p>
<p>not null</p>
<p>foreign key</p>
<p>check(逻辑表达式)</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_name <span class="keyword">on</span> table_name(column_name)</span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> phone <span class="type">char</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course <span class="keyword">alter</span> <span class="keyword">column</span> credit <span class="type">smallint</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> course <span class="keyword">add</span> <span class="keyword">constraint</span> fk_cpno <span class="keyword">foreign</span> key(cpno) <span class="keyword">references</span> course(cno)</span><br></pre></td></tr></table></figure>

<h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a1, a2 </span><br><span class="line">[<span class="keyword">from</span> <span class="keyword">table</span>] </span><br><span class="line">[<span class="keyword">where</span> exp] </span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> exp] </span><br><span class="line">[<span class="keyword">having</span> exp]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">asc</span> <span class="operator">|</span> <span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>



<h1 id="6-关系数据理论"><a href="#6-关系数据理论" class="headerlink" title="6 关系数据理论"></a>6 关系数据理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>任意性, 语义性, 与时间无关, </p>
<p>类似 f(x) = y</p>
<p>平凡(子集)非平凡(不是子集)</p>
<p>完全函数依赖, 部分函数依赖(只依赖一部分)</p>
<h2 id="函数依赖的公理系统"><a href="#函数依赖的公理系统" class="headerlink" title="函数依赖的公理系统"></a>函数依赖的公理系统</h2><p>依赖集 F</p>
<p>最小依赖集 F<del>m</del> </p>
<p>求候选码</p>
<p>求右边没有出现的 N, 求两边都出现的 LR</p>
<p>候选码 = N + LR 的一部分</p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>R(U, F) U 中每个属性和值均为不可再分的原子项</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>每一个<strong>非主属性</strong>都完全函数依赖于 R 的码</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>不存在<strong>非主属性</strong>对码的传递函数依赖</p>
<p>或: 关系模式 R 的所有非平凡函数依赖, 要么左侧包含候选码, 要么右侧是主属性</p>
<p>即不允许 x→y→z, x: 码, y: 不含码, z: 非主属性, 且 z∉y</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>非平凡函数依赖左侧必包含候选码</p>
<p>要么左侧包含候选码, 要么右侧是主属性</p>
<p>二元关系必为 bcnf</p>
<h3 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h3><p>没有非平凡的非函数依赖的多值依赖</p>
<h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><p>分解为两个的特殊算法: 交决定差</p>
<h1 id="9-关系查询和查询优化"><a href="#9-关系查询和查询优化" class="headerlink" title="9 关系查询和查询优化"></a>9 关系查询和查询优化</h1><h2 id="查询操作算法"><a href="#查询操作算法" class="headerlink" title="查询操作算法"></a>查询操作算法</h2><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>全表</p>
<p>索引</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>嵌套循环</p>
<p>排序合并</p>
<p>索引连接</p>
<p>哈希</p>
<h1 id="10-数据库恢复"><a href="#10-数据库恢复" class="headerlink" title="10 数据库恢复"></a>10 数据库恢复</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性, 一致性, 隔离性, 持续性</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>转储 备份+日志</p>
<p>日志文件 undo 没结束的, redo 结束的</p>
<p>检查点</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs6kgfbzccj30ou0fuad1.jpg" alt="截屏2021-07-06 上午1.03.03"></p>
<p>activelist-&gt;t2 t3</p>
<h1 id="11-并发控制"><a href="#11-并发控制" class="headerlink" title="11 并发控制"></a>11 并发控制</h1><p>丢失更新</p>
<p>读脏</p>
<p>不可重复读</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>x 写锁 s 读锁<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs6kregxo7j30qu0dyn0p.jpg" alt="截屏2021-07-06 上午1.13.36"></p>
<h3 id="1-级封锁协议"><a href="#1-级封锁协议" class="headerlink" title="1 级封锁协议"></a>1 级封锁协议</h3><p>修改前必须加 x 锁</p>
<p>可能读脏, 可能不可重复读</p>
<h3 id="2-级封锁协议"><a href="#2-级封锁协议" class="headerlink" title="2 级封锁协议"></a>2 级封锁协议</h3><p>1 级+读前加 s</p>
<p>可能不可重复读</p>
<h3 id="3-级封锁协议"><a href="#3-级封锁协议" class="headerlink" title="3 级封锁协议"></a>3 级封锁协议</h3><p>一直持有锁</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs6kvv5b9wj30t00j2qf8.jpg" alt="截屏2021-07-06 上午1.17.52"></p>
<p>不同事务同一数据, 读读可交换</p>
<p>不同事务不同数据, 读写都可交换</p>
<p>2pl</p>
<p>读写前申请封锁, 释放后不再获得其他封锁</p>
<p>is ix six 锁</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs6veub40nj30s40lkn7k.jpg" alt="截屏2021-07-06 上午7.22.04"></p>
<h1 id="sql-必知必会"><a href="#sql-必知必会" class="headerlink" title="sql 必知必会"></a>sql 必知必会</h1><h2 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h2><ul>
<li>主键列不允许为 null</li>
<li>主键值不允许修改或更新</li>
<li>主键值不能重用(如果某行被删除, 则它的主键不能赋给之后的新行)</li>
</ul>
<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><p>ASC 升序(0-9, A-Z), DESC 降序</p>
<p>排序子句必须是 select 语句的最后一句</p>
<h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><p>BETWEEN 1 AND 9</p>
<p>运算符优先级先 AND 再 OR</p>
<p>IN(‘1’, ‘2’) 枚举</p>
<h3 id="LIKE与通配符"><a href="#LIKE与通配符" class="headerlink" title="LIKE与通配符"></a>LIKE与通配符</h3><p><code>LIKE &#39;FISH%&#39;</code></p>
<p>%(*) 表示任何字符出现任意次数(0~n)</p>
<p>_(?)表示 1 个任意字符</p>
<p>[]表示一个字符集, 匹配一个字符, 可以加^表 NOT <code>[^JM]%</code>表示不以 J 或 M 开头的字符串</p>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><p>+-*/</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>文本处理函数如 trim()</p>
<p>日期处理函数如 datepart()</p>
<p>数值处理函数如 abs()</p>
<h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>运行在<strong>行组</strong>上, 计算和返回单个值的函数</p>
<p>AVG(), COUNT(), MAX(), MIN(), SUM()</p>
<p>只有 COUNT(*)不忽略 null, 其他都忽略 null</p>
<p>DISTINCT 关键字表示只包含不同的值(不重复计算)</p>
<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>将<strong>行</strong>分组</p>
<h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><p>类似于 where, 区别在于 where 过滤行, having 过滤分组</p>
<h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><h3 id="INNER-JOIN-ON"><a href="#INNER-JOIN-ON" class="headerlink" title="INNER JOIN ON"></a>INNER JOIN ON</h3><h3 id="OUTER-JOIN-ON"><a href="#OUTER-JOIN-ON" class="headerlink" title="OUTER JOIN ON"></a>OUTER JOIN ON</h3><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    fullname <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    telephone <span class="type">char</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_person <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 表2 地点表(location)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> location(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    location_name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_location <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 表3 行程表（itinerary）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> itinerary(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>, <span class="comment">--人员编号</span></span><br><span class="line">    loc_id <span class="type">int</span>, <span class="comment">--地点编号</span></span><br><span class="line">    s_time DATETIME,</span><br><span class="line">    e_time DATETIME,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_itinerary <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_itinerary_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_itinerary_lid <span class="keyword">FOREIGN</span> KEY (loc_id) <span class="keyword">REFERENCES</span> location(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 表4 诊断表（diagnose_record）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> diagnose_record(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>,</span><br><span class="line">    diagnose_date DATETIME,</span><br><span class="line">    <span class="keyword">result</span> <span class="type">int</span>, <span class="comment">--1：新冠确诊;2：无症状感染者;3：正常</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_diagnose_record <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_diagnose_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 表5 密切接触者表（close_contact）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> close_contact(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>,</span><br><span class="line">    loc_id <span class="type">int</span>,</span><br><span class="line">    contact_date DATETIME,</span><br><span class="line">    case_p_id <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_close_contact <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_contact_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_contact_lid <span class="keyword">FOREIGN</span> KEY (loc_id) <span class="keyword">REFERENCES</span> location(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_contact_caseid <span class="keyword">FOREIGN</span> KEY (case_p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 表6 隔离地点表（isolation_location）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> isolation_location(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    location_name <span class="type">char</span>(<span class="number">20</span>),</span><br><span class="line">    capacity <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_isolation_loc <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 表7 隔离表（isolation_record）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> isolation_record(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>,</span><br><span class="line">    isol_loc_id <span class="type">int</span>,</span><br><span class="line">    s_date DATETIME,</span><br><span class="line">    e_date DATETIME,</span><br><span class="line">    state <span class="type">int</span>,<span class="comment">--1：正在隔离 2：隔离结束 3：转入医院</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_isolation <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_isolation_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_isolation_lid <span class="keyword">FOREIGN</span> KEY (isol_loc_id) <span class="keyword">REFERENCES</span> isolation_location(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>创建用户, 修改权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> login user0 <span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;123qwe123&#x27;</span>, default_database<span class="operator">=</span>student</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> user0 <span class="keyword">for</span> login user0 <span class="keyword">with</span> default_schema<span class="operator">=</span>dbo</span><br><span class="line"><span class="keyword">exec</span> sp_addrolemember <span class="string">&#x27;db_owner&#x27;</span>, <span class="string">&#x27;dba&#x27;</span></span><br></pre></td></tr></table></figure>



<p>lab</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> combo(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>, <span class="comment">--人员编号</span></span><br><span class="line">    loc_id <span class="type">int</span>, <span class="comment">--地点编号</span></span><br><span class="line">    s_time DATETIME,</span><br><span class="line">    e_time DATETIME,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_itinerary <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_itinerary_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_itinerary_lid <span class="keyword">FOREIGN</span> KEY (loc_id) <span class="keyword">REFERENCES</span> location(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE covid19mon;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> DATABASE covid19mon;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE covid19mon;</span><br><span class="line">USE covid19mon;</span><br><span class="line">go</span><br><span class="line"><span class="comment">-- 请在以下适当的空白位置填写SQL语句完成任务书的要求。空白位置不够的话，可以通过回车换行增加。</span></span><br><span class="line"><span class="comment">-- 表1 人员表(person)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    fullname <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    telephone <span class="type">char</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_person <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表2 地点表(location)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> location(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    location_name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_location <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表3 行程表（itinerary）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> itinerary(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>, <span class="comment">--人员编号</span></span><br><span class="line">    loc_id <span class="type">int</span>, <span class="comment">--地点编号</span></span><br><span class="line">    s_time DATETIME,</span><br><span class="line">    e_time DATETIME,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_itinerary <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_itinerary_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_itinerary_lid <span class="keyword">FOREIGN</span> KEY (loc_id) <span class="keyword">REFERENCES</span> location(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表4 诊断表（diagnose_record）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> diagnose_record(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>,</span><br><span class="line">    diagnose_date DATETIME,</span><br><span class="line">    <span class="keyword">result</span> <span class="type">int</span>, <span class="comment">--1：新冠确诊;2：无症状感染者;3：正常</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_diagnose_record <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_diagnose_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表5 密切接触者表（close_contact）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> close_contact(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>,</span><br><span class="line">    loc_id <span class="type">int</span>,</span><br><span class="line">    contact_date DATETIME,</span><br><span class="line">    case_p_id <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_close_contact <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_contact_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_contact_lid <span class="keyword">FOREIGN</span> KEY (loc_id) <span class="keyword">REFERENCES</span> location(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_contact_caseid <span class="keyword">FOREIGN</span> KEY (case_p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表6 隔离地点表（isolation_location）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> isolation_location(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    location_name <span class="type">char</span>(<span class="number">20</span>),</span><br><span class="line">    capacity <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_isolation_loc <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表7 隔离表（isolation_record）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> isolation_record(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    p_id <span class="type">int</span>,</span><br><span class="line">    isol_loc_id <span class="type">int</span>,</span><br><span class="line">    s_date DATETIME,</span><br><span class="line">    e_date DATETIME,</span><br><span class="line">    state <span class="type">int</span>,<span class="comment">--1：正在隔离 2：隔离结束 3：转入医院</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_isolation <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_isolation_pid <span class="keyword">FOREIGN</span> KEY (p_id) <span class="keyword">REFERENCES</span> person(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_isolation_lid <span class="keyword">FOREIGN</span> KEY (isol_loc_id) <span class="keyword">REFERENCES</span> isolation_location(id)</span><br><span class="line">);</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">1</span>,N<span class="string">&#x27;张小敏&#x27;</span>,N<span class="string">&#x27;13907110001&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">2</span>,N<span class="string">&#x27;李大锤&#x27;</span>,N<span class="string">&#x27;18907110002&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">3</span>,N<span class="string">&#x27;孙二娘&#x27;</span>,N<span class="string">&#x27;13307100003&#x27;</span>);</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">UPDATE table_name <span class="keyword">SET</span> telephone<span class="operator">=</span>N<span class="string">&#x27;13607176668&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">--1</span></span><br><span class="line"><span class="keyword">select</span> location_name, <span class="built_in">count</span>(itinerary.loc_id) <span class="keyword">as</span> visitors</span><br><span class="line"><span class="keyword">from</span> itinerary</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> location</span><br><span class="line"><span class="keyword">ON</span> itinerary.loc_id <span class="operator">=</span> location.id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> location.location_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(itinerary.loc_id)<span class="operator">&gt;</span><span class="number">30</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> visitors <span class="keyword">DESC</span>, location_name <span class="keyword">ASC</span></span><br><span class="line"><span class="comment">--2</span></span><br><span class="line"><span class="keyword">SELECT</span> isolation_location.location_name, <span class="built_in">COUNT</span>(isolation_record.isol_loc_id) <span class="keyword">as</span> number</span><br><span class="line"><span class="keyword">FROM</span> isolation_location</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> isolation_record</span><br><span class="line"><span class="keyword">ON</span> isolation_record.isol_loc_id <span class="operator">=</span> isolation_location.id </span><br><span class="line"><span class="keyword">WHERE</span> isolation_record.state <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> isolation_location.location_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> number <span class="keyword">DESC</span>, isolation_location.location_name <span class="keyword">ASC</span></span><br><span class="line"><span class="comment">--3</span></span><br><span class="line"><span class="keyword">SELECT</span> person.<span class="operator">*</span>, x.e_time <span class="keyword">as</span> reclosing_time, loc1.id <span class="keyword">as</span> loc1, loc1.location_name <span class="keyword">as</span> address1, loc2.id <span class="keyword">as</span> loc2, loc2.location_name <span class="keyword">as</span> address2</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">itinerary x</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> person <span class="keyword">ON</span> x.p_id <span class="operator">=</span> person.id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> location <span class="keyword">as</span> loc1 <span class="keyword">ON</span> x.loc_id <span class="operator">=</span> loc1.id</span><br><span class="line"></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> </span><br><span class="line">(itinerary y</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> location <span class="keyword">as</span> loc2 <span class="keyword">ON</span> y.loc_id <span class="operator">=</span> loc2.id)</span><br><span class="line"><span class="keyword">ON</span> x.e_time <span class="operator">=</span> y.s_time <span class="keyword">AND</span> y.p_id <span class="operator">=</span> person.id</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> person.id<span class="operator">&gt;</span><span class="number">30</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> person.id, person.fullname, person.telephone, x.e_time, loc1.id, loc1.location_name, loc2.id, loc2.location_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> person.id, reclosing_time</span><br><span class="line"></span><br><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="keyword">SELECT</span> person.fullname, person.telephone, location.location_name, <span class="keyword">convert</span>(<span class="type">char</span>(<span class="number">19</span>),itinerary.s_time,<span class="number">20</span>) <span class="keyword">as</span> s_time, <span class="keyword">convert</span>(<span class="type">char</span>(<span class="number">19</span>),itinerary.e_time,<span class="number">20</span>) <span class="keyword">as</span> e_time</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">JOIN</span> itinerary <span class="keyword">ON</span> person.id <span class="operator">=</span> itinerary.p_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">JOIN</span> location <span class="keyword">ON</span> itinerary.loc_id <span class="operator">=</span> location.id</span><br><span class="line"><span class="keyword">WHERE</span> person.fullname <span class="keyword">in</span>(N<span class="string">&#x27;充珉瑶&#x27;</span>, N<span class="string">&#x27;贾涵山&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> person.id <span class="keyword">DESC</span>, itinerary.s_time</span><br><span class="line"></span><br><span class="line"><span class="comment">--5</span></span><br><span class="line"><span class="keyword">SELECT</span> id, location_name</span><br><span class="line"><span class="keyword">from</span> location</span><br><span class="line"><span class="keyword">WHERE</span> location_name <span class="keyword">LIKE</span> N<span class="string">&#x27;%店%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">by</span> id</span><br><span class="line"></span><br><span class="line"><span class="comment">--6</span></span><br><span class="line"><span class="keyword">SELECT</span> person.fullname, person.telephone</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">where</span> person.id</span><br><span class="line"><span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> itinerary.p_id </span><br><span class="line">    <span class="keyword">from</span> itinerary <span class="keyword">JOIN</span> location <span class="keyword">ON</span> itinerary.loc_id <span class="operator">=</span> location.id</span><br><span class="line">    <span class="keyword">where</span> location.location_name <span class="operator">=</span> N<span class="string">&#x27;活动中心&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> (</span><br><span class="line">        itinerary.e_time <span class="keyword">between</span> <span class="built_in">cast</span>(<span class="string">&#x27;2021-2-2 20:05:40&#x27;</span> <span class="keyword">as</span> datetime) <span class="keyword">and</span> <span class="built_in">cast</span>(<span class="string">&#x27;2021-2-2 21:25:40&#x27;</span> <span class="keyword">as</span> datetime)</span><br><span class="line">        <span class="keyword">or</span> </span><br><span class="line">        itinerary.s_time <span class="keyword">between</span> <span class="built_in">cast</span>(<span class="string">&#x27;2021-2-2 20:05:40&#x27;</span> <span class="keyword">as</span> datetime) <span class="keyword">and</span> <span class="built_in">cast</span>(<span class="string">&#x27;2021-2-2 21:25:40&#x27;</span> <span class="keyword">as</span> datetime)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> person.fullname</span><br><span class="line"><span class="comment">--7</span></span><br><span class="line"><span class="keyword">select</span> isolation_location.location_name</span><br><span class="line"><span class="keyword">from</span> isolation_location</span><br><span class="line"><span class="keyword">JOIN</span> isolation_record <span class="keyword">on</span> isolation_location.id <span class="operator">=</span> isolation_record.isol_loc_id</span><br><span class="line"><span class="keyword">WHERE</span> isolation_record.state <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> isolation_location.location_name, isolation_location.id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> isolation_location.id</span><br><span class="line"></span><br><span class="line"><span class="comment">--8</span></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">30</span> person.fullname, person.telephone</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">where</span> person.id <span class="keyword">in</span> (<span class="keyword">SELECT</span> itinerary.p_id <span class="keyword">from</span> itinerary)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> person.id</span><br><span class="line"></span><br><span class="line"><span class="comment">--9</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> number</span><br><span class="line"><span class="keyword">from</span>(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> person</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> itinerary </span><br><span class="line">        <span class="keyword">JOIN</span> location <span class="keyword">ON</span> itinerary.loc_id <span class="operator">=</span> location.id</span><br><span class="line">        <span class="keyword">where</span> location.location_name <span class="operator">=</span> N<span class="string">&#x27;Today便利店&#x27;</span></span><br><span class="line">        <span class="keyword">AND</span> person.id <span class="operator">=</span> itinerary.p_id</span><br><span class="line">        )</span><br><span class="line">) <span class="keyword">as</span> t</span><br><span class="line">    </span><br><span class="line"><span class="comment">--10***</span></span><br><span class="line"><span class="keyword">SELECT</span> person.fullname</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> location</span><br><span class="line">    <span class="keyword">WHERE</span> location.id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> itinerary.loc_id <span class="keyword">from</span> itinerary <span class="keyword">where</span> itinerary.p_id <span class="operator">=</span> person.id</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> person.fullname</span><br><span class="line"></span><br><span class="line"><span class="comment">--11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> isolation_location_status(id,location_name,capacity,occupied) <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> isolation_location.id,location_name,capacity,<span class="built_in">count</span>(isolation_record.isol_loc_id)</span><br><span class="line"><span class="keyword">from</span> isolation_location <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> isolation_record <span class="keyword">on</span> isolation_location.id<span class="operator">=</span>isolation_record.isol_loc_id <span class="keyword">and</span> state<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> isolation_location.id,location_name,capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">--12</span></span><br><span class="line"><span class="keyword">SELECT</span> location_name, capacity <span class="operator">-</span> occupied <span class="keyword">as</span> available_rooms</span><br><span class="line"><span class="keyword">from</span> isolation_location_status</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"></span><br><span class="line"><span class="comment">--13</span></span><br><span class="line"><span class="keyword">SELECT</span> person.fullname, person.telephone</span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">JOIN</span> itinerary <span class="keyword">ON</span> person.id <span class="operator">=</span> itinerary.p_id,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> itinerary <span class="keyword">WHERE</span> itinerary.p_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">from</span> person <span class="keyword">where</span> fullname <span class="operator">=</span> N<span class="string">&#x27;靳宛儿&#x27;</span>)) <span class="keyword">as</span> i</span><br><span class="line"><span class="keyword">WHERE</span> (<span class="keyword">NOT</span>((itinerary.e_time <span class="operator">&lt;</span> i.s_time) <span class="keyword">OR</span> (itinerary.s_time <span class="operator">&gt;</span> i.e_time))) <span class="keyword">AND</span> itinerary.loc_id <span class="operator">=</span> i.loc_id  </span><br><span class="line"><span class="keyword">AND</span> person.fullname <span class="operator">!=</span> N<span class="string">&#x27;靳宛儿&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">by</span> person.fullname</span><br><span class="line"></span><br><span class="line"><span class="comment">--14</span></span><br><span class="line"><span class="keyword">SELECT</span> location.location_name, <span class="built_in">COUNT</span>(person.id) <span class="keyword">as</span> close_contact_number</span><br><span class="line"><span class="keyword">from</span> location </span><br><span class="line"><span class="keyword">join</span> close_contact <span class="keyword">on</span> location.id <span class="operator">=</span> close_contact.loc_id</span><br><span class="line"><span class="keyword">join</span> person <span class="keyword">on</span> (person.id <span class="operator">=</span> close_contact.p_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> location.location_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> close_contact_number <span class="keyword">DESC</span>, location.location_name</span><br><span class="line"></span><br><span class="line"><span class="comment">--15</span></span><br><span class="line"><span class="keyword">SELECT</span> top <span class="number">1</span> person.id <span class="keyword">as</span> case_p_id, person.fullname, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> infected_number</span><br><span class="line"><span class="keyword">from</span> person, close_contact</span><br><span class="line"><span class="keyword">where</span> person.id <span class="operator">=</span> close_contact.case_p_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> person.id, person.fullname</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> infected_number <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--16</span></span><br><span class="line"><span class="keyword">select</span> top <span class="number">3</span> person.fullname, <span class="built_in">COUNT</span>(itinerary.id) <span class="keyword">as</span> record_number</span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">JOIN</span> itinerary <span class="keyword">on</span> person.id <span class="operator">=</span> itinerary.p_id</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span>((itinerary.e_time <span class="operator">&lt;</span> <span class="built_in">cast</span>(<span class="string">&#x27;2021-2-2 10:00:00&#x27;</span> <span class="keyword">as</span> datetime)) <span class="keyword">OR</span> (itinerary.s_time <span class="operator">&gt;</span> <span class="built_in">cast</span>(<span class="string">&#x27;2021-2-2 14:00:00&#x27;</span> <span class="keyword">as</span> datetime)))</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> person.fullname</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> record_number <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--17</span></span><br><span class="line"><span class="keyword">SELECT</span> location_name, capacity</span><br><span class="line"><span class="keyword">from</span> isolation_location <span class="keyword">as</span> i1</span><br><span class="line"><span class="keyword">where</span> <span class="number">2</span> <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> i2.capacity)</span><br><span class="line">    <span class="keyword">FROM</span> isolation_location <span class="keyword">as</span> i2</span><br><span class="line">    <span class="keyword">where</span> i2.capacity <span class="operator">&gt;=</span> i1.capacity</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">--4.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用create trigger语句创建符合任务要求的触发器（触发器名称自已命名）：</span></span><br><span class="line"><span class="comment">-- 当隔离表（isolation_record）中的某位隔离人员在诊断表（diagnose_record）中的</span></span><br><span class="line"><span class="comment">-- 诊断结果（result）为1(新冠确诊)时，自动将隔离表中的隔离状态（state)改成3（转入医院）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你需要考虑：</span></span><br><span class="line"><span class="comment">-- (1) 触发器应该建在哪个表上；</span></span><br><span class="line"><span class="comment">-- (2) 触发器执行的时机；</span></span><br><span class="line"><span class="comment">-- (3) (insert,update,delete)中的哪些(个）事件触发这个触发器运行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> tri</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri <span class="keyword">ON</span> diagnose_record after <span class="keyword">insert</span>, update</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> <span class="variable">@result</span> <span class="type">int</span>, <span class="variable">@p</span>_id <span class="type">int</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="variable">@result</span> <span class="operator">=</span> <span class="keyword">result</span>, <span class="variable">@p</span>_id <span class="operator">=</span> p_id <span class="keyword">from</span> inserted;</span><br><span class="line">        if(<span class="variable">@result</span> <span class="operator">=</span> <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">BEGIN</span></span><br><span class="line">                UPDATE isolation_record <span class="keyword">SET</span> state <span class="operator">=</span> <span class="number">3</span> <span class="keyword">where</span> isolation_record.p_id <span class="operator">=</span> <span class="variable">@p</span>_id</span><br><span class="line">            <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line">    GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri</span><br><span class="line"><span class="keyword">on</span> diagnose_record</span><br><span class="line">after update,<span class="keyword">insert</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  update isolation_record </span><br><span class="line">  <span class="keyword">set</span> state <span class="operator">=</span><span class="number">3</span></span><br><span class="line">  <span class="keyword">from</span> isolation_record</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span> diagnose_record</span><br><span class="line">  <span class="keyword">on</span> isolation_record.p_id <span class="operator">=</span> diagnose_record.p_id</span><br><span class="line">  <span class="keyword">where</span> diagnose_record.p_id <span class="keyword">in</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> p_id</span><br><span class="line">        <span class="keyword">from</span> inserted</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">result</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--4.2</span></span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">FUNCTION</span> Count_Records(<span class="variable">@p</span>_id <span class="type">int</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@result</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@result</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> itinerary <span class="keyword">where</span> itinerary.p_id <span class="operator">=</span> <span class="variable">@p</span>_id</span><br><span class="line">    <span class="keyword">RETURN</span> <span class="variable">@result</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">go</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> person <span class="keyword">where</span> dbo.Count_Records(person.id) <span class="operator">&gt;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>计算机系统基础课程</p>
</blockquote>
<!--more-->

<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="1-1-计算机基本工作原理"><a href="#1-1-计算机基本工作原理" class="headerlink" title="1.1 计算机基本工作原理"></a>1.1 计算机基本工作原理</h3><ul>
<li><p>存储程序</p>
</li>
<li><p>冯诺依曼结构 模型机的硬件基本结构</p>
<ul>
<li>主存, 算数逻辑部件 ALU(arithmetic logic unit), 控制部件 CU(control unit) 取出指令, 通用寄存器组 GPRs(general purpose register), 指令寄存器 IR(instruction register), 程序计数器 PC(program counter), 中央处理器 CPU(central processing unit)包括: 控制部件, 运算部件, 各类寄存器</li>
</ul>
</li>
</ul>
<h3 id="1-2-程序的开发与运行"><a href="#1-2-程序的开发与运行" class="headerlink" title="1.2 程序的开发与运行"></a>1.2 程序的开发与运行</h3><ul>
<li>机器语言</li>
<li>汇编语言</li>
<li>高级编程语言</li>
<li>翻译程序<ul>
<li>汇编程序 汇编-&gt;机器</li>
<li>解释程序 源程序逐条-&gt;机器</li>
<li>编译程序 高级语言-&gt;汇编/机器</li>
</ul>
</li>
<li>处理步骤: 预处理-&gt;编译-&gt;汇编-&gt;链接</li>
</ul>
<h3 id="1-3-计算机系统的层次结构"><a href="#1-3-计算机系统的层次结构" class="headerlink" title="1.3 计算机系统的层次结构"></a>1.3 计算机系统的层次结构</h3><ul>
<li><p>指令集体系结构 ISA(instruction set architecture)  </p>
<p>定义了 一台计算机可以执行的所有 指令的集合，每条指令规定了计算机执行什么操作，以及所处理的操作数存放的地址空间和操作数类型 。</p>
</li>
<li><p>微体系结构(microarchitecture) 微体系结构最终是由逻辑电路 (logic circuit) 实现的</p>
</li>
<li><p>应用程序二进制接口 ABI(application binary interface) 用来约束连接器</p>
</li>
<li><p>应用程序编程接口 ABI(application programming interface) 用来约束编译器</p>
<ul>
<li><p>区分</p>
<h4 id="API-Application-Program-Interface"><a href="#API-Application-Program-Interface" class="headerlink" title="API: Application Program Interface"></a>API: Application Program Interface</h4><p>This is the set of public types/variables/functions that you expose from your application/library.</p>
<p>In C/C++ this is what you expose in the header files that you ship with the application.</p>
<h4 id="ABI-Application-Binary-Interface"><a href="#ABI-Application-Binary-Interface" class="headerlink" title="ABI: Application Binary Interface"></a>ABI: Application Binary Interface</h4><p>This is how the compiler builds an application.<br>It defines things (but is not limited to):</p>
<ul>
<li>How parameters are passed to functions (registers/stack).</li>
<li>Who cleans parameters from the stack (caller/callee).</li>
<li>Where the return value is placed for return.</li>
<li>How exceptions propagate.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-计算机系统性能评价"><a href="#1-4-计算机系统性能评价" class="headerlink" title="1.4 计算机系统性能评价"></a>1.4 计算机系统性能评价</h3><ul>
<li>CPU 性能:<ul>
<li>时钟周期  CPU 的主脉冲信号， 其宽度称为时钟周期 (clock cycle,  tick,  clock  tick ,  clock ) </li>
<li>时钟频率 clock rate CPU 的圭埂就是 CPU 中的主脉冲信号的时钟频率 (clock rate) ,  是 CPU 时 钟周期的倒数 。</li>
<li>CPI(cycles per instruction) 表示执行一条指令所需的时钟周期数 。</li>
</ul>
</li>
</ul>
<h2 id="第二章-数据的机器级表示与处理"><a href="#第二章-数据的机器级表示与处理" class="headerlink" title="第二章 数据的机器级表示与处理"></a>第二章 数据的机器级表示与处理</h2><h3 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h3><ul>
<li><p>浮点数 <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3ntcaf7nj309s01i74j.jpg" alt="截屏2020-06-24 下午8.38.16"></p>
<p>其中阶 E 用”移码”来表示, 即对每个阶都加上一个偏置常数(bias), 使得所有阶都是正数</p>
</li>
<li><p>补码</p>
</li>
</ul>
<h3 id="2-2-整数的表示"><a href="#2-2-整数的表示" class="headerlink" title="2.2 整数的表示"></a>2.2 整数的表示</h3><ul>
<li>整型长度 <ul>
<li>short 16 位</li>
<li>int 16 位是 16 位 32 位是 32 位</li>
<li>long 32 位是 32 位 64 位是 64 位</li>
<li>longlong 64 位</li>
</ul>
</li>
</ul>
<h3 id="2-3-浮点数的表示"><a href="#2-3-浮点数的表示" class="headerlink" title="2.3 浮点数的表示"></a>2.3 浮点数的表示</h3><ul>
<li><p>IEEE754 标准</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3pebo5y0j30oy09qgo0.jpg" alt="截屏2020-06-24 下午9.33.05"></p>
<p>阶码用移码形式，偏置常数并不是通常 n 位移码所用的 2^n-1^ 而是 2^n-1^-1</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg4uayrh3dj311o0f2k36.jpg" alt="截屏2020-06-25 下午9.08.20"></p>
</li>
</ul>
<h3 id="2-4-十进制数的表示"><a href="#2-4-十进制数的表示" class="headerlink" title="2.4 十进制数的表示"></a>2.4 十进制数的表示</h3><ul>
<li>bcd 码</li>
</ul>
<h3 id="2-5-非数值数据的编码表示"><a href="#2-5-非数值数据的编码表示" class="headerlink" title="2.5 非数值数据的编码表示"></a>2.5 非数值数据的编码表示</h3><ul>
<li>逻辑值</li>
<li>西文字符 ascii</li>
<li>汉字字符 <ul>
<li>输入码(外码)</li>
<li>内码 </li>
<li>国际码</li>
<li>gb2312 94*94</li>
</ul>
</li>
</ul>
<h3 id="2-6-数据的宽度与存储"><a href="#2-6-数据的宽度与存储" class="headerlink" title="2.6 数据的宽度与存储"></a>2.6 数据的宽度与存储</h3><ul>
<li>字长!=字的长度=16</li>
<li>LSB MSB</li>
<li>大端(高权低位)   小端(低权低位)</li>
</ul>
<h3 id="2-7-数据的基本运算"><a href="#2-7-数据的基本运算" class="headerlink" title="2.7 数据的基本运算"></a>2.7 数据的基本运算</h3><ul>
<li>移位<ul>
<li>逻辑移位 高位补 0</li>
<li>算数移位 高位补符号</li>
</ul>
</li>
<li>整数加减?</li>
<li>整数乘除?</li>
<li>浮点数运算<ul>
<li>对阶 小阶向大阶看齐</li>
<li>尾数加减</li>
<li>尾数规格化</li>
<li>尾数舍入</li>
<li>阶码溢出判断</li>
</ul>
</li>
</ul>
<h2 id="第三章-程序的转换及机器级表示"><a href="#第三章-程序的转换及机器级表示" class="headerlink" title="第三章 程序的转换及机器级表示"></a>第三章 程序的转换及机器级表示</h2><blockquote>
<p>IA-32</p>
</blockquote>
<h3 id="3-1-程序转换概述"><a href="#3-1-程序转换概述" class="headerlink" title="3.1 程序转换概述"></a>3.1 程序转换概述</h3><ul>
<li>汇编</li>
<li>指令集体系结构 ISA(instruction set architecture) 机器语言虚拟机</li>
<li>生成机器代码的过程<ul>
<li>预处理.i, 编译.s, 汇编.o, 链接</li>
</ul>
</li>
<li>AT&amp;T <ul>
<li>存储器操作数形式为＂偏移量（基址寄存器，变址寄存器，比例因子） “</li>
<li>100(%ebx, %esi ,4)  表示存储单元的地址为 EBX 的内容加 ESI 的内容乘以 4 再加 100</li>
</ul>
</li>
</ul>
<h3 id="3-2-IA-32-intel-architecture-32-bit-指令系统概述"><a href="#3-2-IA-32-intel-architecture-32-bit-指令系统概述" class="headerlink" title="3.2 IA-32 (intel architecture 32-bit)指令系统概述"></a>3.2 IA-32 (intel architecture 32-bit)指令系统概述</h3><ul>
<li><p>数据类型及格式</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg920c0yh1j312o0cc12u.jpg" alt="截屏2020-06-29 下午12.37.08"></p>
</li>
<li><p>寄存器</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg921zanq2j30qe0kador.jpg" alt="截屏2020-06-29 下午12.38.47"></p>
<ul>
<li>通用寄存器</li>
<li>EFLAGS</li>
<li>段寄存器</li>
<li>浮点寄存器栈</li>
<li>多媒体扩展寄存器组</li>
</ul>
</li>
<li><p>寻址方式</p>
<ul>
<li>立即寻址, 寄存器寻址, 存储器操作数</li>
<li>工作模式<ul>
<li>实地址模式</li>
<li>保护模式</li>
</ul>
</li>
</ul>
</li>
<li><p>机器指令格式</p>
</li>
</ul>
<h3 id="3-3-IA-32-常用指令"><a href="#3-3-IA-32-常用指令" class="headerlink" title="3.3 IA-32 常用指令"></a>3.3 IA-32 常用指令</h3><ul>
<li>CALL RET</li>
</ul>
<h3 id="3-4-c-语言程序的机器级表示"><a href="#3-4-c-语言程序的机器级表示" class="headerlink" title="3.4 c 语言程序的机器级表示"></a>3.4 c 语言程序的机器级表示</h3><ul>
<li>过程调用</li>
<li>栈帧 当前栈帧的范围在帧指针 EBP 和栈指针 ESP 指向区域之间</li>
</ul>
<h3 id="3-5-复杂数据类型的分配和访问"><a href="#3-5-复杂数据类型的分配和访问" class="headerlink" title="3.5 复杂数据类型的分配和访问"></a>3.5 复杂数据类型的分配和访问</h3><ul>
<li>数组?</li>
<li>数据的对齐</li>
</ul>
<h3 id="3-6-越界访问-缓冲区溢出"><a href="#3-6-越界访问-缓冲区溢出" class="headerlink" title="3.6 越界访问 缓冲区溢出"></a>3.6 越界访问 缓冲区溢出</h3><ul>
<li>缓冲区溢出攻击<ul>
<li>应对策略</li>
</ul>
</li>
</ul>
<h2 id="第一次实验"><a href="#第一次实验" class="headerlink" title="第一次实验"></a>第一次实验</h2><h3 id="msb-与-lsb"><a href="#msb-与-lsb" class="headerlink" title="msb 与 lsb"></a>msb 与 lsb</h3><blockquote>
<p><strong>Most Significant Bit， Last（Least） Significant Bit</strong></p>
</blockquote>
<h4 id="大端-小端"><a href="#大端-小端" class="headerlink" title="大端 小端"></a>大端 小端</h4><p>PowerPC系列采用big endian方式存储数据</p>
<p>x86系列则采用little endian方式存储数据</p>
<p>其实big endian是指低地址存放最高有效字节（MSB），而little endian则是低地址存放最低有效字节（LSB）。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>对于float单精度浮点来说，它有32个比特位，其中第一位是符号位，和补码一样，第一位是0说明是正数，是1说明是负数</p>
<p>第二位到第九位是所谓的阶码。为了说明什么是阶码，我们先看这个十进制式子 <img src="https://www.zhihu.com/equation?tex=1.2%5Ctimes10%5E%7B5%7D" alt="[公式]"> ，看见右上角那个5了ma，那个东西就类似我们说的阶码，只不过计算机用的是二进制，所以实际上应该写成 <img src="https://www.zhihu.com/equation?tex=(1.x_%7B1%7Dx_%7B2%7Dx_%7B3%7D...)_%7B(2)%7D%5Ctimes2%5E%7BE%7D" alt="[公式]"> ，这里的E就是我们的阶码了，只不过由于诡异的IEEE754标准，这个E还不是真正的阶码，也就是说浮点数不是简单的1.xxxxx乘上 <img src="https://www.zhihu.com/equation?tex=2%5E%7Bn%7D" alt="[公式]"> ，n是几就左/右移几位。实际上，假如你要表示的数是1.0101，你要把10101乘上 <img src="https://www.zhihu.com/equation?tex=2%5E%7B-4%7D" alt="[公式]"> ，但是计算机中真正的阶码是 <img src="https://www.zhihu.com/equation?tex=(-4)+127" alt="[公式]"> 而不是-4——别问为什么，教科书上写了很多这么做的好处，这里我们只需要知道这一点即可。</p>
<p>剩下的23位是所谓的尾数，也就是 <img src="https://www.zhihu.com/equation?tex=1.x_%7B1%7Dx_%7B2%7Dx_%7B3%7D..." alt="[公式]"> 中的那个 <img src="https://www.zhihu.com/equation?tex=x_%7B1%7Dx_%7B2%7Dx_%7B3%7D..." alt="[公式]"> ，<strong>注意这里的尾数都是以原码表示的</strong>。你问我为什么开头一定是1？就像标准的十进制科学记数法开头一定是个1位数一样，开头为1是二进制的正规化数的“标准”，也就是说，开头为1才是二进制数科学记数法的“标准写法”……总之，记住这里有一个1就好了，到时候我们不要忘记加上。</p>
<p><img src="https://img-blog.csdnimg.cn/20190213233956617.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190213223146755.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>简介</p>
</blockquote>
<!--more-->

<h1 id="计算机组成原理实验"><a href="#计算机组成原理实验" class="headerlink" title="计算机组成原理实验"></a>计算机组成原理实验</h1><h2 id="实验-1-数据表示实验"><a href="#实验-1-数据表示实验" class="headerlink" title="实验 1 数据表示实验"></a>实验 1 数据表示实验</h2><h3 id="汉字编码实验"><a href="#汉字编码实验" class="headerlink" title="汉字编码实验"></a>汉字编码实验</h3><p>机内码 计算机内存储字符时使用的编码， 如 ascii，gb2312</p>
<p>区位码 4 位10 进制 <code>gb2312 汉字机内码=区位码+0xA0A0</code></p>
<p>字形码</p>
<p>偶校验: 如果一组给定数据位中1的个数是奇数，补一个bit为1，使得总的1的个数是偶数。例：0000001, 补一个bit为1, 0000001<strong>1</strong></p>
<p>奇校验同理</p>
<h2 id="实验-2"><a href="#实验-2" class="headerlink" title="实验 2"></a>实验 2</h2><p>gsp  c4 c3</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk3z8s4incj31gm0pgnid.jpg" alt="截屏2020-10-27 下午4.35.03"></p>
<h2 id="实验-4"><a href="#实验-4" class="headerlink" title="实验 4"></a>实验 4</h2><h3 id="中断处理机制"><a href="#中断处理机制" class="headerlink" title="中断处理机制"></a>中断处理机制</h3><ul>
<li><p>异常与中断概念</p>
<ul>
<li><p>内部异常</p>
<ul>
<li><p>CPU内部引起的异常事件，也称内部中断</p>
</li>
<li><p>分类</p>
<ul>
<li><p>故障（Fault）</p>
<ul>
<li><p>指令执行引起，未定义指令、除数为零、缺页等</p>
</li>
<li><p>可恢复的故障，指令需恢复执行</p>
</li>
<li><p>不可恢复故障，进程被终止</p>
</li>
</ul>
</li>
<li><p>自陷（trap）</p>
<ul>
<li>系统调用、条件陷阱，位置固定，类似函数调用</li>
</ul>
</li>
<li><p>终止（Abort）</p>
<ul>
<li>随机出现的使得 CPU 无法继续执行的硬件故障，和具体指令无关。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部中断</p>
<ul>
<li><p>由外部设备向 CPU 发出的中断请求（如鼠标点击、按键动作）</p>
</li>
<li><p>CPU 暂时中断当前正在执行的程序，转去执行为某外设事件服务的中断服务程序，处理完毕后再返回断点继续执行</p>
</li>
<li><p>可屏蔽中断，非可屏蔽中断</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部中断处理过程</p>
<ul>
<li><p>中断时机？</p>
<ul>
<li>指令执行周期最后一拍，如有中断请求则进入中断响应周期</li>
</ul>
</li>
<li><p>中断判别？</p>
<ul>
<li>外部中断会通过中断请求IntR信号发送给CPU</li>
</ul>
</li>
<li><p>完整中断流程</p>
<ul>
<li><p>中断响应</p>
<ul>
<li><p>实现中断函数的调用</p>
</li>
<li><p>中断隐指令完成的数据通路</p>
<ul>
<li><p>关中断</p>
<ul>
<li><p>清除中断使能寄存器IE</p>
</li>
<li><p>IE与中断请求逻辑与后送控制器</p>
</li>
<li><p>关中断后控制器无法接收新的中断请求</p>
</li>
</ul>
</li>
<li><p>保存断点</p>
<ul>
<li>保存PC值，X86进堆栈，MIPS送EPC</li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li>识别中断源，并将对应中断服务程序入口地址送PC</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU执行中断服务程序</p>
</li>
<li><p>中断返回</p>
<ul>
<li><p>中断服务程序最后一条指令为中断返回指令</p>
</li>
<li><p>MIPS：eret     X86：iret</p>
</li>
<li><p>单级中断中该指令开中断同时将断点地址送PC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>支持中断的CPU设计</p>
<ul>
<li><p>硬件支持</p>
<ul>
<li><p>增加中断响应周期</p>
<ul>
<li><p>修改指令执行状态机</p>
</li>
<li><p>所有指令的最后一个状态需要进行中断请求判断</p>
</li>
<li><p>有中断进入中断响应周期</p>
</li>
<li><p>中断响应周期结束进入取指令公操作</p>
</li>
</ul>
</li>
<li><p>相关硬件与数据通路</p>
<ul>
<li><p>开关中断</p>
<ul>
<li><p>增加IE寄存器，用于屏蔽中断请求，为0时关中断，为1时开中断</p>
</li>
<li><p>开中断，关中断信号分别连接置位和复位信号</p>
</li>
<li><p>默认开中断，可以连接寄存器的~Q端</p>
</li>
</ul>
</li>
<li><p>保存断点</p>
<ul>
<li><p>增加EPC寄存器/堆栈</p>
</li>
<li><p>增加EPC与PC之间的通路</p>
</li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li><p>增加中断控制逻辑</p>
</li>
<li><p>能识别中断源，产生中断请求和中断号</p>
</li>
<li><p>能根据中断号自动获取中断入口地址送PC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软件支持</p>
<ul>
<li><p>中断返回指令支持</p>
</li>
<li><p>编写中断服务程序</p>
<ul>
<li><p>保护现场</p>
<ul>
<li><p>压栈方式保护</p>
</li>
<li><p>所有在中断服务程序中被改写的通用寄存器都需要压栈</p>
</li>
<li><p>EPC，中断屏蔽字等</p>
</li>
</ul>
</li>
<li><p>中断服务</p>
</li>
<li><p>恢复现场</p>
</li>
<li><p>中断返回</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>控制器实现</p>
<ul>
<li><p>在原有状态机中增加中断响应周期路径和eret指令路径</p>
</li>
<li><p>微程序</p>
<ul>
<li><p>控制字段增加与中断相关的控制信号</p>
</li>
<li><p>判别测试字段增加Pend位，表示当前微指令为微程序的最后一条微指令，需要根据中断请求信号Intr的值进行中断判别</p>
</li>
<li><p>注意中断响应周期最后一个状态也需要设置Pend</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="mooc"><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h1><h2 id="1-计算机系统概论"><a href="#1-计算机系统概论" class="headerlink" title="1. 计算机系统概论"></a>1. 计算机系统概论</h2><ul>
<li><p>冯诺依曼结构计算的工作原理: 存储程序 程序控制</p>
<p>对应硬件: 主机(CPU(运算器, 控制器), 内存), 外设(io, 外存储器), 总线(地址线, 数据线, 控制线)</p>
<ul>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3y3el1vvj30z60imtox.jpg" alt="截屏2020-09-26 下午12.34.11"></li>
</ul>
</li>
<li><p>系统性能评价</p>
<ul>
<li><p>非时间指标: 机器字长, 总线宽度, 主存容量与存储带宽(与总线宽度和传输速度相关)</p>
</li>
<li><p>时间指标: </p>
<ul>
<li><p>主频(1/时间周期) 主频 = 外频 * 倍频</p>
</li>
<li><p>CPI(clock cycles per instruction) (加权平均)</p>
<p>CPI = 指令周期之和/指令总数</p>
</li>
<li><p>MPIS 百万为单位</p>
<p>全性能公式: MPIS = (f/CPI) * 10 ^-6^</p>
</li>
<li><p>cpu时间 = 所有指令时钟周期之和 * T</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机性能测试 几款软件</p>
</li>
</ul>
<h2 id="2-数据表示"><a href="#2-数据表示" class="headerlink" title="2. 数据表示"></a>2. 数据表示</h2><ul>
<li><p>机器数及其特点</p>
<p>反码最高位进位加到最低位</p>
</li>
<li><p>定点数与浮点数</p>
</li>
<li><p>数据校验</p>
<p>码距, 校验码增加的冗余就是为了增大码距</p>
<p>码距与纠错能力</p>
<ul>
<li>码距&gt;=e+1, 可检测 e 个错误</li>
<li>码距&gt;=2t+1, 可纠正 t 个错误</li>
<li>码距&gt;=e+t+1, 可纠正 t 个错误, 同时检测 e 个错误(e&gt;=t)</li>
</ul>
</li>
<li><p>奇偶校验</p>
<p>偶校验: 使得 1 的个数为偶数个, 所有位异或可得偶校验码, G = 传输来的所有位异或, G = 0 则无错误</p>
<p>奇校验: 所有位异或后取非, G = 传输来的所有位异或后取非, G = 0 则无错误</p>
<p>特点: 只能检测一位错误, 无错信息不可靠, 不能纠错</p>
<p>码距: 2</p>
<p>双向奇偶校验: 在传统基础上加一个垂直的校验, (右下角应该是横向的校验吧)</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj43jinnhsj30780863zv.jpg" alt="截屏2020-09-26 下午3.42.48"></p>
</li>
<li><p>crc 校验</p>
<p>N = k + r &lt;= 2^r^ - 1 k有效信息, r 校验位</p>
<p>查表得生成多项式 G(x) 然后用 G(x)进行模 2 运算(异或)得到余数, 原数据+余数组成数据发送出去, 接收方把得到的数用 G(x)进行模 2 运算, 余数为 0 则正确, 而如果余数不为 0, 余数和出错位有一个对应关系, 与 G(x)有关, 与数据无关, 要查表</p>
</li>
<li><p>海明码</p>
<p>N = k + r &lt;= 2^r^ - 1</p>
<p>设从左到右为 1 ~ k+r 位, 数据位 D, 校验位 P</p>
<p>P 在 2^n^位置</p>
<p>D<del>i</del> 中的 i 决定参与哪些 P 的校验, P = D<del>xxx</del> ^ D<del>xxx</del> ^ …</p>
<p>指错字 G<del>i</del> = P<del>i</del> ^ D<del>xxx</del> ^ D<del>xxx</del> ^ …</p>
<p>G<del>4</del>G<del>3</del>G<del>2</del>G<del>1</del> 就是出错位, 都为 0 时表示无错</p>
<p>特点: 指错字为 0 不一定无错, 一位出错和两位出错不能由指错字区分(配合奇偶校验可以区分)</p>
</li>
</ul>
<h2 id="3-运算方法与运算器"><a href="#3-运算方法与运算器" class="headerlink" title="3. 运算方法与运算器"></a>3. 运算方法与运算器</h2><ul>
<li><p>定点数运算和溢出, 定点数补码加减运算器设计</p>
<p>补码运算, 已知 Y 的补码, 求 -Y 的补码: 可从右向左扫描, 在遇到 1 及以前, 直接输出, 之后取反输出, 得到 -Y 补码/所有位取反再最后加一</p>
<p>判断溢出的三种方法</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj44y5bauwj30u012t15m.jpg" alt="深入理解计算机系统（第三版文字版）-60"></p>
<ul>
<li><p>四位串行加法器(简单)</p>
<p>实现减法?取反加一</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk3vo6mblzj30te0j6q9z.jpg" alt="截屏2020-10-27 下午2.31.44"></p>
<p>溢出检测, 第二种最简单</p>
</li>
<li><p>并行(先行)加法运算器</p>
<p>Gi=XiYi</p>
<p>Pi=Xi^Yi</p>
<p>C4 = G4+G3P4+G2P4P3+G1P4P3P2+C0P4P3P2P1</p>
<p>C3 = G3+G2P3+G1P3P2+C0P3P2P1</p>
<p>…</p>
</li>
</ul>
</li>
<li><p>原码一位乘法</p>
<p>符号位单独运算</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj45ru9yx9j311w0l4dx6.jpg" alt="截屏2020-09-26 下午4.59.45"></p>
</li>
<li><p>补码一位乘法</p>
<p>[x*y]<del>补</del> = [x]<del>补</del> * Σ(y<del>i+1</del> - y<del>i</del>) * 2^-i^</p>
<p><strong>算数右移</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj45wuj1ekj30rc0d0n6c.jpg" alt="截屏2020-09-26 下午5.04.39"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj45ywwml4j30rq08e79y.jpg" alt="截屏2020-09-26 下午5.06.47"></p>
</li>
<li><p>乘法运算器的设计</p>
<p>原码阵列乘法器</p>
<p>补码阵列乘法器</p>
</li>
<li><p>定点数除法</p>
</li>
</ul>
<h2 id="4-存储系统"><a href="#4-存储系统" class="headerlink" title="4. 存储系统"></a>4. 存储系统</h2><h3 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h3><blockquote>
<p>cache</p>
<p>cpu -&gt; cache -&gt; 主存 -&gt; 辅存</p>
</blockquote>
<p>L1 cache 集成在 CPU 中, 分数据 cache(D-Cache)和指令 cache(I-Cache)</p>
<p>L2 cahce 在主板上或与 cpu 集成在同一电路板上, 随着工艺提高 L2cahce 被集成在 cpu 内核中, 不分 d-cahce 和 i-cache</p>
<p>局部性原理:</p>
<ul>
<li><p>时间局部性</p>
<p>现在访问的信息在不久以后还会被访问</p>
</li>
<li><p>空间局部性</p>
<p>下一次访问的信息在这次访问的附近</p>
</li>
</ul>
<h3 id="主存中的数据组织"><a href="#主存中的数据组织" class="headerlink" title="主存中的数据组织"></a>主存中的数据组织</h3><ul>
<li>存储字长: 主存中一个存储单元所包含的二进制位数</li>
<li>ISA 设计时要考虑的两个问题<ul>
<li>如何根据字节地址读取一个 32 位的字 字的存放问题</li>
<li>一个字能否存放在主存的任何字节边界 字的边界对齐问题</li>
</ul>
</li>
<li>大端 高字节地址是数据的地址</li>
<li>小端 低字节地址是数据的地址</li>
</ul>
<h3 id="静态存储器的工作原理"><a href="#静态存储器的工作原理" class="headerlink" title="静态存储器的工作原理"></a>静态存储器的工作原理</h3><ul>
<li><p>SRAM 存储单元结构</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb7np7zrnj30c40gk78l.jpg" alt="截屏2020-11-02 下午10.45.20" style="zoom:33%;" />

<ul>
<li><p>工作管: t1, t2(保存数据)</p>
</li>
<li><p>负载管: t3 t4(补充电荷)</p>
</li>
<li><p>门控管: t5 t6 t7 t8(开关作用)</p>
</li>
<li><p>写操作 </p>
<p>x 有效, t5 t6 通, a 与 i/o 连通</p>
<p>y 有效, t7 t8 通, b 与 !i/o 连通</p>
<p>i/o = 1 -&gt; A = 1 -&gt; T2 通 -&gt; B = 0 -&gt; T1 截止</p>
<p>!i/o = 0 -&gt; B = 0 -&gt; T1 截止 -&gt; A = 1 -&gt; T2 通</p>
<p>此时 T1 T2形成了稳态, A = 1, B = 0</p>
<p>此时写 1</p>
<p>相反写 0</p>
</li>
<li><p>读操作</p>
<p>x 有效, t5 t6 通, a 与 i/o 连通</p>
<p>y 有效, t7 t8 通, b 与 !i/o 连通</p>
<p>读 1 的时候, A = 1, B = 0</p>
<p>通过外接于 i/o 和!i/o 之间的电流放大器中的电流方向可以判断出读的是 1 还是 0</p>
</li>
<li><p>无论读写, xy 译码线都要有效</p>
</li>
<li><p>保持: xy 撤销后, 由 t3t4 为 t1t2 提供工作电流, 保持其稳定互锁状态不变</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb825f5zuj30zs0ieh1b.jpg" alt="截屏2020-11-02 下午10.59.16"></p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb851v7z3j30rc0eq45p.jpg" alt="截屏2020-11-02 下午11.02.05"></p>
</li>
</ul>
</li>
</ul>
<h3 id="动态存储器的工作原理"><a href="#动态存储器的工作原理" class="headerlink" title="动态存储器的工作原理"></a>动态存储器的工作原理</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8bnovhcj30ys0hedwb.jpg" alt="截屏2020-11-02 下午11.08.22"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8esl6d9j30xw0is1ck.jpg" alt="截屏2020-11-02 下午11.11.27"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8j4w095j30yy0d6wpl.jpg" alt="截屏2020-11-02 下午11.15.37"></p>
<ul>
<li>集中刷新</li>
<li>分散刷新</li>
<li>异步刷新</li>
</ul>
<h3 id="存储扩展"><a href="#存储扩展" class="headerlink" title="存储扩展"></a>存储扩展</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb8oqsco8j30xy0ee15g.jpg" alt="截屏2020-11-02 下午11.21.01"></p>
<p>Mk*N M:容量, N:位长</p>
<p>字扩展和位扩展</p>
<h3 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h3><p>高位多体交叉存储器: 类似字扩展</p>
<p>低位多体交叉存储器: 相邻地址存在不同存储器中, 可以并行访问, 每个单体都有单独的地址寄存器</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gki99w81cfj30vc0j6ar8.jpg" alt="截屏2020-11-09 上午1.00.10"></p>
<h3 id="cache-基本原理"><a href="#cache-基本原理" class="headerlink" title="cache 基本原理"></a>cache 基本原理</h3><p>写: 写穿策略, 写回策略</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gki9fg07sij30p60icjx1.jpg" alt="image-20201109010537809"></p>
<p>cache 结构</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gki9gnevk3j30y40ie14e.jpg" alt="截屏2020-11-09 上午1.06.33"></p>
<h3 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h3><p>相联存储器作用: 判断 cpu 要访问的内容是否在cache 中</p>
<p>贮存地址-&gt;查找依据</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyca18d4rsj30wk0jywgs.jpg" alt="截屏2020-11-09 上午1.14.27"></p>
<h3 id="cache-地址映射和变换方法"><a href="#cache-地址映射和变换方法" class="headerlink" title="cache 地址映射和变换方法"></a>cache 地址映射和变换方法</h3><ul>
<li><p>全相联</p>
<p>主存分块, cache 分行, 大小一致, 将主存的地址变为二维地址(块地址tag+块内序号 (字))</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyca18zvftj30uu0l0q4y.jpg" alt="image-20201109012214178"></p>
<p>cache 所有空间都可以利用, 但是比对过程复杂, 适用于小容量 cache</p>
</li>
<li><p>直接相联</p>
<p>主存分块, cache 分行, 大小一致</p>
<p>主存地址分为三部分, tag index offset</p>
<p>tag 就是 tag, index 为 cache 的哪一行, offset 为第几个字, 形成一个三维结构</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkia2k5rnqj31240fsanl.jpg" alt="截屏2020-11-09 上午1.27.33"></p>
<p>cache 利用率低, 容易冲突, 但是淘汰算法简单, 适用于大容量 cache</p>
</li>
<li><p>组相联</p>
<p>主存分块, cache 分行, 大小一致</p>
<p>cache 分组, 每组含 k 行, 以组队内存进行划分</p>
<p>主存地址分为: tag, 组号, index 第几组, offset 第几个字</p>
</li>
</ul>
<h3 id="替换算法-淘汰算法"><a href="#替换算法-淘汰算法" class="headerlink" title="替换算法(淘汰算法)"></a>替换算法(淘汰算法)</h3><ul>
<li>先进先出算法FIFO 维持一个计数器, 先进来的先被替换</li>
<li>最不经常使用算法LFU 维持一个计数器, 命中++, 把命中的最少的淘汰掉</li>
<li>近期最少使用LRU 维持一个计数器, 把访问间隔时间最长的替换掉</li>
<li>随机替换法 </li>
</ul>
<h3 id="高速缓冲存储器例题"><a href="#高速缓冲存储器例题" class="headerlink" title="高速缓冲存储器例题"></a>高速缓冲存储器例题</h3><h3 id="虚拟存储器-1"><a href="#虚拟存储器-1" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>解决主存不足的问题</p>
<p>处于主存-辅存层次</p>
<p>页式虚拟存储器</p>
<p>MMU(memery management unit)管理虚拟存储器和物理存储器 </p>
<p>虚拟地址: 虚页号+页偏移量</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4nbq8cej30ti0f4n4q.jpg" alt="截屏2020-11-09 下午7.05.43"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4p8qm7kj30rw0icdlv.jpg" alt="截屏2020-11-09 下午7.07.37"></p>
<h3 id="TLB-translation-lookaside-buffer"><a href="#TLB-translation-lookaside-buffer" class="headerlink" title="TLB(translation lookaside buffer)"></a>TLB(translation lookaside buffer)</h3><p>虚拟地址的转换 PTE 页表项</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4tuy6pij30u00dgwkx.jpg" alt="截屏2020-11-09 下午7.12.02"></p>
<p> <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj4vv63evj31340hen7i.jpg" alt="截屏2020-11-09 下午7.13.58"></p>
<p>TLB: 增加一个小容量, 高速存储部件存放当前访问页表地址变换条目</p>
<p>基于 TLB 的虚实地址转换</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj504t8jcj31060pg154.jpg" alt="截屏2020-11-09 下午7.18.04"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj5493tzzj30vu0ky7c0.jpg" alt="截屏2020-11-09 下午7.22.02"></p>
<h3 id="RAID-redundant-arrays-of-inexpensive-disks-gt"><a href="#RAID-redundant-arrays-of-inexpensive-disks-gt" class="headerlink" title="RAID(redundant arrays of inexpensive disks-&gt;"></a>RAID(redundant arrays of inexpensive disks-&gt;</h3><h3 id="redundant-arrays-of-independent-disks"><a href="#redundant-arrays-of-independent-disks" class="headerlink" title="redundant arrays of independent disks)"></a>redundant arrays of independent disks)</h3><p>核心技术: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1^0&#x3D;1 1&#x3D;0^1</span><br><span class="line">1^1&#x3D;0 1&#x3D;1^0</span><br><span class="line">0^0&#x3D;0 0&#x3D;0^0</span><br></pre></td></tr></table></figure>

<p>有一个磁盘坏了, 可以通过异或得到原来的数据</p>
<ul>
<li><p>RAID0 没有冗余</p>
<p>数据以条带方式均匀分布在各个磁盘(并行)</p>
<p>优点: 磁盘读写效率高</p>
<p>缺点: 无冗余</p>
</li>
<li><p>RAID1</p>
<p>数据采用镜像的冗余方式, 一个数据有多分拷贝</p>
<p>优点: 100%数据冗余, 理论上可以实现两倍读取速率</p>
<p>缺点: 空间利用率只有 1/2 </p>
</li>
<li><p>RAID3 RAID4</p>
<p>数据按位(3)/条(4)并行传输到多个磁盘上, 同时校验数据存放到专用校验盘上</p>
<p>优点: 磁盘利用率=(N-1)/N</p>
<p>缺点: 控制器复杂, 校验磁盘的写性能有瓶颈</p>
</li>
<li><p>RAID5</p>
<p>数据按条分布在不同的磁盘上, 但校验信息被均匀的分散到各个磁盘上 </p>
</li>
<li><p>RAID10</p>
<p>结合 RAID0 和 RAID1, 先镜像, 再条带化</p>
</li>
<li><p>RAID01</p>
<p>结合 RAID0 和 RAID1, 先条带化, 再镜像</p>
</li>
</ul>
<h2 id="5-指令系统"><a href="#5-指令系统" class="headerlink" title="5. 指令系统"></a>5. 指令系统</h2><h3 id="指令系统概述和指令格式"><a href="#指令系统概述和指令格式" class="headerlink" title="指令系统概述和指令格式"></a>指令系统概述和指令格式</h3><p>指令系统: 一台计算机中所有机器指令的集合</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkjbtdzm8oj318y0bctin.jpg" alt="截屏2020-11-09 下午11.13.47"></p>
<p>指令分类</p>
<ul>
<li>地址码字段的分类<ul>
<li>三地址</li>
<li>二地址</li>
<li>一地址</li>
<li>零地址</li>
</ul>
</li>
<li>操作数的物理位置<ul>
<li>存储器, 存储器 SS</li>
<li>寄存器, 寄存器 RR</li>
<li>寄存器, 存储器 RS</li>
</ul>
</li>
<li>功能</li>
</ul>
<p>指令格式</p>
<p>操作码字段+寻址方式+地址码字段</p>
<h3 id="寻址方式-指令寻址"><a href="#寻址方式-指令寻址" class="headerlink" title="寻址方式 指令寻址"></a>寻址方式 指令寻址</h3><ul>
<li><p>指令寻址</p>
<ul>
<li><p>顺序寻址</p>
<p>指令序列在主存中顺序存放, 逐条执行</p>
<p>CPU 中设置 PC 程序计数器</p>
</li>
<li><p>跳跃寻址</p>
<p><code>JMP</code> </p>
</li>
</ul>
</li>
</ul>
<h3 id="操作数寻址"><a href="#操作数寻址" class="headerlink" title="操作数寻址"></a>操作数寻址</h3><ul>
<li><p>立即数寻址 <code>mov ax, 200h</code></p>
</li>
<li><p>寄存器寻址 <code>mov ax, bx</code></p>
</li>
<li><p>直接寻址 <code>mov ax, [200h]</code></p>
</li>
<li><p>间接寻址 <code>mov ax, i[200h]</code> 访问两次内存, 第一次访问主存得到地址, 再访问主存得到数据</p>
</li>
<li><p>寄存器间接寻址 <code>mov ax, [bx]</code> 访问一次主存</p>
</li>
<li><p>相对寻址 注意 pc 值在跳转过程的变化(+1)</p>
<p>从 2003h-&gt;200Ah : 200Ah-(2003h+2) = 5</p>
</li>
<li><p>基址寻址 <code>mov ax, 32[b]</code></p>
</li>
<li><p>变址寻址 <code>mov ax, 32[si]</code> 可循环</p>
</li>
</ul>
<h3 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h3><p><strong>操作码字段 寻址方式 地址码字段</strong></p>
<h3 id="MIPS-32-指令概述"><a href="#MIPS-32-指令概述" class="headerlink" title="MIPS(32) 指令概述"></a>MIPS(32) 指令概述</h3><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p><img src="http://tva1.sinaimg.cn/large/0081Kckwgy1gl54xmkf0uj314o0o4x0u.jpg" alt="截屏2020-11-28 下午7.58.05"></p>
<h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ul>
<li>立即数寻址</li>
<li>寄存器直接寻址</li>
<li>基址寻址</li>
<li>相对寻址</li>
<li>伪直接寻址</li>
</ul>
<h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4><h2 id="6-cpu"><a href="#6-cpu" class="headerlink" title="6. cpu"></a>6. cpu</h2><ul>
<li><p>6.1      中央处理器概述</p>
<ul>
<li><p>6.1.1       中央处理器的功能</p>
<ul>
<li><p>循环取指令执行指令</p>
<ul>
<li><p>程序控制</p>
<ul>
<li>控制程序中指令执行的顺序</li>
</ul>
</li>
<li><p>操作控制</p>
<ul>
<li>产生指令执行过程中所需要的操作控制信号</li>
</ul>
</li>
<li><p>时序控制</p>
<ul>
<li>对每个操作控制信号进行定时，严格控制每个操作控制信号的开始时间和持续时间</li>
</ul>
</li>
<li><p>数据加工</p>
<ul>
<li>即对数据进行算术、逻辑运算，或将数据在相关部件之间传送。</li>
</ul>
</li>
<li><p>中断处理</p>
<ul>
<li>CPU 应能及时响应内部异常和外部中断请求</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.1.2       中央处理器的组成</p>
<ul>
<li><p>控制器</p>
<ul>
<li>时序发生器、操作控制器</li>
</ul>
</li>
<li><p>运算器</p>
<ul>
<li>ALU、寄存器文件</li>
</ul>
</li>
<li><p>常用寄存器</p>
<ul>
<li><p>PC (Program Counter)——程序计数器     </p>
<ul>
<li>X86：EIP  MIPS：PC</li>
</ul>
</li>
<li><p>IR (Instruction Register)——指令寄存器                      [可选]</p>
</li>
<li><p>AR (Address Register)——地址寄存器      MAR           [可选]</p>
</li>
<li><p>DR (Data Register)——数据缓冲寄存器     MDR          [可选]</p>
</li>
<li><p>AC (Accumulate Count)——累加寄存器                      [可选]</p>
<ul>
<li>常见于早期计算机</li>
</ul>
</li>
<li><p>PSW (Program Status Word)——程序状态字               [可选]</p>
<ul>
<li>X86： EFLAGS   MIPS：无</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.2      指令周期</p>
<ul>
<li><p>6.2.1       指令执行的一般流程</p>
<ul>
<li>图解<img src="https://api2.mubu.com/v3/document_image/50029e8b-b45f-4abd-8a5f-83a16b879dde-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>6.2.2       指令周期的基本概念</p>
<ul>
<li><p>通常将一条指令从取出到执行完成所需要的时间称为指令周期</p>
<ul>
<li><p>若干机器周期</p>
<ul>
<li><p>机器周期：取指令所需要的最短时间，指令cache命中时最短</p>
</li>
<li><p>一个机器周期又包括若干时钟周期，可以进行一系列复杂的操作</p>
</li>
<li><p>一个时钟周期只能进行简单的微操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最简单的划分：取指周期+执行周期+中断周期</p>
<ul>
<li>执行周期还可以进一步细分，如间址周期</li>
</ul>
</li>
<li><p>不同的寻址方式，不同的设计指令周期划分是不确定的</p>
</li>
</ul>
</li>
<li><p>6.2.3       寄存器传送语言</p>
<ul>
<li>用于描述指令执行过程中的数据通路</li>
</ul>
</li>
</ul>
</li>
<li><p>6.3      数据通路及指令操作流程</p>
<ul>
<li><p>6.3.1       数据通路模型与定时</p>
<ul>
<li><p>常见数据图解<img src="https://api2.mubu.com/v3/document_image/1a4635b4-ff95-4071-a099-6fa8ca5be453-329792.jpg" alt="img"></p>
</li>
<li><p>数据通路的时钟频率取决于数据处理单元的关键延迟</p>
</li>
</ul>
</li>
<li><p>6.3.2       基于单总线结构的数据通路</p>
<ul>
<li><p>基本特征</p>
<ul>
<li><p>CPU 中的运算器、控制器、寄存器堆等核心部件均通过一条内部的公共总线连接起来</p>
</li>
<li><p>同一时刻只有一个部件向总线输出数据</p>
</li>
<li><p>数据传输只能分时使用总线</p>
</li>
</ul>
</li>
<li><p>数据通路图解</p>
<ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/de297a77-e1a7-4624-ab32-74542bf0bc8e-329792.jpg" alt="img"></p>
</li>
<li><p>指令周期图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/b837e953-d556-493b-a5bd-2bf1efee0fbe-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.3.3       基于专用通路结构的数据通路</p>
<ul>
<li><p>基本特征</p>
<ul>
<li><p>各功能部件之间均基于专用的数据传输通路连接</p>
</li>
<li><p>各通路中的数据可并行传输，控制较总线结构要简单</p>
</li>
</ul>
</li>
<li><p>单周期MIPS</p>
<ul>
<li><p>所有指令一个时钟周期完成，CPI=1，但时钟频率取决于最慢的LW指令</p>
</li>
<li><p>数据、指令分开存放保证取指令和取操作数并行</p>
</li>
<li><p>运算PC、运算分支地址、运算数据所需的ALU分别设置，成本较高</p>
</li>
<li><p>控制器为组合逻辑，不同指令产生不同的控制信号组合，形成对应的数据通路</p>
</li>
</ul>
</li>
<li><p>多周期MIPS（不考）</p>
<ul>
<li><p>不再区分指令存储器和数据存储器，指令和数据保存在同一存储器中。</p>
</li>
<li><p>部分功能单元，如 A</p>
</li>
<li><p>LU可在一条指令执行过程的不同时钟周期中多次使用，不需要额外设置ALU或加法器。</p>
</li>
<li><p>主要功能单元输出端都增加了一些附加寄存器，方便暂存当前时钟周期加工处理的数据给后续时钟周期使用</p>
<ul>
<li><p>DR、IR</p>
</li>
<li><p>A、B  缓存寄存器操作数</p>
</li>
<li><p>C 缓存分支地址或ALU运算结果</p>
</li>
<li><p>增加和扩展了部分多路选择器</p>
</li>
<li><p>增加了ALU控制器</p>
<ul>
<li><p>专门负责产生 ALU 的运算选择控制信号 AluOP</p>
</li>
<li><p>方便合并R型运算指令以及I型指令的状态机</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>指令周期图解</p>
<ul>
<li><p>注意S2，S5状态可以合并，R型运算指令共享S8<del>S9路径，I型运算共享S10</del>S11路径<img src="https://api2.mubu.com/v3/document_image/b5c00733-af77-4711-9c26-dc5f7f220ed0-329792.jpg" alt="img"></p>
</li>
<li><p>控制器是时序逻辑，需要实现尚需状态机，每一个圆圈一个时钟周期</p>
</li>
<li><p>不同指令时钟周期数不一样</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.4      时序与控制</p>
<ul>
<li><p>6.4.1       中央处理器的时序</p>
<ul>
<li><p>传统三级时序</p>
<ul>
<li><p>机器周期电位、节拍电位、节拍脉冲</p>
</li>
<li><p>时序图</p>
<ul>
<li><p>一条指令包括x个机器周期，一个机器周期包括y个节拍，一个节拍包括z个脉冲<img src="https://api2.mubu.com/v3/document_image/a33be99e-bc66-4436-998e-bca2a2fb81f4-329792.jpg" alt="img"></p>
</li>
<li><p>x，y，z的值与指令寻址方式，CPU设计等有关，可固定，也可以变化</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>现代时序：只有时钟周期，指令执行过程是时钟驱动的状态机</p>
</li>
</ul>
</li>
<li><p>6.4.2       控制方式</p>
<ul>
<li><p>同步控制</p>
<ul>
<li><p>指令周期定长</p>
</li>
<li><p>机器周期数固定</p>
</li>
</ul>
</li>
<li><p>异步控制</p>
<ul>
<li><p>按需分配时钟</p>
</li>
<li><p>指令周期可变，机器周期可变</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.4.3       时序发生器</p>
<ul>
<li><p>输入时钟脉冲信号，指令译码信号、反馈信号持续不断的产生状态周期电位和节拍电位，操作控制器利用这些周期、节拍电位信号对操作控制信号进行时序的调制，生成控制信号序列。</p>
</li>
<li><p>输入：clk，指令译码、反馈信号</p>
</li>
<li><p>输出：状态周期电位，节拍电位</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/1abe4764-4514-435f-b534-2407d3e520fb-329792.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/f512c9fb-8f50-4b21-a49e-7814f5249688-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>设计思路</p>
<ul>
<li><p>利用数字逻辑同步时序电路设计方法进行构造，根据状态机进行实现</p>
</li>
<li><p>定长指令周期状态机</p>
<ul>
<li>状态切换只与时钟信号有关<img src="https://api2.mubu.com/v3/document_image/7cfd71a3-b48c-4735-a505-4e6460e37ea0-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>变长指令周期状态机</p>
<ul>
<li>状态切换还与指令译码有关<img src="https://api2.mubu.com/v3/document_image/47faac3c-6d3b-44df-bf74-13495098dc50-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.5      硬布线控制器</p>
<ul>
<li><p>6.5.1       三级时序硬布线控制器</p>
<ul>
<li><p>硬布线控制器是组合逻辑</p>
<ul>
<li><p>输入：指令译码、状态周期电位、节拍电位、反馈信号</p>
</li>
<li><p>输出Cn：微操作控制器信号序列</p>
</li>
<li><p>逻辑函数<img src="https://api2.mubu.com/v3/document_image/ebded0fa-35ac-4d6c-a252-ae2c43a47c31-329792.jpg" alt="img"></p>
</li>
<li><p>例子<img src="https://api2.mubu.com/v3/document_image/dd7dd982-93ff-4bf9-9e4b-cdb4c451e462-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>图例<img src="https://api2.mubu.com/v3/document_image/7f324698-97c6-4832-8ad7-4c929cbd40f2-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>6.5.2       三级时序硬布线控制器设计</p>
<ul>
<li><p>设计流程</p>
<ul>
<li><p>分析指令执行的数据通路，列出各指令执行操作流程每一步所需要的控制信号</p>
</li>
<li><p>对指令的操作流程进行细化，将每条指令的每个微操作分配到具体机器周期的具体时间节拍信号上，即对操作控制信号进行同步控制</p>
</li>
<li><p>根据控制信号同步控制方式构造合适的时序发生器</p>
</li>
<li><p>对每一个控制信号进行逻辑综合，得到每个控制信号的逻辑表达式</p>
</li>
<li><p>最后采用逻辑门或 PLA 或 ROM 实现逻辑表达式的功能</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.5.3       现代时序硬布线控制器</p>
<ul>
<li><p>核心是有限状态机</p>
</li>
<li><p>控制信号是现态的函数</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/0daf4262-d213-490b-b1b0-231b30a6dcab-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>6.5.4       现代时序硬布线控制器设计</p>
<ul>
<li><p>设计流程</p>
<ul>
<li><p>分析指令执行的数据通路，列出每条指令执行操作流程每一步所需要的控制信号</p>
</li>
<li><p>对指令的操作流程进行细化，将每条指令的每个微操作分配到具体时钟节拍上</p>
</li>
<li><p>以时钟周期为单位构建指令执行状态图，生成状态转换表，实现有限状态机</p>
</li>
<li><p>收集每一个控制信号产生的所有状态条件，得到每个控制信号的逻辑表达式。</p>
</li>
<li><p>最后采用逻辑门或 PLA 或 ROM 实现硬布线控制器逻辑</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.6      微程序控制器</p>
<ul>
<li><p>6.6.1       微程序控制的基本概念</p>
<ul>
<li><p>存储逻辑：控制信号序列不由硬件产生，而是像程序一样存储起来</p>
<ul>
<li><p>控制信号序列分解为若干时钟节拍</p>
</li>
<li><p>一个节拍的控制信号编成一条微指令</p>
</li>
<li><p>一条指令有多少节拍就对应多少条微指令，形成一段微程序</p>
</li>
<li><p>取指令过程是公操作，取指令过程对应取指微程序，取指微程序为所有指令共享</p>
</li>
<li><p>控存中的微程序图解<img src="https://api2.mubu.com/v3/document_image/98eb7b3b-ac19-4da5-9c90-fdefe3009d46-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>软时序：依序执行微指令即可生成控制信号序列</p>
<ul>
<li><p>执行一条微指令，给出对应的控制信号</p>
</li>
<li><p>微指令周期就是一个时钟周期，控制器信号的时间长度就是一个节拍</p>
</li>
<li><p>软时序：按顺序执行微指令，就是按顺序给出控制信号</p>
</li>
<li><p>指令取指执行→微程序执行→ 微指令执行→生成控制信号序列</p>
</li>
</ul>
</li>
<li><p>微指令格式</p>
<ul>
<li><p>操作控制字段：存储微操作控制信号</p>
<ul>
<li>每一位对应一个控制信号，也称微命令，可同时给出多个操作信号</li>
</ul>
</li>
<li><p>顺序控制字段：控制微程序执行顺序</p>
<ul>
<li><p>判别测试位：如果为1，要约定条件生成下一条微指令地址</p>
</li>
<li><p>下址字段：判别测试条件为0时下一条微指令的地址</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>图解<img src="https://api2.mubu.com/v3/document_image/6e825efb-3223-4ea2-8bdf-43f4cf234cb7-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>6.6.2       微程序控制器组成原理</p>
<ul>
<li><p>初始化，微地址寄存器为0,控存0号单元为取指令微程序入口</p>
</li>
<li><p>下址字段法<img src="https://api2.mubu.com/v3/document_image/5ce99f63-5b98-48ce-a0a3-e3ec53b02d3a-329792.jpg" alt="img"></p>
</li>
<li><p>计数器法</p>
<ul>
<li>增加一个Pend，表示最后一条微指令，下一条微指令应该返回取指微程序<img src="https://api2.mubu.com/v3/document_image/2b6dd194-5a6b-406e-8a9f-5846ae257b5f-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>6.6.3       微程序控制器设计</p>
<ul>
<li><p>分析指令执行的数据通路，给出控制信号序列，根据控制信号设计微指令控制字段</p>
</li>
<li><p>以时钟周期为单位构建指令执行状态图。</p>
</li>
<li><p>一个状态对应一条微指令</p>
</li>
<li><p>根据状态机设计微指令，安排微程序，状态字等价于微地址</p>
</li>
<li><p>根据状态机分支情况设置判别测试位</p>
</li>
<li><p>根据控存中微程序存放组织方式构建微程序控制器中的地址转移逻辑，微地址寄存器μAR、控存之间的通路，实现微程序控制器</p>
</li>
</ul>
</li>
<li><p>6.6.4       微指令及其编码方法</p>
<ul>
<li><p>微指令编码方法</p>
<ul>
<li><p>直接表示法</p>
<ul>
<li>简单，并行，速度快，微指令字长</li>
</ul>
</li>
<li><p>编码表示法</p>
<ul>
<li>微指令字短、增加译码器延迟</li>
</ul>
</li>
<li><p>混合表示法</p>
</li>
</ul>
</li>
<li><p>微指令格式</p>
<ul>
<li><p>水平微指令</p>
<ul>
<li>编程难，微程序短，并行性高，速度快，控存开销大</li>
</ul>
</li>
<li><p>垂直微指令</p>
<ul>
<li>编程易，微程序长，并行性差，速度慢，控存开销小，已淘汰</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.7      异常与中断处理</p>
<ul>
<li><p>异常与中断概念</p>
<ul>
<li><p>内部异常</p>
<ul>
<li><p>CPU内部引起的异常事件，也称内部中断</p>
</li>
<li><p>分类</p>
<ul>
<li><p>故障（Fault）</p>
<ul>
<li><p>指令执行引起，未定义指令、除数为零、缺页等</p>
</li>
<li><p>可恢复的故障，指令需恢复执行</p>
</li>
<li><p>不可恢复故障，进程被终止</p>
</li>
</ul>
</li>
<li><p>自陷（trap）</p>
<ul>
<li>系统调用、条件陷阱，位置固定，类似函数调用</li>
</ul>
</li>
<li><p>终止（Abort）</p>
<ul>
<li>随机出现的使得 CPU 无法继续执行的硬件故障，和具体指令无关。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部中断</p>
<ul>
<li><p>由外部设备向 CPU 发出的中断请求（如鼠标点击、按键动作）</p>
</li>
<li><p>CPU 暂时中断当前正在执行的程序，转去执行为某外设事件服务的中断服务程序，处理完毕后再返回断点继续执行</p>
</li>
<li><p>可屏蔽中断，非可屏蔽中断</p>
</li>
</ul>
</li>
<li><p>外部中断处理过程</p>
<ul>
<li><p>中断流程</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/3efffa6b-20d3-41d8-82c6-2cfeca1f0cd4-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>中断时机？</p>
<ul>
<li>指令执行周期最后一拍，如有中断请求则进入中断响应周期</li>
</ul>
</li>
<li><p>中断判别？</p>
<ul>
<li>外部中断会通过中断请求IntR信号发送给CPU</li>
</ul>
</li>
<li><p>完整中断流程</p>
<ul>
<li><p>中断响应</p>
<ul>
<li><p>实现中断函数的调用</p>
</li>
<li><p>中断隐指令完成的数据通路</p>
<ul>
<li><p>关中断</p>
<ul>
<li><p>清除中断使能寄存器IE</p>
</li>
<li><p>IE与中断请求逻辑与后送控制器</p>
</li>
<li><p>关中断后控制器无法接收新的中断请求</p>
</li>
</ul>
</li>
<li><p>保存断点</p>
<ul>
<li>保存PC值，X86进堆栈，MIPS送EPC</li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li>识别中断源，并将对应中断服务程序入口地址送PC</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU执行中断服务程序</p>
</li>
<li><p>中断返回</p>
<ul>
<li><p>中断服务程序最后一条指令为中断返回指令</p>
</li>
<li><p>MIPS：eret     X86：iret</p>
</li>
<li><p>单级中断中该指令开中断同时将断点地址送PC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>支持中断的CPU设计</p>
<ul>
<li><p>硬件支持</p>
<ul>
<li><p>增加中断响应周期</p>
<ul>
<li><p>修改指令执行状态机</p>
<ul>
<li>传统时序状态机<ul>
<li><img src="https://api2.mubu.com/v3/document_image/f70b744c-ebf2-46ae-8054-c44a60303ddc-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>现代时序状态机</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/b95070b0-98a5-4551-8da2-8e866e337529-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li><p>所有指令的最后一个状态需要进行中断请求判断</p>
</li>
<li><p>有中断进入中断响应周期</p>
</li>
<li><p>中断响应周期结束进入取指令公操作</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>相关硬件与数据通路</p>
<ul>
<li><p>开关中断</p>
<ul>
<li><p>增加IE寄存器，用于屏蔽中断请求，为0时关中断，为1时开中断</p>
</li>
<li><p>注意初始化时应该默认开中断</p>
</li>
</ul>
</li>
<li><p>开中断，关中断信号分别连接置位和复位信号</p>
<ul>
<li><p>默认开中断，可以连接寄存器的~Q端</p>
</li>
<li><p><img src="https://api2.mubu.com/v3/document_image/04a6d766-3947-4886-afef-9040dc7a5038-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>保存断点</p>
</li>
<li><p>增加EPC寄存器/堆栈</p>
</li>
<li><p>增加EPC与PC之间的通路</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/5db28da8-3982-4382-960c-77912759a36a-329792.jpg" alt="img"></li>
</ul>
</li>
<li><p>中断识别</p>
<ul>
<li><p>增加中断控制逻辑</p>
</li>
<li><p>能识别中断源，产生中断请求和中断号</p>
</li>
<li><p>能根据中断号自动获取中断入口地址送PC</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/e7da8ad8-18e6-4141-9472-db00c197f905-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>软件支持</p>
<ul>
<li><p>中断返回指令支持</p>
</li>
<li><p>编写中断服务程序</p>
</li>
<li><p>保护现场</p>
<ul>
<li><p>压栈方式保护</p>
</li>
<li><p>所有在中断服务程序中被改写的通用寄存器都需要压栈</p>
</li>
<li><p>EPC，中断屏蔽字等</p>
</li>
</ul>
</li>
<li><p>中断服务</p>
</li>
<li><p>恢复现场</p>
</li>
<li><p>中断返回</p>
</li>
<li><p>图解</p>
</li>
<li><p><img src="https://api2.mubu.com/v3/document_image/5c589cbf-4251-4b78-8e63-5e82c56975a2-329792.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>控制器实现</p>
<ul>
<li><p>在原有状态机中增加中断响应周期路径和eret指令路径</p>
</li>
<li><p>微程序</p>
</li>
<li><p>控制字段增加与中断相关的控制信号</p>
</li>
<li><p>判别测试字段增加Pend位，表示当前微指令为微程序的最后一条微指令，需要根据中断请求信号Intr的值进行中断判别</p>
</li>
<li><p>图解</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/3e281b8b-61b9-4ed4-b5d6-05fc58c86bc7-329792.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h2><h3 id="程序被翻译为不同的格式"><a href="#程序被翻译为不同的格式" class="headerlink" title="程序被翻译为不同的格式"></a>程序被翻译为不同的格式</h3><p>上下文</p>
<p>hello.c -预处理器(cpp, preprocesser)-&gt; hello.i -编译器(ccl, compiler)-&gt; hello.s -汇编器(as, assembler)-&gt; hello.o -连接器(ld, linker)-&gt; hello</p>
<p>GNU 项目 GNU is not Unix</p>
<p>​    GCC(GNU compiler collection), GDB(GNU debugger) 工具</p>
<h3 id="系统硬件"><a href="#系统硬件" class="headerlink" title="系统硬件"></a>系统硬件</h3><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>字长, bit byte 为国际单位, 字长不是, 字长与机器本身相关</p>
<h4 id="io-设备"><a href="#io-设备" class="headerlink" title="io 设备"></a>io 设备</h4><p>每个 io 设备都通过一个控制器或适配器与 io 总线相连</p>
<p>控制器是io 设备本身或者系统的主印刷电路板上的芯片组</p>
<p>适配器是一块插在主板插槽上的卡</p>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>DRAM(dynamic random access memory)</p>
<h4 id="处理器-CPU"><a href="#处理器-CPU" class="headerlink" title="处理器 CPU"></a>处理器 CPU</h4><p>处理器的核心是一个大小为一个字的存储设备(寄存器), 成为程序计数器(PC), PC 在任何时候都指向主存中的某条机器指令</p>
<p>处理器的</p>
<p>​    指令集架构: 每条机器代码指令的效果</p>
<p>​    微体系结构: 处理器实际上是如何实现的</p>
<h3 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h3><p>由快到慢: 寄存器, L1 高速缓存, L2 高速缓存, L3 高速缓存, DRAM, 本地二级存储(本地硬盘), 远程二级存储(分布式文件系统, web 服务器)</p>
<h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>上下文切换</p>
<p>内核: 内核是操作系统代码常驻主存的部分</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>每个线程都运行在进程的上下文中, 并共享同样的代码和全局数据</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gip88f6ju0j30mh0inths.jpg" alt="IMG_FB723107648D-1"></p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h3 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h3><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><blockquote>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。</p>
<p>所以我认为它们最关键的点就是：是否是『同时』。</p>
<p><strong>转自知乎</strong></p>
</blockquote>
<p><strong>处理器</strong>, 和操作系统课的并发区分! </p>
<p>并发: 指一个同时具有多个活动的系统</p>
<p>并行: 用并发来使一个系统运行的更快</p>
<h5 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h5><p>单处理器</p>
<p>多核处理器</p>
<p>超线程(同时多线程)???</p>
<h5 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h5><p>现代处理器可以同时执行多条指令的属性称为指令级并行</p>
<p>超标量: 如果处理器可以达到比一个周期一条指令更快的执行速率, 就称之为超标量处理器</p>
<h5 id="单指令-多数据并行"><a href="#单指令-多数据并行" class="headerlink" title="单指令, 多数据并行"></a>单指令, 多数据并行</h5><p>允许一条指令产生多个可以并行执行的操作</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><h2 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h2><p>ISO: international organization for standardization</p>
<h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><p>内存 –&gt; 虚拟内存</p>
<p>每个字节 –&gt; 地址</p>
<p>所有可能的地址的集合 –&gt; 虚拟地址空间</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj41qk2i2gj30gv0exafo.jpg" alt="IMG_0A3C8AB125D9-1"></p>
<p>0x12345678</p>
<p>大端 12 34 56 78</p>
<p>小端 78 56 34 12</p>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><ul>
<li><p>检测无符号加法中的溢出</p>
<p>S = x + y - 2^w^</p>
<p>而 x, y &lt; 2^w^</p>
<p>所以 S &lt; x, y</p>
</li>
<li><p>无符号数求反</p>
<p>!x = 2^w^ - x</p>
<p>∵ !x + x = 2^w^</p>
</li>
<li><p>补码加法</p>
<p>x + y = x + y - 2 * 2^w-1^</p>
<p>x + y = x + y</p>
<p>x + y = x + y + 2* 2^w-1^</p>
<p>(符号位的权为 2^w-1^)</p>
</li>
<li><p>补码的溢出</p>
<p>参考补码加法和无符号加法的溢出, 可知 S 与 x, y 符号相反时发生溢出</p>
</li>
<li><p>补码乘法</p>
<p>-2^w-1^&lt;x, y&lt;2^w-1^-1</p>
<p>-2^w-1^ * (2^w-1^-1) &lt; x*y &lt; 2^w-1^ * 2^w-1^</p>
</li>
<li><p>除以 2</p>
<p>x&gt;&gt;k = x/2^k^ 向下取整 (因为右移出去的 1 变成 0 , 值变小)</p>
<p>但是对于负数, 我们希望向 0 舍入, 引入概念偏置</p>
<p>偏置 biasing(b) 移k 位, b = 2^k^-1</p>
<p>对于不需要舍入的, 不会改变值, 对于需要舍入的会进 1 位, 从而实现向上舍入</p>
</li>
</ul>
<h3 id="浮点数-1"><a href="#浮点数-1" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><p>IEEE 754表示</p>
<p>SME 为有效值, sfe 为实际存储中的值</p>
<p>V = (-1)^s^ * M * 2^E^</p>
<p>S sign 符号</p>
<p>M significand 尾数</p>
<p>E exponent 阶码</p>
<p>32 位 S 31 E 30-23 M 22-0</p>
<p>64 位 S 63 E 62-52 M 51-0</p>
<p><strong>分类</strong></p>
<ul>
<li><p>规格化 S = s, E = e - bias, M = f + 1</p>
<p>0&lt;e&lt;2^k^-1</p>
<p>bias = 2^k-1^-1</p>
<p>eg: 对于 32 位, E 的取值为 1-127 ~ 254-127</p>
<p>f+1 是因为有一个隐含的 1(implied leading 1)</p>
</li>
<li><p>非规格化 S = s, E = 1 - bias, M = f</p>
<p>e = 0</p>
<p>注意规格化数和非规格化数之间的平滑转换</p>
</li>
<li><p>特殊值</p>
<p>e = 2^k^-1</p>
<p>s=0 正无穷</p>
<p>s=1 负无穷</p>
<p>f != 0 NaN(not a number)</p>
<p>e =0 f = 0 0</p>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/40571490/answer/746043817?utm_source=qq&utm_medium=social&utm_oi=806118869101088768">CPU 的工作原理是什么 知乎</a></p>
<blockquote>
<p>马原网课</p>
</blockquote>
<!--more-->

<h1 id="马哲学在现代的意义"><a href="#马哲学在现代的意义" class="headerlink" title="马哲学在现代的意义"></a>马哲学在现代的意义</h1><p>对现代性的有原则高度的批判</p>
<h2 id="现代性"><a href="#现代性" class="headerlink" title="现代性"></a>现代性</h2><p>现代性是指现代世界的本质根据, 这种本质根据有两个基本支柱: 资本 现代形而上学</p>
<ul>
<li><p>资本和现代形而上学的关系:</p>
<p>资本是物质的动因, 是一种欲望, 它要求不断的增值, 不断的获利, 它使现代世界表现为进步和不断发展</p>
<p>现代形而上学使资本的这种欲望得到实现和满足, 因此现代的经济生活主要表现为科学的生产性应用</p>
</li>
</ul>
<h3 id="资本"><a href="#资本" class="headerlink" title="资本"></a>资本</h3><p>资本首先是集中起来的货币</p>
<p>资本基本特征: 增值, 获利, 产生超出自身价值以上的价值</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh18d442hvj31sq0q019m.jpg" alt="截屏2020-07-23 下午9.32.39"> 物物 w–w</p>
<p>使用价值 w–g–w</p>
<p>商业资本 <strong>g–w–g’,  g’=△g+g</strong></p>
<ul>
<li>进步强制(海德格尔)</li>
</ul>
<h3 id="现代形而上学"><a href="#现代形而上学" class="headerlink" title="现代形而上学"></a>现代形而上学</h3><p>是指现代哲学以及 以现代哲学 为基础的 现代科学和技术</p>
<h4 id="剩余"><a href="#剩余" class="headerlink" title="剩余"></a>剩余</h4><h5 id="绝对剩余价值"><a href="#绝对剩余价值" class="headerlink" title="绝对剩余价值"></a>绝对剩余价值</h5><p>绝对剩余指在必要劳动时间不变的条件下, 通过绝对延长工作日, 从而绝对延长剩余劳动时间生产出来的剩余价值(传统的, 不是现代的)</p>
<h5 id="相对剩余价值"><a href="#相对剩余价值" class="headerlink" title="相对剩余价值"></a>相对剩余价值</h5><p>相对剩余价值的增加不是由于创造出来的价值绝对的增加了, 而是通过缩短必要劳动时间, 把一部分原来的必要劳动时间转化为剩余劳动时间, 从而使剩余价值相对的增加(现代的, 提高生产率, 科学生产力的应用)</p>
<h2 id="有原则高度"><a href="#有原则高度" class="headerlink" title="有原则高度"></a>有原则高度</h2><blockquote>
<p>算法哈工大 mooc</p>
</blockquote>
<!--more-->

<h1 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1. 枚举"></a>1. 枚举</h1><h2 id="eg完美立方"><a href="#eg完美立方" class="headerlink" title="eg完美立方"></a>eg完美立方</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjmf40qbg0j30zw0k2tjo.jpg" alt="截屏2020-10-12 下午12.07.08" style="zoom:50%;" />

<p> 四层循环嵌套</p>
<h2 id="eg-生理周期"><a href="#eg-生理周期" class="headerlink" title="eg 生理周期"></a>eg 生理周期</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjmf8dcke3j311y0fwk53.jpg" alt="截屏2020-10-12 下午12.07.08" style="zoom:50%;" />

<p>d+1 到 21252</p>
<p>(k-p)%23 == 0 &amp;&amp; (k-e)%28 &amp;&amp; (k-i)%33 == 0</p>
<p><strong>跳着试</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 21252</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin&gt;&gt;p&gt;&gt;e&gt;&gt;i&gt;&gt;d &amp;&amp; p!=<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ++caseNo;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (k+d+<span class="number">1</span>; (k-p)%<span class="number">23</span>; ++k);</span><br><span class="line">    <span class="keyword">for</span> (; (k-e)%<span class="number">28</span>; k+=<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">for</span> (; (k-i)%<span class="number">33</span>; k+=<span class="number">23</span>*<span class="number">28</span>);</span><br><span class="line">    cout &lt;&lt; caseNo &lt;&lt; k-d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eg-称硬币"><a href="#eg-称硬币" class="headerlink" title="eg 称硬币"></a>eg 称硬币</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjmfiqxiwlj316g0b6n9g.jpg" alt="截屏2020-10-12 下午12.17.25"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> Left[<span class="number">3</span>][<span class="number">7</span>]; <span class="comment">//左天平</span></span><br><span class="line"><span class="keyword">char</span> Right[<span class="number">3</span>][<span class="number">7</span>]; <span class="comment">//右天平</span></span><br><span class="line"><span class="keyword">char</span> result[<span class="number">3</span>][<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFake</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">bool</span> light)</span></span>; <span class="comment">//假设是否正确</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">      cin&gt;&gt; Left[i]&gt;&gt;Right[i]&gt;&gt;result[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">&#x27;A&#x27;</span>; c&lt;=<span class="string">&quot;L&quot;</span>; c++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">IsFake</span>(c, <span class="literal">true</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot;light&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsFake</span>(c, <span class="literal">false</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot;heavy&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFake</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">bool</span> light)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i0; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> * pLeft, *pRight;</span><br><span class="line">    <span class="keyword">if</span>(light)</span><br><span class="line">    &#123;</span><br><span class="line">      pLeft = Left[i];</span><br><span class="line">      pRight = Right[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      pLeft = Right[i];</span><br><span class="line">      pRight = Left[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(result[i][<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strchr</span>(pRight, c) == null)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strchr</span>(pLeft, c)||<span class="built_in">strchr</span>(pRight, c))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strchr</span>(pLeft, c) == null)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eg-熄灯问题"><a href="#eg-熄灯问题" class="headerlink" title="eg 熄灯问题"></a>eg 熄灯问题</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjmoyhoig0j316c0k816x.jpg" alt="截屏2020-10-12 下午5.43.53"></p>
<p>给定一种初始状态, 求让灯全灭的方案</p>
<h1 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h1><h2 id="eg-求阶乘"><a href="#eg-求阶乘" class="headerlink" title="eg 求阶乘"></a>eg 求阶乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">f</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjrgyap57hj30me0l6agd.jpg" alt="截屏2020-10-16 下午8.54.49"></p>
<h2 id="eg-汉诺塔问题"><a href="#eg-汉诺塔问题" class="headerlink" title="eg 汉诺塔问题"></a>eg 汉诺塔问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> n, cha src, <span class="keyword">char</span> mid, <span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;src&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;dest&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Hanoi</span>(n<span class="number">-1</span>, src, dest, mid);</span><br><span class="line">  cout&lt;&lt;src&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;dest&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">Hanoi</span>(n<span class="number">-1</span>, mid, src, dest);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eg-n皇后问题"><a href="#eg-n皇后问题" class="headerlink" title="eg n皇后问题"></a>eg n皇后问题</h2><p>递归替代多重循环</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjrh7cu3tlj30z00kqk2b.jpg" alt="截屏2020-10-16 下午9.03.31"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">queePos[<span class="number">100</span>];</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">// 0 - k 行都已经摆好了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">if</span>(k == n)</span><br><span class="line">  &#123;<span class="comment">//输出方案</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">      cout&lt;&lt;queenPos[i]+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;k; j++)</span><br><span class="line">    	<span class="keyword">if</span>(queenPos[j]==i || <span class="built_in">abs</span>(queenPos[j]-i == <span class="built_in">abs</span>(k-j)))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(j==k)</span><br><span class="line">    &#123;</span><br><span class="line">      queenPos[k] = i;</span><br><span class="line">      <span class="built_in">NQueen</span>(k+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="eg-逆波兰表达式"><a href="#eg-逆波兰表达式" class="headerlink" title="eg 逆波兰表达式"></a>eg 逆波兰表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span>(s[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()+<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()-<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()*<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()/<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="built_in">atof</span>(s);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eg-表达式计算"><a href="#eg-表达式计算" class="headerlink" title="eg 表达式计算"></a>eg 表达式计算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor_value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Sinos_wei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2021/12/21/%E8%AF%BE%E7%A8%8B-%E6%80%BB/">https://sinos_wei.gitee.io/2021/12/21/%E8%AF%BE%E7%A8%8B-%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/icon.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/cpp/"><img class="prev-cover" src="/img/icon.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">cpp 从入门到汇编</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/06/%E9%9D%A2%E7%BB%8F/"><img class="next-cover" src="/img/icon.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos_wei</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">31</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MOOC"><span class="toc-number">1.</span> <span class="toc-text">MOOC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 计算机网络与因特网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 应用层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 运输层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.4.</span> <span class="toc-text">第四章 网络层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">1.5.</span> <span class="toc-text">第五章 链路层和局域网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-wifi"><span class="toc-number">1.6.</span> <span class="toc-text">第六章 wifi</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-1-socket-%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">实验 1 socket 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">实验要求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-2-rdt-%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">实验 2 rdt 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83"><span class="toc-number">3.2.</span> <span class="toc-text">模拟环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86"><span class="toc-number">3.3.</span> <span class="toc-text">知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GBN"><span class="toc-number">3.3.1.</span> <span class="toc-text">GBN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt"><span class="toc-number">3.3.2.</span> <span class="toc-text">rdt</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp-%E5%AE%9E%E9%AA%8Ctips"><span class="toc-number">4.</span> <span class="toc-text">cpp 实验tips</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">4.1.</span> <span class="toc-text">1.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E4%B8%AD%E7%9A%84-const-%E6%88%90%E5%91%98"><span class="toc-number">4.1.1.</span> <span class="toc-text">struct 中的 const 成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-struct"><span class="toc-number">4.1.2.</span> <span class="toc-text">初始化 struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B3%A8%E6%84%8F%E5%90%8E%E9%9D%A2%E6%98%AF%E4%B8%8D%E6%98%AF-0-if-%E6%A3%80%E9%AA%8C"><span class="toc-number">4.1.3.</span> <span class="toc-text">% &#x2F;  要注意后面是不是 0 if 检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E4%B8%8E-nullptr-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.4.</span> <span class="toc-text">null 与 nullptr 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete"><span class="toc-number">4.1.5.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E6%9C%89%E6%9C%AA%E7%BB%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%BC%82%E5%B8%B8-0xC0000005-%E8%AF%BB%E5%8F%96%E4%BD%8D%E7%BD%AE-0xcccccccc-%E6%97%B6%E5%8F%91%E7%94%9F%E8%AE%BF%E9%97%AE%E5%86%B2%E7%AA%81"><span class="toc-number">4.1.6.</span> <span class="toc-text">处有未经处理的异常: 0xC0000005: 读取位置 0xcccccccc 时发生访问冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2"><span class="toc-number">4.2.</span> <span class="toc-text">2.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#noexcept"><span class="toc-number">4.2.1.</span> <span class="toc-text">noexcept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-amp-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.3.</span> <span class="toc-text">&amp;&amp;运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invalid-address-specified-to-RtlValidateHea"><span class="toc-number">4.2.4.</span> <span class="toc-text">Invalid address specified to RtlValidateHea</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3"><span class="toc-number">4.3.</span> <span class="toc-text">3.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-move"><span class="toc-number">4.3.1.</span> <span class="toc-text">std::move()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4"><span class="toc-number">4.4.</span> <span class="toc-text">4.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">4.4.1.</span> <span class="toc-text">运算符重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp-%E8%AF%BE%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">cpp 课件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.2.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number">5.3.</span> <span class="toc-text">数据成员指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.4.</span> <span class="toc-text">类中的关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">5.4.1.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutable"><span class="toc-number">5.4.2.</span> <span class="toc-text">mutable:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PA%E6%8A%A5%E5%91%8A"><span class="toc-number">6.</span> <span class="toc-text">PA报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E7%9B%AE%E7%9A%84"><span class="toc-number">6.1.1.</span> <span class="toc-text">课程目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.1.2.</span> <span class="toc-text">课程任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">6.1.3.</span> <span class="toc-text">实验环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA1"><span class="toc-number">6.2.</span> <span class="toc-text">PA1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PA1-1-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="toc-number">6.2.1.</span> <span class="toc-text">PA1.1 基础设施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-1"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-1-2-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">6.2.2.</span> <span class="toc-text">PA 1.2 表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-2"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-1"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-1"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-1-3-%E7%9B%91%E8%A7%86%E7%82%B9"><span class="toc-number">6.2.3.</span> <span class="toc-text">PA 1.3 监视点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-3"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-2"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-2"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-1-%E9%97%AE%E7%AD%94"><span class="toc-number">6.2.4.</span> <span class="toc-text">PA 1 问答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA2"><span class="toc-number">6.3.</span> <span class="toc-text">PA2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-1-%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AA-C-%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.3.1.</span> <span class="toc-text">PA 2.1 运行第一个 C 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-4"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-3"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-3"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-2"><span class="toc-number">6.3.2.</span> <span class="toc-text">PA 2.2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-5"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-4"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-4"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-3"><span class="toc-number">6.3.3.</span> <span class="toc-text">PA 2.3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-6"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-5"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-5"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-%E9%97%AE%E7%AD%94"><span class="toc-number">6.3.4.</span> <span class="toc-text">PA 2 问答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA-3-%E8%87%AA%E9%99%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">PA 3 自陷操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-1"><span class="toc-number">6.4.1.</span> <span class="toc-text">PA 3.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-7"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-6"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-6"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.4.2.</span> <span class="toc-text">PA 3.2 系统调用与程序加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-8"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-7"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-7"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0"><span class="toc-number">6.4.3.</span> <span class="toc-text">PA 3.3 文件系统与仙剑奇侠传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-9"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-8"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-8"><span class="toc-number">6.4.3.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-%E9%97%AE%E7%AD%94"><span class="toc-number">6.4.4.</span> <span class="toc-text">PA 3 问答</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PA%E5%AE%9E%E9%AA%8C"><span class="toc-number">7.</span> <span class="toc-text">PA实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PA0"><span class="toc-number">7.1.</span> <span class="toc-text">PA0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA1-1"><span class="toc-number">7.2.</span> <span class="toc-text">PA1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA2-1"><span class="toc-number">7.3.</span> <span class="toc-text">PA2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA3"><span class="toc-number">7.4.</span> <span class="toc-text">PA3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA"><span class="toc-number">8.</span> <span class="toc-text">第一章 引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.1.</span> <span class="toc-text">编译程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">8.2.1.</span> <span class="toc-text">词法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">8.2.2.</span> <span class="toc-text">语法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">8.2.3.</span> <span class="toc-text">语义分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">8.2.4.</span> <span class="toc-text">中间代码生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.5.</span> <span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">8.2.6.</span> <span class="toc-text">目标代码生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">8.2.7.</span> <span class="toc-text">*符号表管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text">解释程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PL-O-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.4.</span> <span class="toc-text">PL&#x2F;O 语言编译系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%96%87%E6%B3%95%E4%B8%8E%E8%AF%AD%E8%A8%80"><span class="toc-number">9.</span> <span class="toc-text">第二章 文法与语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">文法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E4%B8%B2"><span class="toc-number">9.2.</span> <span class="toc-text">符号和符号串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">10.</span> <span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Amdahl-%E5%AE%9A%E5%BE%8B"><span class="toc-number">10.1.</span> <span class="toc-text">Amdahl 定律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E6%80%A7%E8%83%BD%E5%85%AC%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">CPU 性能公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">10.4.</span> <span class="toc-text">系统评价指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">10.5.</span> <span class="toc-text">系统结构的发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%99%A8%E4%BB%B6%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">10.6.</span> <span class="toc-text">器件对系统结构的影响</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">11.</span> <span class="toc-text">第三章 流水线技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">11.2.</span> <span class="toc-text">性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E7%8E%87TP"><span class="toc-number">11.2.1.</span> <span class="toc-text">吞吐率TP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E6%AF%94"><span class="toc-number">11.2.2.</span> <span class="toc-text">加速比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E7%8E%87-E"><span class="toc-number">11.2.3.</span> <span class="toc-text">效率(E)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%8A%9F%E8%83%BD%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">11.3.</span> <span class="toc-text">单功能非线性流水线的调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3"><span class="toc-number">11.4.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%B2%E7%AA%81"><span class="toc-number">11.5.</span> <span class="toc-text">流水线冲突</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C-ILP"><span class="toc-number">12.</span> <span class="toc-text">第五章 指令级并行(ILP)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6"><span class="toc-number">12.1.</span> <span class="toc-text">指令的动态调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">12.1.1.</span> <span class="toc-text">乱序执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">12.1.2.</span> <span class="toc-text">寄存器重命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">12.2.</span> <span class="toc-text">动态分支预测技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BHT-branch-history-table"><span class="toc-number">12.2.1.</span> <span class="toc-text">BHT branch history table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTB-branch-target-buffer"><span class="toc-number">12.2.2.</span> <span class="toc-text">BTB branch target buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%8C%87%E4%BB%A4%E6%B5%81%E5%87%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">12.3.</span> <span class="toc-text">多指令流出技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%A0%87%E9%87%8F"><span class="toc-number">12.3.1.</span> <span class="toc-text">超标量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97-VLIW"><span class="toc-number">12.3.2.</span> <span class="toc-text">超长指令字 VLIW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">12.3.3.</span> <span class="toc-text">超流水线</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.</span> <span class="toc-text">第七章 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cache"><span class="toc-number">13.1.</span> <span class="toc-text">cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%91%BD%E4%B8%AD"><span class="toc-number">13.1.1.</span> <span class="toc-text">三种类型的不命中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E4%B8%8D%E5%91%BD%E4%B8%AD-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8"><span class="toc-number">13.1.1.1.</span> <span class="toc-text">强制不命中: 第一次启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%E4%B8%8D%E5%91%BD%E4%B8%AD-%E5%AE%B9%E9%87%8F%E4%B8%8D%E8%B6%B3"><span class="toc-number">13.1.1.2.</span> <span class="toc-text">容量不命中: 容量不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E4%B8%8D%E5%91%BD%E4%B8%AD-%E5%86%B2%E7%AA%81"><span class="toc-number">13.1.1.3.</span> <span class="toc-text">冲突不命中: 冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E-cache-%E4%B8%8D%E5%91%BD%E4%B8%AD%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.1.2.</span> <span class="toc-text">降低 cache 不命中率的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0-cache-%E5%9D%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">13.1.2.1.</span> <span class="toc-text">增加 cache 块大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0-cache-%E5%AE%B9%E9%87%8F"><span class="toc-number">13.1.2.2.</span> <span class="toc-text">增加 cache 容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E7%9B%B8%E8%81%94%E5%BA%A6"><span class="toc-number">13.1.2.3.</span> <span class="toc-text">提高相联度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E7%9B%B8%E8%81%94-cache"><span class="toc-number">13.1.2.4.</span> <span class="toc-text">伪相联 cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E9%A2%84%E5%8F%96"><span class="toc-number">13.1.2.5.</span> <span class="toc-text">硬件预取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A2%84%E5%8F%96"><span class="toc-number">13.1.2.6.</span> <span class="toc-text">编译器控制的预取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96"><span class="toc-number">13.1.2.7.</span> <span class="toc-text">编译优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E7%89%BA%E7%89%B2%E2%80%9D-cache"><span class="toc-number">13.1.2.8.</span> <span class="toc-text">“牺牲” cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F%E4%B8%8D%E5%91%BD%E4%B8%AD%E5%BC%80%E9%94%80"><span class="toc-number">13.1.3.</span> <span class="toc-text">减小不命中开销</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E4%B8%A4%E7%BA%A7-cache"><span class="toc-number">13.1.3.1.</span> <span class="toc-text">采用两级 cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E4%B8%8D%E5%91%BD%E4%B8%AD%E4%BC%98%E5%85%88%E4%BA%8E%E5%86%99"><span class="toc-number">13.1.3.2.</span> <span class="toc-text">读不命中优先于写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E7%BC%93%E5%86%B2%E5%90%88%E5%B9%B6"><span class="toc-number">13.1.3.3.</span> <span class="toc-text">写缓冲合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-cache-%E6%8A%80%E6%9C%AF"><span class="toc-number">13.1.3.4.</span> <span class="toc-text">非阻塞 cache 技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F%E5%91%BD%E4%B8%AD%E6%97%B6%E9%97%B4"><span class="toc-number">13.1.4.</span> <span class="toc-text">减小命中时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-cache-%E5%B9%B6%E8%A1%8C-mmu"><span class="toc-number">13.1.4.1.</span> <span class="toc-text">虚拟 cache(并行 mmu)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">13.1.4.2.</span> <span class="toc-text">流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B8%AA%E8%BF%B9-cache"><span class="toc-number">13.1.4.3.</span> <span class="toc-text">踪迹 cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%BB%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.1.5.</span> <span class="toc-text">并行主存系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">13.1.6.</span> <span class="toc-text">虚拟存储器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-i-o-%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.</span> <span class="toc-text">第六章 i&#x2F;o 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7"><span class="toc-number">14.1.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">14.2.</span> <span class="toc-text">串并联系统可靠性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.2.1.</span> <span class="toc-text">串联系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.2.2.</span> <span class="toc-text">并联系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raid"><span class="toc-number">14.3.</span> <span class="toc-text">raid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C"><span class="toc-number">15.</span> <span class="toc-text">第七章 互联网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">15.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E8%BF%9E%E5%87%BD%E6%95%B0"><span class="toc-number">15.2.</span> <span class="toc-text">互连函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6"><span class="toc-number">15.3.</span> <span class="toc-text">时延</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%97%B6%E5%BB%B6"><span class="toc-number">15.3.1.</span> <span class="toc-text">通道时延</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%97%B6%E5%BB%B6"><span class="toc-number">15.3.2.</span> <span class="toc-text">网络时延</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C"><span class="toc-number">15.4.</span> <span class="toc-text">静态互联网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E7%BD%91%E7%BB%9C"><span class="toc-number">15.5.</span> <span class="toc-text">总线网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E5%BC%80%E5%85%B3%E7%BD%91%E7%BB%9C"><span class="toc-number">15.6.</span> <span class="toc-text">交叉开关网络</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">多处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cache-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">16.1.</span> <span class="toc-text">cache 的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%BC%8F%E5%8D%8F%E8%AE%AE"><span class="toc-number">16.1.1.</span> <span class="toc-text">监听式协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%BC%8F%E5%8D%8F%E8%AE%AE"><span class="toc-number">16.1.2.</span> <span class="toc-text">目录式协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BB%AA%E8%AE%BA"><span class="toc-number">17.</span> <span class="toc-text">1 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.1.</span> <span class="toc-text">模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.1.1.</span> <span class="toc-text">概念模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#er-%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.1.1.1.</span> <span class="toc-text">er 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-R%E5%9B%BE-entity-relationship-model"><span class="toc-number">17.1.1.2.</span> <span class="toc-text">E-R图 entity relationship model</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.1.2.</span> <span class="toc-text">逻辑模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.2.</span> <span class="toc-text">三级模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">18.</span> <span class="toc-text">2 关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-number">18.1.</span> <span class="toc-text">关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="toc-number">18.1.1.</span> <span class="toc-text">关系运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%CF%83%E9%80%89%E6%8B%A9"><span class="toc-number">18.1.1.1.</span> <span class="toc-text">σ选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%CF%80%E6%8A%95%E5%BD%B1"><span class="toc-number">18.1.1.2.</span> <span class="toc-text">π投影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%CE%B8%E8%BF%9E%E6%8E%A5"><span class="toc-number">18.1.1.3.</span> <span class="toc-text">θ连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%C3%B7%E9%99%A4%E6%B3%95"><span class="toc-number">18.1.1.4.</span> <span class="toc-text">÷除法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">18.2.</span> <span class="toc-text">完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">18.2.1.</span> <span class="toc-text">实体完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">18.2.2.</span> <span class="toc-text">参照完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">18.2.3.</span> <span class="toc-text">用户定义的完整性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-sql"><span class="toc-number">19.</span> <span class="toc-text">3 sql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#schema"><span class="toc-number">19.1.</span> <span class="toc-text">schema</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table"><span class="toc-number">19.2.</span> <span class="toc-text">table</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">19.2.1.</span> <span class="toc-text">约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">19.2.2.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">19.2.3.</span> <span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="toc-number">19.3.</span> <span class="toc-text">数据字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">19.4.</span> <span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"><span class="toc-number">20.</span> <span class="toc-text">6 关系数据理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">20.1.</span> <span class="toc-text">函数依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">20.2.</span> <span class="toc-text">函数依赖的公理系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">20.3.</span> <span class="toc-text">范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1NF"><span class="toc-number">20.3.1.</span> <span class="toc-text">1NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2NF"><span class="toc-number">20.3.2.</span> <span class="toc-text">2NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3NF"><span class="toc-number">20.3.3.</span> <span class="toc-text">3NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCNF"><span class="toc-number">20.3.4.</span> <span class="toc-text">BCNF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4NF"><span class="toc-number">20.3.5.</span> <span class="toc-text">4NF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3"><span class="toc-number">20.4.</span> <span class="toc-text">模式分解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">21.</span> <span class="toc-text">9 关系查询和查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E7%AE%97%E6%B3%95"><span class="toc-number">21.1.</span> <span class="toc-text">查询操作算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">21.1.1.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">21.1.2.</span> <span class="toc-text">连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D"><span class="toc-number">22.</span> <span class="toc-text">10 数据库恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">22.1.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-number">22.2.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">23.</span> <span class="toc-text">11 并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">23.1.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">23.1.1.</span> <span class="toc-text">1 级封锁协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">23.1.2.</span> <span class="toc-text">2 级封锁协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">23.1.3.</span> <span class="toc-text">3 级封锁协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A"><span class="toc-number">24.</span> <span class="toc-text">sql 必知必会</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#primary-key"><span class="toc-number">24.1.</span> <span class="toc-text">primary key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORDER-BY"><span class="toc-number">24.2.</span> <span class="toc-text">ORDER BY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WHERE"><span class="toc-number">24.3.</span> <span class="toc-text">WHERE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LIKE%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">24.3.1.</span> <span class="toc-text">LIKE与通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="toc-number">24.4.</span> <span class="toc-text">计算字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">24.5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">24.5.1.</span> <span class="toc-text">聚集函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GROUP-BY"><span class="toc-number">24.6.</span> <span class="toc-text">GROUP BY</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HAVING"><span class="toc-number">24.6.1.</span> <span class="toc-text">HAVING</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JOIN"><span class="toc-number">24.7.</span> <span class="toc-text">JOIN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INNER-JOIN-ON"><span class="toc-number">24.7.1.</span> <span class="toc-text">INNER JOIN ON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OUTER-JOIN-ON"><span class="toc-number">24.7.2.</span> <span class="toc-text">OUTER JOIN ON</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">25.</span> <span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0"><span class="toc-number">25.1.</span> <span class="toc-text">第一章 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">25.1.1.</span> <span class="toc-text">1.1 计算机基本工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-number">25.1.2.</span> <span class="toc-text">1.2 程序的开发与运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">25.1.3.</span> <span class="toc-text">1.3 计算机系统的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-Application-Program-Interface"><span class="toc-number">25.1.3.1.</span> <span class="toc-text">API: Application Program Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ABI-Application-Binary-Interface"><span class="toc-number">25.1.3.2.</span> <span class="toc-text">ABI: Application Binary Interface</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7"><span class="toc-number">25.1.4.</span> <span class="toc-text">1.4 计算机系统性能评价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">25.2.</span> <span class="toc-text">第二章 数据的机器级表示与处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">25.2.1.</span> <span class="toc-text">2.1 数制与编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">25.2.2.</span> <span class="toc-text">2.2 整数的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">25.2.3.</span> <span class="toc-text">2.3 浮点数的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">25.2.4.</span> <span class="toc-text">2.4 十进制数的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%9D%9E%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">25.2.5.</span> <span class="toc-text">2.5 非数值数据的编码表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="toc-number">25.2.6.</span> <span class="toc-text">2.6 数据的宽度与存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-number">25.2.7.</span> <span class="toc-text">2.7 数据的基本运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">25.3.</span> <span class="toc-text">第三章 程序的转换及机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E6%A6%82%E8%BF%B0"><span class="toc-number">25.3.1.</span> <span class="toc-text">3.1 程序转换概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-IA-32-intel-architecture-32-bit-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">25.3.2.</span> <span class="toc-text">3.2 IA-32 (intel architecture 32-bit)指令系统概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-IA-32-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">25.3.3.</span> <span class="toc-text">3.3 IA-32 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-c-%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">25.3.4.</span> <span class="toc-text">3.4 c 语言程序的机器级表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-number">25.3.5.</span> <span class="toc-text">3.5 复杂数据类型的分配和访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">25.3.6.</span> <span class="toc-text">3.6 越界访问 缓冲区溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">25.4.</span> <span class="toc-text">第一次实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#msb-%E4%B8%8E-lsb"><span class="toc-number">25.4.1.</span> <span class="toc-text">msb 与 lsb</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E7%AB%AF-%E5%B0%8F%E7%AB%AF"><span class="toc-number">25.4.1.1.</span> <span class="toc-text">大端 小端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">25.4.2.</span> <span class="toc-text">浮点数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C"><span class="toc-number">26.</span> <span class="toc-text">计算机组成原理实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-1-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">26.1.</span> <span class="toc-text">实验 1 数据表示实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E5%AE%9E%E9%AA%8C"><span class="toc-number">26.1.1.</span> <span class="toc-text">汉字编码实验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-2"><span class="toc-number">26.2.</span> <span class="toc-text">实验 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-4"><span class="toc-number">26.3.</span> <span class="toc-text">实验 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">26.3.1.</span> <span class="toc-text">中断处理机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mooc"><span class="toc-number">27.</span> <span class="toc-text">mooc</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA"><span class="toc-number">27.1.</span> <span class="toc-text">1. 计算机系统概论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">27.2.</span> <span class="toc-text">2. 数据表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">27.3.</span> <span class="toc-text">3. 运算方法与运算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">27.4.</span> <span class="toc-text">4. 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">27.4.1.</span> <span class="toc-text">存储系统的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87"><span class="toc-number">27.4.2.</span> <span class="toc-text">主存中的数据组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">27.4.3.</span> <span class="toc-text">静态存储器的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">27.4.4.</span> <span class="toc-text">动态存储器的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%89%A9%E5%B1%95"><span class="toc-number">27.4.5.</span> <span class="toc-text">存储扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BD%93%E4%BA%A4%E5%8F%89%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">27.4.6.</span> <span class="toc-text">多体交叉存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">27.4.7.</span> <span class="toc-text">cache 基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E8%81%94%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">27.4.8.</span> <span class="toc-text">相联存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%92%8C%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">27.4.9.</span> <span class="toc-text">cache 地址映射和变换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-number">27.4.10.</span> <span class="toc-text">替换算法(淘汰算法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%E4%BE%8B%E9%A2%98"><span class="toc-number">27.4.11.</span> <span class="toc-text">高速缓冲存储器例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8-1"><span class="toc-number">27.4.12.</span> <span class="toc-text">虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB-translation-lookaside-buffer"><span class="toc-number">27.4.13.</span> <span class="toc-text">TLB(translation lookaside buffer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-redundant-arrays-of-inexpensive-disks-gt"><span class="toc-number">27.4.14.</span> <span class="toc-text">RAID(redundant arrays of inexpensive disks-&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redundant-arrays-of-independent-disks"><span class="toc-number">27.4.15.</span> <span class="toc-text">redundant arrays of independent disks)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">27.5.</span> <span class="toc-text">5. 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%92%8C%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">27.5.1.</span> <span class="toc-text">指令系统概述和指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">27.5.2.</span> <span class="toc-text">寻址方式 指令寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="toc-number">27.5.3.</span> <span class="toc-text">操作数寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">27.5.4.</span> <span class="toc-text">指令格式设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIPS-32-%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0"><span class="toc-number">27.5.5.</span> <span class="toc-text">MIPS(32) 指令概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">27.5.5.1.</span> <span class="toc-text">指令格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">27.5.5.2.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">27.5.5.3.</span> <span class="toc-text">指令详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-cpu"><span class="toc-number">27.6.</span> <span class="toc-text">6. cpu</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">28.</span> <span class="toc-text">深入理解计算机系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8"><span class="toc-number">28.1.</span> <span class="toc-text">第一章 计算机系统漫游</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%A2%AB%E7%BF%BB%E8%AF%91%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">28.1.1.</span> <span class="toc-text">程序被翻译为不同的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6"><span class="toc-number">28.1.2.</span> <span class="toc-text">系统硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">28.1.2.1.</span> <span class="toc-text">总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E8%AE%BE%E5%A4%87"><span class="toc-number">28.1.2.2.</span> <span class="toc-text">io 设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98"><span class="toc-number">28.1.2.3.</span> <span class="toc-text">主存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8-CPU"><span class="toc-number">28.1.2.4.</span> <span class="toc-text">处理器 CPU</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">28.1.3.</span> <span class="toc-text">存储设备形成层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6"><span class="toc-number">28.1.4.</span> <span class="toc-text">操作系统管理硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">28.1.4.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">28.1.4.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">28.1.4.3.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">28.1.4.4.</span> <span class="toc-text">文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E4%B8%BB%E9%A2%98"><span class="toc-number">28.1.5.</span> <span class="toc-text">重要主题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">28.1.5.1.</span> <span class="toc-text">并发和并行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%B9%B6%E5%8F%91"><span class="toc-number">28.1.5.1.1.</span> <span class="toc-text">线程级并发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C"><span class="toc-number">28.1.5.1.2.</span> <span class="toc-text">指令级并行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%8C%87%E4%BB%A4-%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C"><span class="toc-number">28.1.5.1.3.</span> <span class="toc-text">单指令, 多数据并行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">28.1.5.2.</span> <span class="toc-text">抽象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">28.2.</span> <span class="toc-text">第二章 信息的表示和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">28.2.1.</span> <span class="toc-text">信息存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">28.2.2.</span> <span class="toc-text">整数运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0-1"><span class="toc-number">28.2.3.</span> <span class="toc-text">浮点数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%AC%E5%93%B2%E5%AD%A6%E5%9C%A8%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">29.</span> <span class="toc-text">马哲学在现代的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%80%A7"><span class="toc-number">29.1.</span> <span class="toc-text">现代性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%9C%AC"><span class="toc-number">29.1.1.</span> <span class="toc-text">资本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6"><span class="toc-number">29.1.2.</span> <span class="toc-text">现代形而上学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%A9%E4%BD%99"><span class="toc-number">29.1.2.1.</span> <span class="toc-text">剩余</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%89%A9%E4%BD%99%E4%BB%B7%E5%80%BC"><span class="toc-number">29.1.2.1.1.</span> <span class="toc-text">绝对剩余价值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%89%A9%E4%BD%99%E4%BB%B7%E5%80%BC"><span class="toc-number">29.1.2.1.2.</span> <span class="toc-text">相对剩余价值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%8E%9F%E5%88%99%E9%AB%98%E5%BA%A6"><span class="toc-number">29.2.</span> <span class="toc-text">有原则高度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%9E%9A%E4%B8%BE"><span class="toc-number">30.</span> <span class="toc-text">1. 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#eg%E5%AE%8C%E7%BE%8E%E7%AB%8B%E6%96%B9"><span class="toc-number">30.1.</span> <span class="toc-text">eg完美立方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-%E7%94%9F%E7%90%86%E5%91%A8%E6%9C%9F"><span class="toc-number">30.2.</span> <span class="toc-text">eg 生理周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-%E7%A7%B0%E7%A1%AC%E5%B8%81"><span class="toc-number">30.3.</span> <span class="toc-text">eg 称硬币</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-%E7%86%84%E7%81%AF%E9%97%AE%E9%A2%98"><span class="toc-number">30.4.</span> <span class="toc-text">eg 熄灯问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92"><span class="toc-number">31.</span> <span class="toc-text">2. 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-%E6%B1%82%E9%98%B6%E4%B9%98"><span class="toc-number">31.1.</span> <span class="toc-text">eg 求阶乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">31.2.</span> <span class="toc-text">eg 汉诺塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">31.3.</span> <span class="toc-text">eg n皇后问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">31.4.</span> <span class="toc-text">eg 逆波兰表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eg-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">31.5.</span> <span class="toc-text">eg 表达式计算</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/28/ShellScript/" title="ShellScript"><img src="/img/icon.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ShellScript"/></a><div class="content"><a class="title" href="/2022/06/28/ShellScript/" title="ShellScript">ShellScript</a><time datetime="2022-06-28T11:22:05.000Z" title="Created 2022-06-28 19:22:05">2022-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/27/%E7%BD%97%E7%BF%94%E8%AF%B4%E5%88%91%E6%B3%95/" title="罗翔说刑法"><img src="/img/icon.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="罗翔说刑法"/></a><div class="content"><a class="title" href="/2022/06/27/%E7%BD%97%E7%BF%94%E8%AF%B4%E5%88%91%E6%B3%95/" title="罗翔说刑法">罗翔说刑法</a><time datetime="2022-06-27T12:41:46.000Z" title="Created 2022-06-27 20:41:46">2022-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/04/OS3pieces%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="OS3pieces读书笔记"><img src="/img/icon.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS3pieces读书笔记"/></a><div class="content"><a class="title" href="/2022/06/04/OS3pieces%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="OS3pieces读书笔记">OS3pieces读书笔记</a><time datetime="2022-06-04T08:47:16.000Z" title="Created 2022-06-04 16:47:16">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src="/img/icon.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2022/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2022-05-09T11:32:45.000Z" title="Created 2022-05-09 19:32:45">2022-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%86%E5%8F%B2/" title="操作系统历史"><img src="/img/icon.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统历史"/></a><div class="content"><a class="title" href="/2022/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%86%E5%8F%B2/" title="操作系统历史">操作系统历史</a><time datetime="2022-05-05T00:35:13.000Z" title="Created 2022-05-05 08:35:13">2022-05-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Sinos_wei</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Local search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>