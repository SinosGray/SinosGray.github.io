
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>pa - Sinos_wei&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="



报告概述课程目的理解”程序如何在计算机上运行”的根本途径是从”零”开始实现一个完整的计算机系统. 指导学生实现一个经过简化但功能完备的x86/mips32/riscv32模拟器NEMU(NJ,"> 
    <meta name="author" content="Sinos_wei"> 
    <link rel="alternative" href="atom.xml" title="Sinos_wei&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/a33.jpg"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sinos_wei&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://sinos_wei.gitee.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">pa</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">pa</h1>
        <div class="stuff">
            <span>十二月 28, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/pa/" rel="tag">pa</a></li></ul>


        </div>
        <div class="content markdown">
            <blockquote>
</blockquote>
<span id="more"></span>

<h1 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="课程目的"><a href="#课程目的" class="headerlink" title="课程目的"></a>课程目的</h3><p>理解”程序如何在计算机上运行”的根本途径是从”零”开始实现一个完整的计算机系统. 指导学生实现一个经过简化但功能完备的x86/mips32/riscv32模拟器NEMU(NJU EMUlator), 最终在NEMU上运行游戏”仙剑奇侠传”, 让学生探究”程序在计算机上运行”的基本原理. </p>
<h3 id="课程任务"><a href="#课程任务" class="headerlink" title="课程任务"></a>课程任务</h3><p>PA包括一个准备实验(配置实验环境)以及5部分连贯的实验内容:</p>
<ul>
<li>图灵机与简易调试器</li>
<li>冯诺依曼计算机系统</li>
<li>批处理系统</li>
<li>分时多任务</li>
<li>程序性能优化</li>
</ul>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>CPU架构: x64</li>
<li>操作系统: GNU/Linux</li>
<li>编译器: GCC</li>
<li>编程语言: C语言</li>
</ul>
<h2 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h2><h3 id="PA1-1-基础设施"><a href="#PA1-1-基础设施" class="headerlink" title="PA1.1 基础设施"></a>PA1.1 基础设施</h3><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><p>熟悉 nemu 框架, 实现单步执行, 打印寄存器, 扫描内存三种基本指令</p>
<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件: </p>
<p>nemu/src/monitor/debug/ui.c</p>
<p>nemu/src/isa/riscv32/reg.c </p>
</li>
<li><p>具体实现</p>
<p>新增三个指令 cmd_si, cmd_info, cmd_x, 分别对应单步执行, 打印寄存器, 扫描内存. </p>
<p>单步执行主要是通过 cpu_exec API 实现, 通过控制单步执行的指令数量实现调试步幅.</p>
<p>打印寄存器主要是通过 isa_reg_display API 实现, 当收到 “r” 参数时打印所有寄存器状态.</p>
<p>扫描内存主要是通过访问虚拟内存实现, 首先分离出内存位置和需要打印的空间大小, 然后通过 vaddr_read 接口读取内存内容并打印.</p>
</li>
</ol>
<h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><ol>
<li><p>help 指令测试, 如图 1-1 所示新增了si, info, x 三种指令.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6c6ttu64j30ko0gan1c.jpg" alt="截屏2022-01-08 下午2.33.41"></p>
<center style="font-size:14px;text-decoration:underline">图 1-1 help 指令测试</center> </li>
<li><p>si 指令测试, 无参数 si 指令测试如图 1-2 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6cdi7gfwj30l8068my1.jpg" alt="截屏2022-01-08 下午2.34.10"></p>
<center style="font-size:14px;text-decoration:underline">图 1-2 无参数 si 指令测试</center> 

<p>有参数 si 指令测试如图 1-3 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6ces9zocj30hg02et8u.jpg" alt="截屏2022-01-08 下午2.34.34"></p>
</li>
<li><p>info r 指令测试如图 1-4 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6cfdxdfkj30kg0h8ac1.jpg" alt="截屏2022-01-08 下午2.38.34"></p>
<p>​    </p>
</li>
</ol>
<h3 id="PA-1-2-表达式求值"><a href="#PA-1-2-表达式求值" class="headerlink" title="PA 1.2 表达式求值"></a>PA 1.2 表达式求值</h3><h4 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h4><p>实现 p 表达式求值指令.</p>
<h4 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件: </p>
<p>nemu/src/monitor/debug/ui.c, nemu/src/monitor/debug/expr.c</p>
</li>
<li><p>具体实现: </p>
<p>首先要对 token 进行正确的识别, 具体为实现 rule 数组并使用正则表达式提取 token.</p>
<p>之后将表达式求值拆分为符号优先级判断, 括号判断, 求值等几个部分分别实现. 最后的表达式计算接口由 p 指令调用.</p>
</li>
</ol>
<h4 id="实验测试-1"><a href="#实验测试-1" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 1-5 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6cvosla9j30ki0aqtar.jpg" alt="截屏2022-01-08 下午3.18.52 1"></p>
<h3 id="PA-1-3-监视点"><a href="#PA-1-3-监视点" class="headerlink" title="PA 1.3 监视点"></a>PA 1.3 监视点</h3><h4 id="实验要求-2"><a href="#实验要求-2" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>使用完善监视点池.</li>
<li>实现 w, d, info w 指令</li>
</ul>
<h4 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件:  </p>
<p>nemu/src/monitor/debug/ui.c,  nemu/src/monitor/debug/watchpoint.c,  nemu/include/monitor/watchpoint.h</p>
</li>
<li><p>具体设计:</p>
<p>首先完善监视点结构, 增加符号的名称和值两个字段. </p>
<p>之后实现监视点池的 new_wp, free_wp, print_wp 接口, 分别代表新建监视点, 释放监视点, 打印监视点. </p>
<p>然后实现 w, d 指令, 分别代表创建监视点和删除监视点, 分别调用 new_wp 和 free_wp 接口, 最后实现 info w 指令, 调用 print_wp 接口打印监视点内容.</p>
</li>
</ol>
<h4 id="实验测试-2"><a href="#实验测试-2" class="headerlink" title="实验测试"></a>实验测试</h4><p>监视点测试如图 1-6 所示.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6d3r3k9tj30kk096dh8.jpg" alt="截屏2022-01-08 下午3.45.30"></p>
<h3 id="PA-1-问答"><a href="#PA-1-问答" class="headerlink" title="PA 1 问答"></a>PA 1 问答</h3><p>你需要在实验报告中回答下列问题:</p>
<ul>
<li><p>送分题 我选择的ISA是 <em><strong>riscv32</strong></em> .</p>
</li>
<li><p>理解基础设施 我们通过一些简单的计算来体会简易调试器的作用. 首先作以下假设:</p>
<ul>
<li>假设你需要编译500次NEMU才能完成PA.</li>
<li>假设这500次编译当中, 有90%的次数是用于调试.</li>
<li>假设你没有实现简易调试器, 只能通过GDB对运行在NEMU上的客户程序进行调试. 在每一次调试中, 由于GDB不能直接观测客户程序, 你需要花费30秒的时间来从GDB中获取并分析一个信息.</li>
<li>假设你需要获取并分析20个信息才能排除一个bug.</li>
</ul>
<p>那么这个学期下来, 你将会在调试上花费多少时间?</p>
<p><em><strong>500 * 0.9 * 30 * 20 = 270000s</strong></em></p>
<p>由于简易调试器可以直接观测客户程序, 假设通过简易调试器只需要花费10秒的时间从中获取并分析相同的信息. 那么这个学期下来, 简易调试器可以帮助你节省多少调试的时间?</p>
<p><em><strong>500 * 0.9 * 20 * (30-10) = 180000s</strong></em></p>
<p>事实上, 这些数字也许还是有点乐观, 例如就算使用GDB来直接调试客户程序, 这些数字假设你能通过10分钟的时间排除一个bug. 如果实际上你需要在调试过程中获取并分析更多的信息, 简易调试器这一基础设施能带来的好处就更大.</p>
</li>
<li><p>查阅手册</p>
<p>理解了科学查阅手册的方法之后, 请你尝试在你选择的ISA手册中查阅以下问题所在的位置, 把需要阅读的范围写到你的实验报告里面:</p>
<ul>
<li><p>riscv32</p>
<ul>
<li><p>riscv32有哪几种指令格式?</p>
<p><em><strong>R, I, S, B, U, J</strong></em></p>
</li>
<li><p>LUI指令的行为是什么?</p>
<p><em><strong>将 20 位常量加载到寄存器的高 20 位.</strong></em></p>
</li>
<li><p>mstatus寄存器的结构是怎么样的?</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6ddrpfhoj30wc0bw0vb.jpg" alt="截屏2022-01-08 下午5.00.13"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>shell命令 完成PA1的内容之后, <code>nemu/</code>目录下的所有.c和.h和文件总共有多少行代码? 你是使用什么命令得到这个结果的? 和框架代码相比, 你在PA1中编写了多少行代码? (Hint: 目前<code>pa1</code>分支中记录的正好是做PA1之前的状态, 思考一下应该如何回到”过去”?) 你可以把这条命令写入<code>Makefile</code>中, 随着实验进度的推进, 你可以很方便地统计工程的代码行数, 例如敲入<code>make count</code>就会自动运行统计代码行数的命令. 再来个难一点的, 除去空行之外, <code>nemu/</code>目录下的所有<code>.c</code>和<code>.h</code>文件总共有多少行代码?</p>
<p><em><strong>使用 <code>find . -name &quot;*[.h|.c]&quot; |xargs cat|wc -l </code>命令, 5392 行</strong></em></p>
<p><em><strong>使用<code>find . -name &quot;*[.h|.c]&quot; | xargs cat|grep -v ^$ |wc -l  </code>命令, 4410 行</strong></em></p>
</li>
<li><p>使用man 打开工程目录下的<code>Makefile</code>文件, 你会在<code>CFLAGS</code>变量中看到gcc的一些编译选项. 请解释gcc中的<code>-Wall</code>和<code>-Werror</code>有什么作用? 为什么要使用<code>-Wall</code>和<code>-Werror</code>?</p>
<p><em><strong>-Wall 的作用是打开 gcc 所有警告。</strong></em></p>
<p><em><strong>-Werror 的作用是要求 gcc 将所有警告当成错误处理。</strong></em></p>
</li>
</ul>
<h2 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h2><h3 id="PA-2-1-运行第一个-C-程序"><a href="#PA-2-1-运行第一个-C-程序" class="headerlink" title="PA 2.1 运行第一个 C 程序"></a>PA 2.1 运行第一个 C 程序</h3><h4 id="实验要求-3"><a href="#实验要求-3" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>准备交叉编译环境</li>
<li>完成部分指令, 运行 dummy 程序</li>
</ul>
<h4 id="实验过程-3"><a href="#实验过程-3" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件: </p>
<p>nemu/src/isa/riscv32/</p>
</li>
<li><p>首先运行 dummy 程序, 根据 build 目录下的 dummy-riscv32-nemu.txt 反汇编文件找到需要实现的指令, 其中有部分伪指令如 ret 是由其他指令实现的, 最终确定需要实现的指令有 auipc, addi, jal, jalr.</p>
<p>在 all-instr.h 文件中定义执行函数, 在 opcode_table 添加新指令, 在 decode.c 和 control.c 中实现执行辅助函数.</p>
</li>
</ol>
<h4 id="实验测试-3"><a href="#实验测试-3" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 2.1 所示, dummy 正常运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r4m0pkhj30km0d0tbx.jpg" alt="截屏2022-01-09 下午3.33.12"></p>
<h3 id="PA-2-2"><a href="#PA-2-2" class="headerlink" title="PA 2.2"></a>PA 2.2</h3><h4 id="实验要求-4"><a href="#实验要求-4" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>运行 string test</li>
<li>运行 hello-str test</li>
<li>进行 run-all 测试</li>
</ul>
<h4 id="实验过程-4"><a href="#实验过程-4" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件</p>
<p>nemu/src/isa/riscv32/</p>
<p>nexus-am/libs/klib/src/stdio.c</p>
<p>nexus-am/libs/klib/src/string.c</p>
</li>
<li><p>同 PA 2.1, 依照反汇编文件找出所有需要实现的指令, 依次注册实现.<br>stdio.c 中的输出函数和 string.c 中的字符串处理函数需要参考手册中的说明进行实现, 同时要考虑多种异常情况下输出情况是否与手册中描述的一致.</p>
<p>最后进行一键回归测试.</p>
</li>
</ol>
<h4 id="实验测试-4"><a href="#实验测试-4" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 2.2 所示, string test 成功运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r5u1hckj30ku0aemzt.jpg" alt="截屏2022-01-09 下午8.58.23"></p>
<p>如图 2.3 所示, hello-str test 成功运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r5xsb06j30kq0bmjuf.jpg" alt="截屏2022-01-09 下午8.58.50"></p>
<p>如图 2.4 所示, 回归测试全部通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8r6jon69j30l60jitb2.jpg" alt="截屏2022-01-09 下午9.16.44"></p>
<h3 id="PA-2-3"><a href="#PA-2-3" class="headerlink" title="PA 2.3"></a>PA 2.3</h3><h4 id="实验要求-5"><a href="#实验要求-5" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现串口, 时钟, 键盘, VGA四种 I/O 设备程序.</li>
<li>分别测试时钟, 键盘, VGA 功能.</li>
<li>运行 slide 程序和 typing 打字游戏.</li>
<li>microbench 跑分.</li>
</ul>
<h4 id="实验过程-5"><a href="#实验过程-5" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>涉及文件:</p>
<p>nexus-am/am/src/nemu-common/</p>
</li>
<li><p>分别在 nemu-timer.c, nemu-input.c, nemu-video.c 中实现时钟, 键盘, VGA 的功能. </p>
<p>在运行 typing 时出现了 assert 错误, 显示 draw.c 51 行<code>assert(x + j &lt; W &amp;&amp; y + i &lt; H);</code>断言错误, 但是之前的 VGA 测试结果正确, 所以初步判断是 PA2.1 或者 PA2.2 中实现的指令有问题, 调试过程发现 x 的值会等于 W, 于是寻找 x 的来源, 确定是<code>draw_string(hit, W - strlen(hit) * 8, 0, 0x00ff00);</code> 的<code>W - strlen(hit)</code>, 发现 <code>strlen(hit)</code>的大小为 0, 然而 <code>hit</code> 的值为 0 是没有问题的, 于是想到问题可能出在自己实现的<code>strlen</code>, 最后发现是返回了 0 而不是字符串的大小. 修改后解决.</p>
</li>
</ol>
<h4 id="实验测试-5"><a href="#实验测试-5" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 2.5 所示, 时间测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8rud7gtrj30km0da0vo.jpg" alt="截屏2022-01-10 下午4.49.26"></p>
<p>如图 2.6 所示, 键盘测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8rudmwwwj30ka0dc0uu.jpg" alt="截屏2022-01-10 下午4.49.45"></p>
<p>如图 2.7 所示, VGA测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8rue6kr4j30m40hstb3.jpg" alt="截屏2022-01-10 下午4.11.33"></p>
<p>如图 2.8 所示, slide 程序测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8ruccbp9j30mm0hk0un.jpg" alt="截屏2022-01-10 下午5.23.29"></p>
<p>如图 2.9 所示, typing 游戏测试通过.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8ruersqyj30my0iajry.jpg" alt="截屏2022-01-10 下午6.15.31"></p>
<p>如图 2.10 所示, microbench 分数为 683.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8s2y2hbwj30h40c2jtu.jpg" alt="截屏2022-01-10 下午6.59.59"></p>
<h3 id="PA-2-问答"><a href="#PA-2-问答" class="headerlink" title="PA 2 问答"></a>PA 2 问答</h3><ul>
<li><p>RTFSC 请整理一条指令在NEMU中的执行过程. (我们其实已经在PA2.1阶段提到过这道题了)</p>
<p><em><strong>首先通过 instr_fetch 取指令, 根据 opcode_table 查找指令对应的译码辅助函数和执行辅助函数, 将译码信息保存在 decinfo, 执行指令, 最后通过 update_pc 更新 PC 值.</strong></em></p>
</li>
<li><p>编译与链接 在<code>nemu/include/rtl/rtl.h</code>中, 你会看到由<code>static inline</code>开头定义的各种RTL指令函数. 选择其中一个函数, 分别尝试去掉<code>static</code>, 去掉<code>inline</code>或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生/不发生? 你有办法证明你的想法吗?</p>
<p><em><strong>static 和 inline 同时去掉时会报错, 重复定义, static 存在时函数作用域仅限本文件, inline 存在时函数在预编译就会展开, 都不会重复定义.</strong></em></p>
</li>
<li><p>编译与链接</p>
<ol>
<li><p>在<code>nemu/include/common.h</code>中添加一行<code>volatile static int dummy;</code> 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个<code>dummy</code>变量的实体? 你是如何得到这个结果的?</p>
<p><em><strong>使用 grep 命令, 81 个</strong></em></p>
</li>
<li><p>添加上题中的代码后, 再在<code>nemu/include/debug.h</code>中添加一行<code>volatile static int dummy;</code> 然后重新编译NEMU. 请问此时的NEMU含有多少个<code>dummy</code>变量的实体? 与上题中<code>dummy</code>变量实体数目进行比较, 并解释本题的结果.</p>
<p><em><strong>使用 grep 命令, 82 个</strong></em></p>
</li>
<li><p>修改添加的代码, 为两处<code>dummy</code>变量进行初始化:<code>volatile static int dummy = 0;</code> 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)</p>
<p><em><strong>编译报错, 两个强符号冲突</strong></em></p>
</li>
</ol>
</li>
<li><p>了解Makefile</p>
<p>请描述你在<code>nemu/</code>目录下敲入<code>make</code>后, <code>make</code>程序如何组织.c和.h文件, 最终生成可执行文件<code>nemu/build/$ISA-nemu</code>. (这个问题包括两个方面: <code>Makefile</code>的工作方式和编译链接的过程.) 关于<code>Makefile</code>工作方式的提示:</p>
<ul>
<li><code>Makefile</code>中使用了变量, 包含文件等特性</li>
<li><code>Makefile</code>运用并重写了一些implicit rules</li>
<li>在<code>man make</code>中搜索<code>-n</code>选项, 也许会对你有帮助</li>
<li>RTFM</li>
</ul>
<p>敲入 make 后, 会将 makefile 文件中第一个目标文件作为最终的目标文件,  如果文件不存在, 就会重新编译; 如果目标文件依赖的.o 文件也不存在, 就根据这个.o 文件的生成规则生成, 然后生成上一层.o 文件, 中间某一步出错就会直接报错.</p>
</li>
</ul>
<h2 id="PA-3-自陷操作"><a href="#PA-3-自陷操作" class="headerlink" title="PA 3 自陷操作"></a>PA 3 自陷操作</h2><h3 id="PA-3-1"><a href="#PA-3-1" class="headerlink" title="PA 3.1"></a>PA 3.1</h3><h4 id="实验要求-6"><a href="#实验要求-6" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现自陷操作.</li>
<li>重新组织<code>_Context</code>结构体的成员.</li>
<li>在<code>__am_irq_handle()</code>中通过异常号识别出自陷异常, 并打包成编号为<code>_EVENT_YIELD</code>的自陷事件.</li>
<li>在<code>do_event()</code>中识别出自陷事件<code>_EVENT_YIELD</code>, 然后输出一句话即可.</li>
</ul>
<h4 id="实验过程-6"><a href="#实验过程-6" class="headerlink" title="实验过程"></a>实验过程</h4><p>涉及文件:</p>
<p>nemu/src/isa/riscv32/intr.c</p>
<p>nanos-lite/src/irq.c</p>
<p>nexus-am/am/src/riscv32/nemu/cte.c</p>
<p>nexus-am/am/include/arch/riscv32-nemu.h</p>
<p>nemu/src/isa/riscv32/exec/system.c</p>
<p>具体过程:</p>
<p>首先在 nemu/src/isa/riscv32/exec/system.c 文件中实现新增的指令 csrrs, csrrw, ecall, sret. 在 nemu/src/isa/riscv32/intr.c 文件中编写 raise_intr, 将当前的 PC 存入 sepc 寄存器, 在 scause 寄存器中保存异常号, 跳转到异常入口地址. </p>
<p>之后重新组织_Context 结构体, 根据 trap.s 重新给结构体成员排序.</p>
<p>最后在 nexus-am/am/src/riscv32/nemu/cte.c 文件中的 __am_irq_handle 函数中实现事件的分发和打包, 在 nanos-lite/src/irq.c 文件的 do_event 函数中处理事件, 对于自陷事件简单的输出 “self trap!” 提示.</p>
<h4 id="实验测试-6"><a href="#实验测试-6" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 3.1 所示, 输出 self trap! 提示表示自陷成功. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya4tct39fj30kc03g3z1.jpg" alt="截屏2022-01-11 下午11.06.08"></p>
<center style="font-size:14px;text-decoration:underline">图 3-1 自陷 dummy 测试</center> 

<h3 id="PA-3-2-系统调用与程序加载"><a href="#PA-3-2-系统调用与程序加载" class="headerlink" title="PA 3.2 系统调用与程序加载"></a>PA 3.2 系统调用与程序加载</h3><h4 id="实验要求-7"><a href="#实验要求-7" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现 loader 函数加载功能.</li>
<li>在<code>nexus-am/am/include/arch/$ISA-nemu.h</code>中实现正确的<code>GPR</code>宏, 让它们从上下文<code>c</code>中获得正确的系统调用参数寄存器.</li>
<li>运行 hello 测试程序. </li>
<li>实现<code>SYS_brk</code>系统调用.</li>
</ul>
<h4 id="实验过程-7"><a href="#实验过程-7" class="headerlink" title="实验过程"></a>实验过程</h4><p>涉及文件:</p>
<p>nanos-lite/src/loader.c</p>
<p>nexus-am/am/include/arch/riscv32-nemu.h</p>
<p>nexus-am/am/src/riscv32/nemu/trap.S</p>
<p>navy-apps/libs/libos/src/nanos.c</p>
<p>nanos-lite/src/proc.c</p>
<p>nanos-lite/src/irq.c</p>
<p>具体过程:</p>
<p>首先在 loader 函数中实现程序的加载, 一开始使用 ramdisk, 后来有了文件系统更新为使用文件操作, 最后返回程序的入口, 通过 naive_uload 进入程序. 在 irq.c 文件中实现 do_event 函数将事件分发给系统调用, 再在 syscall.c 文件中实现 do_syscall 跳转到各个系统调用.</p>
<p>其次, 根据 trap.S 文件实现正确的 GPR 宏, 并添加系统调用完成_sbrk 实现堆区管理. </p>
<h4 id="实验测试-7"><a href="#实验测试-7" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 3.2 所示, hello 程序正常运行.</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya56uu4e2j30km0aodir.jpg" alt="截屏2022-01-11 下午11.01.53"></p>
<center style="font-size:14px;text-decoration:underline">图 3-2 hello 测试</center> 

<h3 id="PA-3-3-文件系统与仙剑奇侠传"><a href="#PA-3-3-文件系统与仙剑奇侠传" class="headerlink" title="PA 3.3 文件系统与仙剑奇侠传"></a>PA 3.3 文件系统与仙剑奇侠传</h3><h4 id="实验要求-8"><a href="#实验要求-8" class="headerlink" title="实验要求"></a>实验要求</h4><ul>
<li>实现文件读写操作. </li>
<li>修改 loader 加载用户程序的方式. </li>
<li>实现设备函数. </li>
<li>运行仙剑奇侠传</li>
</ul>
<h4 id="实验过程-8"><a href="#实验过程-8" class="headerlink" title="实验过程"></a>实验过程</h4><p>涉及文件:</p>
<p>/Users/akunda/project/ics2019_1/nanos-lite/src/device.c</p>
<p>/Users/akunda/project/ics2019_1/nanos-lite/src/syscall.c</p>
<p>/Users/akunda/project/ics2019_1/nanos-lite/src/fs.c</p>
<p>具体过程:</p>
<p>首先需要实现基本的文件读写.</p>
<p>其次修改之前的 loader 函数, 更新为使用文件系统加载程序. </p>
<p>之后扩展 IOE, 实现 device.c 里的各个接口.</p>
<p>最后运行仙剑奇侠传.</p>
<h4 id="实验测试-8"><a href="#实验测试-8" class="headerlink" title="实验测试"></a>实验测试</h4><p>如图 3.3 所示, text 测试正常. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5aum7i1j30ko058t9f.jpg" alt="截屏2022-01-11 下午11.05.15"></p>
<center style="font-size:14px;text-decoration:underline">图 3-3 text 测试</center> 

<p>如图 3.4 所示, event 测试正常. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5btoj9fj30ke0ag41l.jpg" alt="截屏2022-01-11 下午11.23.54"></p>
<center style="font-size:14px;text-decoration:underline">图 3-4 event 测试</center> 

<p>如图 3.5 所示, bmptest 测试正常. </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5chkyn9j30mq0hsq3h.jpg" alt="截屏2022-01-11 下午11.24.32"></p>
<center style="font-size:14px;text-decoration:underline">图 3-5 bmptest 测试</center> 

<p>如图 3.6 所示, 仙剑奇侠传测试正常</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gya5efs8ojj30m60hkmyr.jpg" alt="截屏2022-01-11 下午11.26.24"></p>
<center style="font-size:14px;text-decoration:underline">图 3-6 仙剑奇侠传测试</center> 

<h3 id="PA-3-问答"><a href="#PA-3-问答" class="headerlink" title="PA 3 问答"></a>PA 3 问答</h3><p>你会在<code>__am_irq_handle()</code>中看到有一个上下文结构指针<code>c</code>, <code>c</code>指向的上下文结构究竟在哪里?这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? <code>$ISA-nemu.h</code>, <code>trap.S</code>, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</p>
<p><em><strong>由 trap.S 运行进行赋值的.</strong></em> </p>
<p><em><strong>riscv-nemu.h 定义了相关的结构, trap.S 对上下文结构体进行赋值, 讲义讲清了流程, 实现的指令使自陷操作顺利执行.</strong></em></p>
<p>从Nanos-lite调用<code>_yield()</code>开始, 到从<code>_yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, Nanos-lite)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码/C代码的行为, 尤其是一些比较关键的指令/变量. </p>
<p><em><strong>nanos-lite 调用中断, am 发起自陷指令, 保存上下文, 转入 cpu 自陷指令的内存部分, 执行完后恢复上下文, 返回运行环境</strong></em></p>
<p>我们知道<code>navy-apps/tests/hello/hello.c</code>只是一个C源文件, 它会被编译链接成一个ELF文件. 那么, hello程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? hello程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?</p>
<p><em><strong>elf 位于 ramdisk 中, 通过 naive_uload 读入内存并放置在指定位置, 字符通过系统调用 SYS_write 输出.</strong></em></p>
<p>运行仙剑奇侠传时会播放启动动画, 动画中仙鹤在群山中飞过. 这一动画是通过<code>navy-apps/apps/pal/src/main.c</code>中的<code>PAL_SplashScreen()</code>函数播放的. 阅读这一函数, 可以得知仙鹤的像素信息存放在数据文件<code>mgo.mkf</code>中. 请回答以下问题: 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从<code>mgo.mkf</code>文件中读出仙鹤的像素信息, 并且更新到屏幕上? 换一种PA的经典问法: 这个过程究竟经历了些什么?</p>
<p><em><strong>操作系统通过可函数读出像素信息, 画面通过 vga 输出, vga 被操作系统看做设备文件, fs_write 函数调用了 draw_rect 函数, draw_rect 函数把像素信息写到 vga 对应的地址空间中, 最后通过 update_screen 函数将画面显示到屏幕上.</strong></em></p>
<h1 id="PA实验"><a href="#PA实验" class="headerlink" title="PA实验"></a>PA实验</h1><p>course.cunok.cn都替换成course1.istratus.cn、scripts都替换成scripts1。反之亦然。</p>
<p>校园网外访问：<br><a target="_blank" rel="noopener" href="https://course1.istratus.cn/projects/pa/wiki">https://course1.istratus.cn/projects/pa/wiki</a></p>
<h2 id="PA0"><a href="#PA0" class="headerlink" title="PA0"></a>PA0</h2><h2 id="PA1-1"><a href="#PA1-1" class="headerlink" title="PA1"></a>PA1</h2><p><strong>realpath ./</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_START&#96;(也就是&#96;0x100000)</span><br></pre></td></tr></table></figure>

<p>因此, 我们把内置客户程序放在<code>nemu/src/isa/$ISA/init.c</code>中, 同时抽象出<code>uint8_t isa_default_img[]</code>和<code>long isa_default_img_size</code>这两个变量作为API来给monitor使用.</p>
<p>例如如果mips32的CPU打算访问内存地址<code>0x80001234</code>, 我们最终会让它访问<code>pmem[0x1234]</code>.</p>
<ul>
<li><code>Log()</code>是<code>printf()</code>的升级版, 专门用来输出调试信息, 同时还会输出使用<code>Log()</code>所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置</li>
<li><code>Assert()</code>是<code>assert()</code>的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息</li>
<li><code>panic()</code>用于输出信息并结束程序, 相当于无条件的assertion fail</li>
</ul>
<p>总是使用<code>vaddr_read()</code>和<code>vaddr_write()</code>访问模拟的内存. vaddr, paddr分别代表虚拟地址和物理地址. </p>
<p>debug</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>格式</th>
<th>使用举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>帮助(1)</td>
<td><code>help</code></td>
<td><code>help</code></td>
<td>打印命令的帮助信息</td>
</tr>
<tr>
<td>继续运行(1)</td>
<td><code>c</code></td>
<td><code>c</code></td>
<td>继续运行被暂停的程序</td>
</tr>
<tr>
<td>退出(1)</td>
<td><code>q</code></td>
<td><code>q</code></td>
<td>退出NEMU</td>
</tr>
<tr>
<td>单步执行</td>
<td><code>si [N]</code></td>
<td><code>si 10</code></td>
<td>让程序单步执行<code>N</code>条指令后暂停执行, 当<code>N</code>没有给出时, 缺省为<code>1</code></td>
</tr>
<tr>
<td>打印程序状态</td>
<td><code>info SUBCMD</code></td>
<td><code>info r</code> <code>info w</code></td>
<td>打印寄存器状态 打印监视点信息</td>
</tr>
<tr>
<td>表达式求值</td>
<td><code>p EXPR</code></td>
<td><code>p $eax + 1</code></td>
<td>求出表达式<code>EXPR</code>的值, <code>EXPR</code>支持的 运算请见<a target="_blank" rel="noopener" href="https://course1.istratus.cn/pa/doc2019/1.6.html">调试中的表达式求值</a>小节</td>
</tr>
<tr>
<td>扫描内存(2)</td>
<td><code>x N EXPR</code></td>
<td><code>x 10 $esp</code></td>
<td>求出表达式<code>EXPR</code>的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的<code>N</code>个4字节</td>
</tr>
<tr>
<td>设置监视点</td>
<td><code>w EXPR</code></td>
<td><code>w *0x2000</code></td>
<td>当表达式<code>EXPR</code>的值发生变化时, 暂停程序执行</td>
</tr>
<tr>
<td>删除监视点</td>
<td><code>d N</code></td>
<td><code>d 2</code></td>
<td>删除序号为<code>N</code>的监视点</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nemu&#x2F;src&#x2F;isa&#x2F;$ISA&#x2F;reg.c</span><br><span class="line">void isa_reg_display(void);</span><br></pre></td></tr></table></figure>

<p>你需要将<code>nemu_state.state</code>变量设置为<code>NEMU_STOP</code>来达到暂停的效果. 最后输出一句话提示用户触发了监视点, 并返回到<code>ui_mainloop()</code>循环中等待用户的命令.</p>
<h2 id="PA2-1"><a href="#PA2-1" class="headerlink" title="PA2"></a>PA2</h2><p>PA2中（<a target="_blank" rel="noopener" href="https://course.cunok.cn/pa/doc2019/2.2.html%EF%BC%89%E6%8F%90%E5%88%B0%E7%9A%84riscv32">https://course.cunok.cn/pa/doc2019/2.2.html）提到的riscv32</a> centos64版本的交叉编译器链接的github地址已经失效，请下载课程网站wiki页面中“相关资源”9. RISC-V Cross-compiler所提供的编译器。版本与文档中稍有差别，PATH路径对应修改一下。</p>
<ol>
<li>在<code>opcode_table</code>中填写正确的译码辅助函数, 执行辅助函数以及操作数宽度</li>
<li>用RTL实现正确的执行辅助函数, 需要注意使用RTL伪指令时要遵守上文提到的小型调用约定</li>
</ol>
<p>exec_once() nemu/src/cpu/cpu.c</p>
<p>isa_exec() nemu/src/isa/$ISA/exec/exec.c</p>
<p>idex() nemu/include/cpu/exec.h</p>
<p>make_DHelper nemu/include/cpu/decode.h nemu/src/isa/x86/decode/decode.c</p>
<p>make_DopHelper </p>
<p>make_EHelper nemu/include/cpu/exec.h</p>
<p>在<code>nexus-am/tests/cputest/</code>目录下键入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=<span class="variable">$ISA</span>-nemu ALL=dummy run</span><br></pre></td></tr></table></figure>



<p>具体地, 在<code>exec_once()</code>中, 框架代码首先将当前的PC保存到全局译码信息<code>decinfo</code>的成员<code>seq_pc</code>中. 其中:</p>
<ul>
<li><code>decinfo</code>结构在<code>nemu/src/cpu/cpu.c</code>中定义, 它用于记录一些全局译码信息供后续使用, 包括操作数的类型, 宽度, 值等信息. 还有一些信息是ISA相关的, NEMU用一个结构类型<code>struct ISADecodeInfo</code>来对这些信息进行抽象, 具体的定义在<code>nemu/src/isa/$ISA/include/isa/decode.h</code>中.</li>
<li><code>seq</code>代表顺序(sequential)的意思</li>
</ul>
<p>然后<code>decinfo.seq_pc</code>的地址将被作为参数送进<code>isa_exec()</code>函数(在<code>nemu/src/isa/$ISA/exec/exec.c</code>中定义)中. <code>isa_exec()</code>显然是一个用于屏蔽ISA差异的API: 不同ISA的指令行为天然不同.</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>nemu/include/macro.h</code></td>
<td></td>
</tr>
<tr>
<td><code>str(x)</code></td>
<td>字符串<code>&quot;x&quot;</code></td>
</tr>
<tr>
<td><code>concat(x, y)</code></td>
<td>token<code>xy</code></td>
</tr>
<tr>
<td><code>nemu/include/cpu/decode.h</code></td>
<td></td>
</tr>
<tr>
<td><code>id_src</code></td>
<td>全局变量<code>decinfo</code>中源操作数成员的地址</td>
</tr>
<tr>
<td><code>id_src2</code></td>
<td>全局变量<code>decinfo</code>中2号源操作数成员的地址</td>
</tr>
<tr>
<td><code>id_dest</code></td>
<td>全局变量<code>decinfo</code>中目的操作数成员的地址</td>
</tr>
<tr>
<td><code>make_DHelper(name)</code></td>
<td>名为<code>decode_name</code>的译码辅助函数的原型说明</td>
</tr>
<tr>
<td><code>nemu/src/isa/$ISA/decode.c</code></td>
<td></td>
</tr>
<tr>
<td><code>make_DopHelper(name)</code></td>
<td>名为<code>decode_op_name</code>的操作数译码辅助函数的原型说明</td>
</tr>
<tr>
<td><code>nemu/include/cpu/exec.h</code></td>
<td></td>
</tr>
<tr>
<td><code>make_EHelper(name)</code></td>
<td>名为<code>exec_name</code>的执行辅助函数的原型说明</td>
</tr>
<tr>
<td><code>print_asm(...)</code></td>
<td>将反汇编结果的字符串打印到缓冲区<code>log_asmbuf</code>中</td>
</tr>
<tr>
<td><code>suffix_char(width)</code></td>
<td>操作数宽度<code>width</code>对应的后缀字符(仅x86使用)</td>
</tr>
<tr>
<td>`print_asm_template[1</td>
<td>2</td>
</tr>
</tbody></table>
<ul>
<li><p>不同ISA的通用寄存器(在<code>nemu/src/isa/$ISA/include/isa/reg.h</code>中定义)</p>
</li>
<li><p><code>id_src</code>, <code>id_src2</code>和<code>id_dest</code>中的访存地址<code>addr</code>和操作数内容<code>val</code>(在<code>nemu/include/cpu/decode.h</code>中定义). 从概念上看, 它们分别与<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_address_register">MAR</a>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_data_register">MDR</a>有异曲同工之妙</p>
</li>
<li><p>临时寄存器<code>s0, s1, t0, t1</code>和<code>ir</code>(在<code>nemu/src/cpu/cpu.c</code>中定义)</p>
</li>
<li><p>立即数读入<code>rtl_li</code></p>
</li>
<li><p>寄存器传输<code>rtl_mv</code></p>
</li>
<li><p>32位寄存器-寄存器类型的算术/逻辑运算, 包括<code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])</code>, 这些运算的定义用到了<code>nemu/include/rtl/c_op.h</code>中的C语言运算</p>
</li>
<li><p>被除数为64位的除法运算<code>rtl_i?div64_[q|r]</code></p>
</li>
<li><p>guest内存访问<code>rtl_lm</code>和<code>rtl_sm</code></p>
</li>
<li><p>host内存访问<code>rtl_host_lm</code>和<code>rtl_host_sm</code></p>
</li>
<li><p>关系运算<code>rtl_setrelop</code>, 具体可参考<code>nemu/src/cpu/relop.c</code></p>
</li>
<li><p>跳转, 包括直接跳转<code>rtl_j</code>, 间接跳转<code>rtl_jr</code>和条件跳转<code>rtl_jrelop</code></p>
</li>
<li><p>终止程序<code>rtl_exit</code>(在<code>nemu/src/monitor/cpu-exec.c</code>中定义)</p>
</li>
<li><p>实现RTL伪指令的时候, 尽可能不使用<code>dest</code>之外的寄存器存放中间结果. 由于<code>dest</code>最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.</p>
</li>
<li><p>实在需要使用临时寄存器的时候, 按照以下约定来使用:</p>
<ul>
<li><code>ir</code>(immediate register) - 只能作为<code>rtl_li</code>的目的RTL寄存器</li>
<li><code>t0</code>, <code>t1</code> - 只能在RTL伪指令的实现过程中存放中间结果</li>
<li><code>s0</code>, <code>s1</code> - 只能在译码辅助函数和执行辅助函数的实现过程中存放中间结果</li>
</ul>
</li>
</ul>
<p>这个例子也展示了运行时环境的一种普遍的存在方式: 库. 通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些API, 就能使用运行时环境提供的相应功能.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AM &#x3D; TRM + IOE + CTE + VME + MPE</span><br></pre></td></tr></table></figure>

<ul>
<li>TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力</li>
<li>IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力</li>
<li>CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力</li>
<li>VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力</li>
<li>MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)</li>
</ul>
<h2 id="PA3"><a href="#PA3" class="headerlink" title="PA3"></a>PA3</h2><p>riscv32提供<code>ecall</code>指令作为自陷指令, 并提供一个stvec寄存器来存放异常入口地址. 为了保存程序当前的状态, riscv32提供了一些特殊的系统寄存器, 叫控制状态寄存器(CSR寄存器). 在PA中, 我们只使用如下3个CSR寄存器:</p>
<ul>
<li>sepc寄存器 - 存放触发异常的PC</li>
<li>sstatus寄存器 - 存放处理器的状态</li>
<li>scause寄存器 - 存放触发异常的原因</li>
</ul>
<p>riscv32触发异常后硬件的响应过程如下:</p>
<ol>
<li>将当前PC值保存到sepc寄存器</li>
<li>在scause寄存器中设置异常号</li>
<li>从stvec寄存器中取出异常入口地址</li>
<li>跳转到异常入口地址</li>
</ol>
<p>你需要实现<code>SYS_exit</code>系统调用, 它会接收一个退出状态的参数, 用这个参数调用<code>_halt()</code>即可. 实现成功后, 再次运行dummy程序, 你会看到<code>HIT GOOD TRAP</code>的信息.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -15,2 +15,2 @@</span></span><br><span class="line"><span class="deletion">-SINGLE_APP = $(NAVY_HOME)/tests/dummy</span></span><br><span class="line"><span class="addition">+SINGLE_APP = $(NAVY_HOME)/tests/hello</span></span><br><span class="line"> SINGLE_APP_FILE = $(FSIMG_PATH)/bin/$(notdir $(SINGLE_APP))</span><br></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- nanos-lite/Makefile</span></span><br><span class="line"><span class="comment">+++ nanos-lite/Makefile</span></span><br><span class="line"><span class="meta">@@ -36,2 +36,2 @@</span></span><br><span class="line"><span class="deletion">-update: update-ramdisk-single src/syscall.h</span></span><br><span class="line"><span class="addition">+update: update-ramdisk-fsimg src/syscall.h</span></span><br><span class="line">  @touch src/initrd.S</span><br></pre></td></tr></table></figure>

<p>然后运行<code>make clean</code>清除<code>build/ramdisk.img</code>. 之后编译Nanos-lite就会自动编译Navy-apps里面的所有程序, 并把<code>navy-apps/fsimg/</code>目录下的所有内容整合成ramdisk镜像, 同时生成这个ramdisk镜像的文件记录表<code>nanos-lite/src/files.h</code>. 需要注意的是, 并不是Navy-apps里面的所有程序都能在Nanos-lite上运行, 有些程序需要更多系统调用的支持才能运行, 例如NWM和NTerm, 我们并不打算在PA中运行这些程序.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -6,4 +6,5 @@</span></span><br><span class="line"> typedef struct &#123;</span><br><span class="line">   char *name;         // 文件名</span><br><span class="line">   size_t size;        // 文件大小</span><br><span class="line">   size_t disk_offset;  // 文件在ramdisk中的偏移</span><br><span class="line"><span class="addition">+  size_t open_offset;  // 文件被打开之后的读写指针</span></span><br></pre></td></tr></table></figure>


            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E7%9B%AE%E7%9A%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">课程目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">课程任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.3.</span> <span class="toc-text">实验环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA1"><span class="toc-number">1.2.</span> <span class="toc-text">PA1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PA1-1-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">PA1.1 基础设施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-1-2-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.2.2.</span> <span class="toc-text">PA 1.2 表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-1"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-1-3-%E7%9B%91%E8%A7%86%E7%82%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">PA 1.3 监视点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-1-%E9%97%AE%E7%AD%94"><span class="toc-number">1.2.4.</span> <span class="toc-text">PA 1 问答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA2"><span class="toc-number">1.3.</span> <span class="toc-text">PA2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-1-%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AA-C-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">PA 2.1 运行第一个 C 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-3"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-3"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-3"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">PA 2.2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-4"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-4"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-4"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-3"><span class="toc-number">1.3.3.</span> <span class="toc-text">PA 2.3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-5"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-5"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-2-%E9%97%AE%E7%AD%94"><span class="toc-number">1.3.4.</span> <span class="toc-text">PA 2 问答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA-3-%E8%87%AA%E9%99%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">PA 3 自陷操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">PA 3.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-6"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-6"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.4.2.</span> <span class="toc-text">PA 3.2 系统调用与程序加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-7"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-7"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-7"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0"><span class="toc-number">1.4.3.</span> <span class="toc-text">PA 3.3 文件系统与仙剑奇侠传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-8"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-8"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-8"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">实验测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PA-3-%E9%97%AE%E7%AD%94"><span class="toc-number">1.4.4.</span> <span class="toc-text">PA 3 问答</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PA%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">PA实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PA0"><span class="toc-number">2.1.</span> <span class="toc-text">PA0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA1-1"><span class="toc-number">2.2.</span> <span class="toc-text">PA1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA2-1"><span class="toc-number">2.3.</span> <span class="toc-text">PA2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA3"><span class="toc-number">2.4.</span> <span class="toc-text">PA3</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
