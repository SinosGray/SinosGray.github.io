<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面经 | Sinos_wei's blog</title><meta name="author" content="Sinos"><meta name="copyright" content="Sinos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://sinos_wei.gitee.io/2021/12/06/%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Sinos_wei&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sinos_wei.gitee.io/img/cover/IMG_2423.JPG">
<meta property="article:published_time" content="2021-12-06T07:31:58.026Z">
<meta property="article:modified_time" content="2022-07-11T12:19:24.912Z">
<meta property="article:author" content="Sinos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sinos_wei.gitee.io/img/cover/IMG_2423.JPG"><link rel="shortcut icon" href="/img/icon.JPG"><link rel="canonical" href="https://sinos_wei.gitee.io/2021/12/06/%E9%9D%A2%E7%BB%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-11 20:19:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">31</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/IMG_2423.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Sinos_wei's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2022-07-11T12:19:24.912Z" title="Updated 2022-07-11 20:19:24">2022-07-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面经"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
</blockquote>
<span id="more"></span>

<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官您好, 我叫魏子清, 本科就读于华中科技大学计算机科学与技术专业, 是一名大四应届毕业生</p>
<p>本科阶段在华科启明学院 Dian 团队进行项目开发, 团队编号 691, 下面我简单介绍一下我所参与的两个项目</p>
<p><strong>深信服科技股份有限公司 SIEM 日志接入</strong>( Security Information Event Management，安全信息与事件管理)</p>
<ol>
<li>在虚拟机上配置软件环境, 调整软件行为使其尽可能的产生各种种类的日志</li>
<li>通过 logstash 将生成的日志输出为 json 格式</li>
<li>测试解析的速度, 输出日志解析文档</li>
</ol>
<p>sendmail, mysql, informix, websphere</p>
<p>自己写脚本</p>
<p><strong>武汉烽火凯卓科技有限公司 基于海康流媒体的边防监控系统客户端</strong></p>
<p>这款产品已经成功落地, 在边境派出所投入使用</p>
<p>这个项目在我们接手时 完成度比较高, 几经转手, 甲方添加新功能 丰富完善</p>
<ul>
<li><p>在 alarm 时弹出监控截图的窗口, eventdata</p>
</li>
<li><p>录像回放剪辑, 录像下载, 传时间 基准时间</p>
</li>
<li><p>录像回放节点过滤</p>
</li>
<li><p>预览界面左边是摄像头通道树, 右边是九宫格预览,<br>树本身, 树和预览界面之间, 拖拽, 双击, 一组摄像头拖拽</p>
</li>
<li><p>抓图, 三连抓, 全景拼接</p>
</li>
<li><p>收藏夹, 服务端沟通, 闪退</p>
</li>
</ul>
<p>在预览界面将设备节点再不同区域来回拖动会导致闪退问题</p>
<ol>
<li>首先通过依次关闭各个软件模块, 定位到问题是出现在预览模块中</li>
<li>版本回退, 收藏夹</li>
<li>之后通过调试捕捉到闪退是报出的 std::non_rtti_object 异常, 分析后判断这是因为对一个已经释放的野指针执行 dynamic_cast 导致的(Run-Time Type Identification)</li>
<li>通过在树的继承间打印内存信息，对数据进行分析，发现是由于收藏夹树刷新时没有清理指针的缓存，通过对树的重构解决</li>
</ol>
<p>这个项目是分很多模块的, 根据 config 文件来决定哪些模块需要加载, 然后每个模块都会继承一个 icomponent 接口, 这些模块的指针保存在一个指针数组里, 外界可以通过响应的名字来进行调用.</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>　　我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。</p>
<p>　　这就是DP（动态规划，dynamic programming）.</p>
<p>　　将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</p>
<h2 id="fib"><a href="#fib" class="headerlink" title="fib"></a>fib</h2><p>fib(n) = fib(n-1) + fib(n-2)</p>
<ul>
<li><p>classic</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>memoization</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(<span class="number">50</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="grid-travel"><a href="#grid-travel" class="headerlink" title="grid travel"></a>grid travel</h2><p>gridtravel(x, y) = gridtravel(x-1, y) + gridtravel(x, y-1)</p>
<ul>
<li><p>classical</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gridtravel</span><span class="params">(m, n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(m==<span class="number">0</span> || n==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gridtravel</span>(m<span class="number">-1</span>, n) + <span class="built_in">gridtravel</span>(m, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>memoization</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="keyword">long</span> <span class="keyword">long</span>&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gridtravel</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    string key = <span class="built_in">to_string</span>(m) + <span class="string">&quot;|&quot;</span> + <span class="built_in">to_string</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(memo.<span class="built_in">find</span>(key) == memo.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>)</span><br><span class="line">            memo[key] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">0</span> || n==<span class="number">0</span>)</span><br><span class="line">            memo[key] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            memo[key] = <span class="built_in">gridtravel</span>(m<span class="number">-1</span>, n) + <span class="built_in">gridtravel</span>(m, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可优化: 4,3 == 3, 4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="can-sum"><a href="#can-sum" class="headerlink" title="can sum"></a>can sum</h2><blockquote>
<p>canSum(7, [5, 3, 4, 7])  true</p>
</blockquote>
<ul>
<li><p>classical</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canSum</span><span class="params">(<span class="keyword">int</span> targetSum, vector&lt;<span class="keyword">int</span>&gt; numbers)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(targetSum == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(num )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == null || head-&gt;next == null)</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* newhead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">      ListNode* next = cur-&gt;next;</span><br><span class="line">      cur-&gt;next = prev;</span><br><span class="line">      prev = cur;</span><br><span class="line">      cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前序遍历-中序遍历-值不重复-构建二叉树"><a href="#前序遍历-中序遍历-值不重复-构建二叉树" class="headerlink" title="前序遍历+中序遍历(值不重复) 构建二叉树"></a>前序遍历+中序遍历(值不重复) 构建二叉树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">this</span>-&gt;inorder_hash[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursion</span>(<span class="number">0</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; preorder;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inorder_hash;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[root]);</span><br><span class="line">        <span class="keyword">int</span> i = inorder_hash[preorder[root]];</span><br><span class="line">        node-&gt;left = <span class="built_in">recursion</span>(root+<span class="number">1</span>, left, i<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">recursion</span>(root+i-left+<span class="number">1</span>, i+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="top-k"><a href="#top-k" class="headerlink" title="top k"></a>top k</h1><p>#剑指 offer</p>
<ul>
<li><p>状态难易度标签</p>
<table>
<thead>
<tr>
<th align="left">题目</th>
<th align="left">通过率</th>
<th>题目概述</th>
<th align="left">思路</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></td>
<td align="left">67.9%</td>
<td>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br/><br/></td>
<td align="left">bool vector</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></td>
<td align="left">40.2%</td>
<td>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br/></td>
<td align="left">左下右上</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></td>
<td align="left">76.0%</td>
<td>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</td>
<td align="left">easy</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></td>
<td align="left">75.0%</td>
<td>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</td>
<td align="left">反转链表</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></td>
<td align="left">70.2%</td>
<td>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。<br />假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></td>
<td align="left">71.1%</td>
<td>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )<br/><br/>来源：力扣（LeetCode）<br/>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a><br/>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</td>
<td align="left">s1 输入, s2 输出</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></td>
<td align="left">36.2%</td>
<td>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br/><br/>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br/></td>
<td align="left">只需要保留后两个数, 不用全部存在 vector 里</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></td>
<td align="left">45.2%</td>
<td>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br/><br/>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</td>
<td align="left">同上</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></td>
<td align="left">49.2%</td>
<td>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br/><br/>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  <br/><br/>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。<br/></td>
<td align="left">二分变形</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></td>
<td align="left">45.3%</td>
<td></td>
<td align="left">dfs</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></td>
<td align="left">53.2%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></td>
<td align="left">57.2%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></td>
<td align="left">31.6%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></td>
<td align="left">75.0%</td>
<td></td>
<td align="left">位运算</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></td>
<td align="left">34.4%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></td>
<td align="left">77.9%</td>
<td></td>
<td align="left">大数???</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></td>
<td align="left">60.1%</td>
<td></td>
<td align="left">内存泄漏</td>
</tr>
<tr>
<td align="left">[剑指 Offer 19. 正则表达式]</td>
<td align="left"></td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></td>
<td align="left">24.9%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></td>
<td align="left">64.6%</td>
<td></td>
<td align="left">双指针</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></td>
<td align="left">80.1%</td>
<td></td>
<td align="left">快慢指针?</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></td>
<td align="left">74.3%</td>
<td></td>
<td align="left">prev cur next</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></td>
<td align="left">72.7%</td>
<td></td>
<td align="left">双指针</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></td>
<td align="left">46.7%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></td>
<td align="left">79.3%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></td>
<td align="left">57.8%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></td>
<td align="left">43.8%</td>
<td></td>
<td align="left">?</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></td>
<td align="left">55.3%</td>
<td></td>
<td align="left">min栈</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></td>
<td align="left">61.8%</td>
<td></td>
<td align="left">判定有问题[1, 0], 模拟栈</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></td>
<td align="left">68.7%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></td>
<td align="left">58.8%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></td>
<td align="left">55.9%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></td>
<td align="left">58.4%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></td>
<td align="left">71.7%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></td>
<td align="left">65.3%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></td>
<td align="left">56.6%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></td>
<td align="left">58.0%</td>
<td></td>
<td align="left">重复字母?</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></td>
<td align="left">69.7%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></td>
<td align="left">57.2%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></td>
<td align="left">58.4%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></td>
<td align="left">60.7%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></td>
<td align="left">49.6%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></td>
<td align="left">42.3%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></td>
<td align="left">55.7%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></td>
<td align="left">52.6%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></td>
<td align="left">69.1%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></td>
<td align="left">46.4%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></td>
<td align="left">65.4%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></td>
<td align="left">48.9%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></td>
<td align="left">65.4%</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></td>
<td align="left">53.2%</td>
<td></td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="拷贝初始化-直接初始化"><a href="#拷贝初始化-直接初始化" class="headerlink" title="拷贝初始化 直接初始化"></a>拷贝初始化 直接初始化</h2><h2 id="final-volatile"><a href="#final-volatile" class="headerlink" title="final volatile"></a>final volatile</h2><ul>
<li><p>final</p>
<p>直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</p>
<p>将方法标记为fianal，这意味着无法再<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>中重写该方法。这时final关键字至于方法参数列表后面，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Supe</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SomeMethod</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>volatile</p>
<p>用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据</p>
</li>
</ul>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p>解决: 虚继承</p>
<p>虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态。对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象，共享基类子对象称为虚基类。虚基类用virtual声明继承关系就行了。</p>
<h2 id="多态是什么"><a href="#多态是什么" class="headerlink" title="多态是什么"></a>多态是什么</h2><ul>
<li>编译时多态 重载函数</li>
<li>运行时多态 虚函数</li>
</ul>
<p>通过基类指针调用派生类的方法, 实现一个接口多个方法</p>
<h2 id="虚函数是怎么实现的"><a href="#虚函数是怎么实现的" class="headerlink" title="虚函数是怎么实现的"></a><a target="_blank" rel="noopener" href="https://jacktang816.github.io/post/virtualfunction/">虚函数是怎么实现的</a></h2><p>每一个有虚函数的类都有一个指向虚函数表的指针, 里面记录了每个虚函数的地址, 当对象的虚函数被调用时, 通过查找虚函数表来确定调用哪个函数</p>
<p>创建时间: 虚函数表指针-编译时和对象一起, 虚函数表-编译时</p>
<p>多继承, 多虚函数表</p>
<p><strong>虚函数运行时所需的代价主要是虚函数不能是内联函数</strong></p>
<ul>
<li>内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码</li>
</ul>
<p>static 函数不能为 virtual, 因为没有 this 指针, 无法调用 vtb</p>
<p>构造函数不能为 virtual, 因为 virtual func 需要查找 vtb, 会有编译错误</p>
<p>构造函数内可以调用虚函数, 但是无法实现多态</p>
<p>析构函数, 如果可能为基类就要求是 virtual</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_a</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">int64_t</span> _m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jacktang816.github.io/img/cpp/virtualFunction/vptrLocation.png" alt="img"></p>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p>继承封装多态</p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p> 指针是对象, 引用是对象的别名, 且一定不为空</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>防止内存泄露</p>
<p>大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。 在现代 C++ 中，原始指针仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的 Helper 函数中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Song* pSong = <span class="keyword">new</span> <span class="built_in">Song</span>(<span class="string">L&quot;Nothing on You&quot;</span>, <span class="string">L&quot;Bruno Mars&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pSong...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t forget to delete!</span></span><br><span class="line">    <span class="keyword">delete</span> pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseSmartPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Song&gt; <span class="title">song2</span><span class="params">(<span class="keyword">new</span> Song(<span class="string">L&quot;Nothing on You&quot;</span>, <span class="string">L&quot;Bruno Mars&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use song2...</span></span><br><span class="line">    wstring s = song2-&gt;duration_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// song2 is deleted automatically here.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>分类</p>
<ul>
<li><code>unique_ptr</code><br>在任何时间、资源只能被一个指针占有。 可以移到新所有者，但不会复制或共享。 替换已弃用的 <code>auto_ptr</code>。 大小是一个指针. 头文件：<code>&lt;memory&gt;</code>。<br>在下列两者之一发生时用关联的删除器释放对象：<ul>
<li>销毁了管理的 unique_ptr 对象</li>
<li>通过 operator= 或 reset() 赋值另一指针给管理的 unique_ptr 对象。</li>
</ul>
</li>
<li><code>shared_ptr</code><br>采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 <code>shared_ptr</code> 所有者超出了范围或放弃所有权，才会删除原始指针。 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。 头文件：<code>&lt;memory&gt;</code>。<br>下列情况之一出现时销毁对象并解分配其内存：<ul>
<li>最后剩下的占有对象的 shared_ptr 被销毁；</li>
<li>最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset() 赋值为另一指针。</li>
</ul>
</li>
<li><code>weak_ptr</code><br>结合 <code>shared_ptr</code> 使用的特例智能指针。 <code>weak_ptr</code> 提供对一个或多个 <code>shared_ptr</code> 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，需要断开 <code>shared_ptr</code> 实例间的循环引用。 头文件：<code>&lt;memory&gt;</code>。 </li>
</ul>
<p>（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：</p>
<ul>
<li>有一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:331873847%7D">指针数组</a>，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li>
<li>两个对象包含都指向第三个对象的指针；</li>
<li>STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。</li>
</ul>
<p>（2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。</p>
</li>
</ul>
<h2 id="Resource-acquisition-is-initialization"><a href="#Resource-acquisition-is-initialization" class="headerlink" title="Resource acquisition is initialization"></a>Resource acquisition is initialization</h2><h2 id="malloc-new"><a href="#malloc-new" class="headerlink" title="malloc new"></a>malloc new</h2><p>由于<code>malloc/free</code>是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于<code>malloc/free</code>。</p>
<h2 id="static-作用"><a href="#static-作用" class="headerlink" title="static 作用"></a>static 作用</h2><ul>
<li><p>static 变量</p>
<ul>
<li><p>static 变量 in func</p>
<p>声明周期和程序本身一样</p>
</li>
<li><p>static 变量 in class</p>
<p>所有对象共享</p>
</li>
</ul>
</li>
<li><p>static func</p>
<p>只允许访问静态成员和函数</p>
</li>
</ul>
<h2 id="memset-memcpy-strcpy"><a href="#memset-memcpy-strcpy" class="headerlink" title="memset memcpy strcpy"></a>memset memcpy strcpy</h2><p> strcpy </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest,<span class="keyword">char</span> *src)</span></span>;  </span><br></pre></td></tr></table></figure>

<p> 功能：把src所指由NULL结束的字符串复制到dest所指的数组中  </p>
<p>说明:src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。  </p>
<p>返回指向dest的指针 </p>
<p>memcpy </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest,<span class="keyword">void</span> *src,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; </span><br></pre></td></tr></table></figure>

<p> 功能：由src所指内存区域复制count个字符串到dest所指内存区域.  </p>
<p>说明：src和dest所指内存区域不能重叠，函数返回指向dest的指针.   </p>
<p>memset  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *buffer,<span class="keyword">int</span> c,<span class="keyword">int</span> count)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>功能：把buffer所指内存区域的前count个字节设置成字符c  </p>
<p>说明：返回指向buffer的指针.</p>
<p>memset 用来对一段内存空间全部设置为某个字符，一般用于在对定义的字符串初始化为’ ‘或者’\0’;   </p>
<p>memcpy 是用来做内存拷贝，可以用来拷贝任何数据类型的对象，可以指定拷贝的数据长度； memcpy是见着什么拷贝什么。    </p>
<p>strcpy 就只能拷贝字符串，它遇到’\0’就结束拷贝；    例：char a[100],b[50];        strcpy(a,b);        如用strcpy(b,a)要注意a中的字符串长度(第一个’\0’之前) 是否超过50,如果超过，则会造成b的 内存溢出.它是不会拷贝’\0’的</p>
<h2 id="内联函数和宏"><a href="#内联函数和宏" class="headerlink" title="内联函数和宏"></a>内联函数和宏</h2><p>宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。</p>
<h2 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h2><p>auto decltype</p>
<p>左右值</p>
<p>列表初始化</p>
<p>lambda</p>
<p>智能指针</p>
<p>for 循环</p>
<p>final  override</p>
<h2 id="stl-容器"><a href="#stl-容器" class="headerlink" title="stl 容器"></a>stl 容器</h2><table>
<thead>
<tr>
<th>底层实现</th>
<th>插入删除</th>
<th>访问</th>
<th>查找</th>
<th>其他</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>尾结点 O(1)<br />非尾结点 O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>扩容</td>
<td>vector</td>
</tr>
<tr>
<td>环状双向链表</td>
<td>O(1)</td>
<td>O(n)</td>
<td></td>
<td></td>
<td>list</td>
</tr>
<tr>
<td>堆+中央控制器</td>
<td>非首尾 O(n)<br />首尾 O(1)</td>
<td>O(1)</td>
<td></td>
<td></td>
<td>deque</td>
</tr>
<tr>
<td>deque</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>stack</td>
</tr>
<tr>
<td>deque</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>queue</td>
</tr>
<tr>
<td>堆(数组无指针)</td>
<td>最值O(logn)</td>
<td></td>
<td></td>
<td></td>
<td>priority_queue</td>
</tr>
<tr>
<td>红黑树</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td></td>
<td></td>
<td>set</td>
</tr>
<tr>
<td>红黑树</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td></td>
<td></td>
<td>map</td>
</tr>
<tr>
<td>hash</td>
<td>O(1)~O(n)</td>
<td>O(1)~O(n)</td>
<td></td>
<td></td>
<td>unordered_set</td>
</tr>
<tr>
<td>hash</td>
<td>O(1)~O(n)</td>
<td>O(1)~O(n)</td>
<td></td>
<td></td>
<td>unordered_map</td>
</tr>
</tbody></table>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="浏览器输入-URL-后发生了什么？"><a href="#浏览器输入-URL-后发生了什么？" class="headerlink" title="浏览器输入 URL 后发生了什么？"></a>浏览器输入 URL 后发生了什么？</h2><p>DNS 解析</p>
<p>TCP 连接</p>
<p>HTTP</p>
<p>tcp 关闭</p>
<p>解析 html</p>
<h2 id="http1-0-http1-1-http2-0"><a href="#http1-0-http1-1-http2-0" class="headerlink" title="http1.0/http1.1/http2.0"></a>http1.0/http1.1/http2.0</h2><ul>
<li><p>http1.1</p>
<p>默认长链接, 请求hostname</p>
</li>
<li><p>http2.0</p>
<p>多路复用 同时发起多重的请求-响应消息</p>
<p>server push</p>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p><img src="https://pic3.zhimg.com/80/v2-c181b1f7cf755605bf950dff0182674a_1440w.jpg" alt="img"></p>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><h2 id="post-get"><a href="#post-get" class="headerlink" title="post get"></a>post get</h2><p>get 获取资源, 没有副作用 url 携带数据(浏览器), 会被 cache</p>
<p>post 提交表单 body</p>
<h2 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h2><p>application/x-www-form-urlencoded</p>
<h2 id="tcp如何保证可靠传输"><a href="#tcp如何保证可靠传输" class="headerlink" title="tcp如何保证可靠传输"></a>tcp如何保证可靠传输</h2><ol>
<li><p>有序</p>
</li>
<li><p>校验和</p>
</li>
<li><p>丢弃重复数据</p>
</li>
<li><p>流量控制 滑动窗口, 防止包丢失</p>
<p><img src="https://pic4.zhimg.com/80/a1d5c050ad957880094a5f003b1ccd24_1440w.jpg?source=1940ef5c" alt="img"></p>
</li>
<li><p>拥塞控制 cwnd</p>
<p><img src="https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_1440w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_1440w.jpg" alt="img"></p>
<ul>
<li><strong>慢开始：</strong>即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong>拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
</li>
<li><p>arq(automatic repeat request) 协议</p>
</li>
<li><p>超时重传</p>
</li>
</ol>
<h1 id="组原"><a href="#组原" class="headerlink" title="组原"></a>组原</h1><h2 id="编译器编译代码的四个过程"><a href="#编译器编译代码的四个过程" class="headerlink" title="编译器编译代码的四个过程"></a>编译器编译代码的四个过程</h2><p>（预处理、编译、汇编、链接, 生成可执行文件）</p>
<p>编译 : 扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><blockquote>
<p>元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为内存是按照自己的大小（通常它为4或8）来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始，这就是所谓的内存对齐。</p>
</blockquote>
<p>理论上，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。</p>
<h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>为什么要内存对齐</p>
<p>内存对齐规则</p>
<ol>
<li><p><strong>基本类型</strong>的对齐值就是其sizeof值;</p>
</li>
<li><p><strong>数据成员对齐规则</strong></p>
<p>1.第一个成员在结构体变量偏移量为0 的地址处，也就是第一个成员必须从头开始。</p>
<p>2.以后每个成员相对于结构体首地址的 offset 都是该成员大小的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
<p>3.结构体的总大小为 最大对齐数的整数倍（每个成员变量都有自己的对齐数），如有需要编译器会在最末一个成员之后加上填充字节。</p>
<p>4.如果嵌套结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（包含嵌套结构体的对齐数）的整数倍。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>   a;</span><br><span class="line">  <span class="keyword">long</span>  b;</span><br><span class="line">  <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//24</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>   a;</span><br><span class="line">  <span class="keyword">short</span> b;</span><br><span class="line">  <span class="keyword">long</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">CBase</span>( <span class="keyword">void</span> );</span><br><span class="line">     <span class="keyword">virtual</span>   ~ <span class="built_in">CBase</span>( <span class="keyword">void</span> );</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">     <span class="keyword">int</span>    a;</span><br><span class="line">     <span class="keyword">char</span>   * p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//32 位系统 12</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CChild</span> :</span></span><br><span class="line">     <span class="keyword">public</span>  CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">CChild</span>( <span class="keyword">void</span> );</span><br><span class="line">     ~ <span class="built_in">CChild</span>( <span class="keyword">void</span> );</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">     <span class="keyword">int</span>  b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mystruct3</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;  <span class="comment">//1  0</span></span><br><span class="line">    <span class="keyword">short</span> d; <span class="comment">//2   [2 3]</span></span><br><span class="line">     <span class="keyword">int</span> c;   <span class="comment">//4   [4 5 6 7]</span></span><br><span class="line">    <span class="keyword">double</span> b;<span class="comment">//8  [8 9 10 11 12 13 14 15]</span></span><br><span class="line"> &#125;Mystruct3;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mystruct4</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;  <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">int</span>  b;  <span class="comment">//4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Mystruct3</span> <span class="title">struct3</span>;</span> <span class="comment">//16  </span></span><br><span class="line">&#125;Mystruct4;</span><br><span class="line"><span class="comment">//4+4+16 = 24</span></span><br></pre></td></tr></table></figure>

<h2 id="c-内存管理"><a href="#c-内存管理" class="headerlink" title="c++ 内存管理"></a>c++ 内存管理</h2><p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。<br>　　<strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>　　<strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br>　　<strong>全局/静态存储区</strong> bssdata：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。<br>　　<strong>常量存储区</strong>rodata：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<p>​        <strong>程序代码区</strong>: 函数</p>
<p>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。栈效率更高</p>
<p><strong>一个程序的3个基本段：text段，data段，bss段</strong></p>
<p>text段在内存中被映射为只读，但data段与bss段是可写的</p>
<ul>
<li>text段：代码段，就是放程序代码的，编译时确定，只读</li>
<li>data段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域</li>
<li>bss段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。</li>
</ul>
<p>两者之间区别是：代码段，数据段，堆栈段是cpu级别的概念，五大分区属于语言级别的概念，两者是不同的概念。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_.<span class="built_in">find</span>(key) == hash_.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = hash_[key]-&gt;second;</span><br><span class="line">            ls_.<span class="built_in">erase</span>(hash_[key]);</span><br><span class="line">            ls_.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">            hash_[key] = ls_.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_.<span class="built_in">find</span>(key) != hash_.<span class="built_in">end</span>())</span><br><span class="line">            ls_.<span class="built_in">erase</span>(hash_[key]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ls_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">            hash_.<span class="built_in">erase</span>(ls_.<span class="built_in">back</span>().first);</span><br><span class="line">            ls_.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ls_.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        hash_[key] = ls_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> capacity_;</span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ls_;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; hash_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>操作系统通过系统调用为运行于其上的进程提供服务。</p>
<p>当用户态进程发起一个系统调用， CPU 将切换到 <strong>内核态</strong> 并开始执行一个 <strong>内核函数</strong> 。 内核函数负责响应应用程序的要求，例如操作文件、进行网络通讯或者申请内存资源等。</p>
<p>注解</p>
<p>读者可能会有些疑问——输出文本不是用 printf 等函数吗？</p>
<p>确实是。 printf 是更高层次的库函数，建立在系统调用之上，实现数据格式化等功能。 因此，本质上还是系统调用起决定性作用。</p>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>那么，在应用程序内，调用一个系统调用的流程是怎样的呢？</p>
<p>我们以一个假设的系统调用 xyz 为例，介绍一次系统调用的所有环节。</p>
<p><img src="https://linux.fasionchan.com/zh_CN/latest/_images/92b3f2ae7105aa2017ac7f475892aca9.jpg" alt="../../_images/92b3f2ae7105aa2017ac7f475892aca9.jpg"></p>
<p>如上图，系统调用执行的流程如下：</p>
<blockquote>
<p>外中断: io</p>
<p>内中断: 系统调用, 异常</p>
</blockquote>
<ol>
<li><strong>应用程序</strong> 代码调用系统调用( xyz )，该函数是一个包装系统调用的 <strong>库函数</strong> ；</li>
<li><strong>库函数</strong> ( xyz )负责准备向内核传递的参数，并触发 <strong>软中断</strong> 以切换到内核；</li>
<li>CPU 被 <strong>软中断</strong> 打断后，执行 <strong>中断处理函数</strong> ，即 <strong>系统调用处理函数</strong> ( system_call )；</li>
<li><strong>系统调用处理函数</strong> 调用 <strong>系统调用服务例程</strong> ( sys_xyz )，真正开始处理该系统调用；</li>
</ol>
<h3 id="执行态切换"><a href="#执行态切换" class="headerlink" title="执行态切换"></a>执行态切换</h3><p><strong>应用程序</strong> ( application program )与 <strong>库函数</strong> ( libc )之间， <strong>系统调用处理函数</strong> ( system call handler )与 <strong>系统调用服务例程</strong> ( system call service routine )之间， 均是普通函数调用，应该不难理解。 而 <strong>库函数</strong> 与 <strong>系统调用处理函数</strong> 之间，由于涉及用户态与内核态的切换，要复杂一些。</p>
<p>Linux 通过 <strong>软中断</strong> 实现从 <strong>用户态</strong> 到 <strong>内核态</strong> 的切换。 <strong>用户态</strong> 与 <strong>内核态</strong> 是独立的执行流，因此在切换时，需要准备 <strong>执行栈</strong> 并保存 <strong>寄存器</strong> 。</p>
<p>内核实现了很多不同的系统调用(提供不同功能)，而 <strong>系统调用处理函数</strong> 只有一个。 因此，用户进程必须传递一个参数用于区分，这便是 <strong>系统调用号</strong> ( system call number )。 在 Linux 中， <strong>系统调用号</strong> 一般通过 eax <strong>寄存器</strong> 来传递。</p>
<p>总结起来， <strong>执行态切换</strong> 过程如下：</p>
<ol>
<li><strong>应用程序</strong> 在 <strong>用户态</strong> 准备好调用参数，执行 int 指令触发 <strong>软中断</strong> ，中断号为 0x80 ；</li>
<li>CPU 被软中断打断后，执行对应的 <strong>中断处理函数</strong> ，这时便已进入 <strong>内核态</strong> ；</li>
<li><strong>系统调用处理函数</strong> 准备 <strong>内核执行栈</strong> ，并保存所有 <strong>寄存器</strong> (一般用汇编语言实现)；</li>
<li><strong>系统调用处理函数</strong> 根据 <strong>系统调用号</strong> 调用对应的 C 函数—— <strong>系统调用服务例程</strong> ；</li>
<li><strong>系统调用处理函数</strong> 准备 <strong>返回值</strong> 并从 <strong>内核栈</strong> 中恢复 <strong>寄存器</strong> ；</li>
<li><strong>系统调用处理函数</strong> 执行 ret 指令切换回 <strong>用户态</strong> ；</li>
</ol>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 进程线程区别</span><br><span class="line"></span><br><span class="line">**进程是资源分配的最小单位，线程是CPU调度的最小单位**</span><br><span class="line"></span><br><span class="line">每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**, 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段</span><br><span class="line"></span><br><span class="line">切换开销</span><br><span class="line"></span><br><span class="line">进程切换 切换虚拟地址空间，切换内核栈和硬件上下文, 缓存</span><br><span class="line"></span><br><span class="line">线程切换 切换内核栈和硬件上下文</span><br><span class="line"></span><br><span class="line">## IPC Inter-Process Communication</span><br><span class="line"></span><br><span class="line">##<span class="meta"># pipe 匿名管道</span></span><br><span class="line"></span><br><span class="line">内核开辟缓存区, 一端读一端写, 单向, 只能是父子进程</span><br><span class="line"></span><br><span class="line">##<span class="meta"># fifo 有名管道</span></span><br><span class="line"></span><br><span class="line">半双工, 允许无亲缘关系</span><br><span class="line"></span><br><span class="line">### 消息队列</span><br><span class="line"></span><br><span class="line">消息链表, 有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。`消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点`</span><br><span class="line"></span><br><span class="line">### 信号</span><br><span class="line"></span><br><span class="line">### 共享内存</span><br><span class="line"></span><br><span class="line">多进程访问同一个块内存</span><br><span class="line"></span><br><span class="line">分配 shmget 绑定 shmat</span><br><span class="line"></span><br><span class="line">### 套接字</span><br><span class="line"></span><br><span class="line">socket 编程</span><br><span class="line"></span><br><span class="line"># 算法</span><br><span class="line"></span><br><span class="line">## [红黑树](https:<span class="comment">//github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md)</span></span><br><span class="line"></span><br><span class="line">![img](https:<span class="comment">//github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png)</span></span><br><span class="line"></span><br><span class="line">本质上是平衡的二叉查找树</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1</span>）每个结点要么是红的，要么是黑的。  </span><br><span class="line">&gt; <span class="number">2</span>）根结点是黑的。  </span><br><span class="line">&gt; <span class="number">3</span>）每个叶结点（叶结点即指树尾端NIL指针或<span class="literal">NULL</span>结点）是黑的。  </span><br><span class="line">&gt; <span class="number">4</span>）如果一个结点是红的，那么它的俩个儿子都是黑的。  </span><br><span class="line">&gt; <span class="number">5</span>）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  </span><br><span class="line"></span><br><span class="line">## 排序</span><br><span class="line"></span><br><span class="line">![img](https:<span class="comment">//tva1.sinaimg.cn/large/e6c9d24ely1h0pr8a32oxj218z0u0n24.jpg)</span></span><br><span class="line"></span><br><span class="line">### 冒泡排序</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">bubbleSort</span>(vector&lt;<span class="keyword">int</span>&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) <span class="comment">//需要循环次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) <span class="comment">//每次需要比较个数</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]); <span class="comment">//不满足偏序，交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, minIndex; i &lt; len - <span class="number">1</span>; i++) <span class="comment">//需要循环次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        minIndex = i;                     <span class="comment">//最小下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) <span class="comment">//访问未排序的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[minIndex])</span><br><span class="line">                minIndex = j; <span class="comment">//找到最小的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j, temp; i &lt; len - <span class="number">1</span>; i++) <span class="comment">//需要循环次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        temp = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span> <span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Partition the array and get the pivot point</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quicksort</span>(arr, start, p - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quicksort</span>(arr, p + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The pivot element is taken to be the element at</span></span><br><span class="line">    <span class="comment">// the start of the subrange to be partitioned</span></span><br><span class="line">    <span class="keyword">int</span> pivotValue = arr[start];</span><br><span class="line">    <span class="keyword">int</span> pivotPosition = start;</span><br><span class="line">    <span class="comment">// Rearrange the rest of the array elements to partition the subrange from start to end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = start + <span class="number">1</span>; pos &lt;= end; pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[pos] &lt; pivotValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// arr[scan] is the &quot;current&quot; item.</span></span><br><span class="line">            <span class="comment">// Swap the current item with the item to the</span></span><br><span class="line">            <span class="comment">// right of the pivot element</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[pivotPosition + <span class="number">1</span>], arr[pos]);</span><br><span class="line">            <span class="comment">// Swap the current item with the pivot element</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[pivotPosition], arr[pivotPosition + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// Adjust the pivot position so it stays with the</span></span><br><span class="line">            <span class="comment">// pivot element</span></span><br><span class="line">            pivotPosition ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pivotPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a, vector&lt;<span class="keyword">int</span>&gt; &amp;T, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>, tmid = left + right &gt;&gt; <span class="number">1</span>, tleft = left, i = left;</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, T, left, mid), <span class="built_in">mergeSort</span>(a, T, mid, right);</span><br><span class="line">    <span class="keyword">while</span> (tleft &lt; mid || tmid &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmid &gt;= right || (tleft &lt; mid &amp;&amp; a[tleft] &lt;= a[tmid]))</span><br><span class="line">        &#123;</span><br><span class="line">            T[i++] = a[tleft++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T[i++] = a[tmid++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)</span><br><span class="line">        a[i] = T[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">T</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, T, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">    <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; a[i * <span class="number">2</span> + <span class="number">1</span>] &gt; a[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果有右子树，且右子树大于父节点和左节点，则将最大指针指向右子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; a[i * <span class="number">2</span> + <span class="number">2</span>] &gt; a[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[maxIndex], a[i]);</span><br><span class="line">        <span class="built_in">adjustHeap</span>(a, maxIndex,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//1.构建一个最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//从最后一个非叶子节点开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(a, i,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[<span class="number">0</span>], a[i]);</span><br><span class="line">        <span class="built_in">adjustHeap</span>(a, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><blockquote>
<p>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</p>
<p>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</p>
<p>任意节点的左、右子树也分别为二叉查找树；</p>
<p><strong>没有键值相等的节点</strong></p>
</blockquote>
<p>查找插入 O(logn)~O(n)</p>
<p>插入: 总是插入叶子节点</p>
<p>删除叶子节点: 直接删除</p>
<p>删除有一个子节点的节点: 替换</p>
<p>删除有两个子节点的节点: 则将其右子树的最小数据代替此节点的数据</p>
<p>中序遍历从小到大</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>为了防止退化成线性表 O(n)</p>
<p>左右层级不大于 1</p>
<p>（1）非叶子节点最多拥有两个子节点；</p>
<p>（2）非叶子节值大于左边子节点、小于右边子节点；</p>
<p>（3）树的左右两边的层级数相差不会大于1;</p>
<h2 id="堆-priority-queue"><a href="#堆-priority-queue" class="headerlink" title="堆(priority_queue)"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/changyuanchn/article/details/14564403">堆(priority_queue)</a></h2><p>它能够使插入（Insert）和删除最值（Delete）这两种操作的最坏时间复杂度为O(N)，而插入的平均时间复杂度为常数时间，即O(1)。</p>
<p>Heap（堆）是一个除了底层节点外的<strong>完全填满的二叉树</strong>，底层可以不完全，左到右填充节点。</p>
<p>（a）完全二叉树；（b）父节点小于后继子节点</p>
<p>堆的插入是按照顺序插入到底层的结点上，然后与他的父节点比较，如果小于父节点，那么此结点与父节点交换位置，否则，这个位置就是应该插入的位置，依次循环</p>
<h2 id="链表与数组"><a href="#链表与数组" class="headerlink" title="链表与数组"></a>链表与数组</h2><ul>
<li><p>链表</p>
<p>插入删除快, 内存利用率, 可扩展</p>
</li>
<li><p>数组</p>
<p>空间少, 随机访问</p>
</li>
</ul>
<h2 id="链表中环的检测"><a href="#链表中环的检测" class="headerlink" title="链表中环的检测"></a>链表中环的检测</h2><ul>
<li><p>hash</p>
</li>
<li><p>快慢指针</p>
<p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与slow 指针在环中相遇。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul>
<li><a target="_blank" rel="noopener" href="https://ty-chen.github.io/linux-kernel-pipe/">PIPE</a></li>
</ul>
<h1 id="beyond-coding"><a href="#beyond-coding" class="headerlink" title="beyond coding"></a>beyond coding</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> Singleton* instance;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">	~<span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">NULL</span>) </span><br><span class="line">			instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/software-testing-basics/">Software Testing</a> can be majorly classified into two categories: </p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/software-engineering-black-box-testing/"><strong>Black Box Testing</strong></a> is a software testing method in which the internal structure/ design/ implementation of the item being tested is <strong>not known to the tester</strong> </li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/software-engineering-white-box-testing/"><strong>White Box Testing</strong></a> is a software testing method in which the internal structure/ design/ implementation of the item being tested is <strong>known to the tester.</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="left">Black Box Testing</th>
<th align="left">White Box Testing</th>
</tr>
</thead>
<tbody><tr>
<td align="left">It is a way of software testing in which the internal structure or the program or the code is hidden and nothing is known about it.</td>
<td align="left">It is a way of testing the software in which the tester has knowledge about the internal structure or the code or the program of the software.</td>
</tr>
<tr>
<td align="left">It is mostly done by software testers.</td>
<td align="left">It is mostly done by software developers.</td>
</tr>
<tr>
<td align="left">No knowledge of implementation is needed.</td>
<td align="left">Knowledge of implementation is required.</td>
</tr>
<tr>
<td align="left">It can be referred as <strong>outer</strong> or external software testing.</td>
<td align="left">It is the inner or the <strong>internal</strong> software testing.</td>
</tr>
<tr>
<td align="left">It is <strong>functional</strong> test of the software.</td>
<td align="left">It is <strong>structural</strong> test of the software.</td>
</tr>
<tr>
<td align="left">This testing can be initiated on the basis of requirement specifications document.</td>
<td align="left">This type of testing of software is started after detail design document.</td>
</tr>
<tr>
<td align="left">No knowledge of programming is required.</td>
<td align="left">It is mandatory to have knowledge of programming.</td>
</tr>
<tr>
<td align="left">It is the behavior testing of the software.</td>
<td align="left">It is the logic testing of the software.</td>
</tr>
<tr>
<td align="left">It is applicable to the higher levels of testing of software.</td>
<td align="left">It is generally applicable to the lower levels of software testing.</td>
</tr>
<tr>
<td align="left">It is also called closed testing.</td>
<td align="left">It is also called as clear box testing.</td>
</tr>
<tr>
<td align="left">It is least time consuming.</td>
<td align="left">It is most time consuming.</td>
</tr>
<tr>
<td align="left">It is not suitable or preferred for algorithm testing.</td>
<td align="left">It is <strong>suitable for algorithm testing.</strong></td>
</tr>
<tr>
<td align="left">Can be done by trial and error ways and methods.</td>
<td align="left">Data domains along with inner or internal boundaries can be better tested.</td>
</tr>
<tr>
<td align="left"><strong>Example:</strong> search something on google by using keywords</td>
<td align="left"><strong>Example:</strong> by input to check and verify loops</td>
</tr>
<tr>
<td align="left"><strong>Types of Black Box Testing:</strong>   A. Functional Testing   B. Non-functional testing   C. Regression Testing</td>
<td align="left"><strong>Types of White Box Testing:</strong>   A. Path Testing   B. Loop Testing   C. Condition testing</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Sinos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sinos_wei.gitee.io/2021/12/06/%E9%9D%A2%E7%BB%8F/">https://sinos_wei.gitee.io/2021/12/06/%E9%9D%A2%E7%BB%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover/IMG_2423.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/%E8%AF%BE%E7%A8%8B-%E6%80%BB/"><img class="prev-cover" src="/img/cover/52fe3e2c7n2c69c14b8de26b317f6438.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">课程提纲(乱)</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/30/%E6%AF%8F%E4%B8%AA%E5%86%85%E5%AD%98-%E8%87%AA%E7%BF%BB/"><img class="next-cover" src="/img/cover/IMG_2538.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">每个内存_自翻</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sinos</div><div class="author-info__description">己所不欲, 勿施于人</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">31</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lightmanwei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:akunda@sina.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fib"><span class="toc-number">2.1.</span> <span class="toc-text">fib</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#grid-travel"><span class="toc-number">2.2.</span> <span class="toc-text">grid travel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#can-sum"><span class="toc-number">2.3.</span> <span class="toc-text">can sum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">3.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">3.2.</span> <span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%80%BC%E4%B8%8D%E9%87%8D%E5%A4%8D-%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">前序遍历+中序遍历(值不重复) 构建二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#top-k"><span class="toc-number">5.</span> <span class="toc-text">top k</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C"><span class="toc-number">6.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">拷贝初始化 直接初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-volatile"><span class="toc-number">6.2.</span> <span class="toc-text">final volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">6.4.</span> <span class="toc-text">菱形继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.5.</span> <span class="toc-text">多态是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">6.6.</span> <span class="toc-text">虚函数是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">6.7.</span> <span class="toc-text">面向对象三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.8.</span> <span class="toc-text">指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">6.9.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource-acquisition-is-initialization"><span class="toc-number">6.10.</span> <span class="toc-text">Resource acquisition is initialization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-new"><span class="toc-number">6.11.</span> <span class="toc-text">malloc new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E4%BD%9C%E7%94%A8"><span class="toc-number">6.12.</span> <span class="toc-text">static 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memset-memcpy-strcpy"><span class="toc-number">6.13.</span> <span class="toc-text">memset memcpy strcpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F"><span class="toc-number">6.14.</span> <span class="toc-text">内联函数和宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11"><span class="toc-number">6.15.</span> <span class="toc-text">c++11</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl-%E5%AE%B9%E5%99%A8"><span class="toc-number">6.16.</span> <span class="toc-text">stl 容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">7.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5-URL-%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">浏览器输入 URL 后发生了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http1-0-http1-1-http2-0"><span class="toc-number">7.2.</span> <span class="toc-text">http1.0&#x2F;http1.1&#x2F;http2.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-number">7.3.</span> <span class="toc-text">中间人攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https"><span class="toc-number">7.4.</span> <span class="toc-text">https</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#post-get"><span class="toc-number">7.5.</span> <span class="toc-text">post get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#content-type"><span class="toc-number">7.6.</span> <span class="toc-text">content-type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">7.7.</span> <span class="toc-text">tcp如何保证可靠传输</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%8E%9F"><span class="toc-number">8.</span> <span class="toc-text">组原</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">编译器编译代码的四个过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">8.2.</span> <span class="toc-text">内存对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="toc-number">8.3.</span> <span class="toc-text">内存对齐规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.4.</span> <span class="toc-text">c++ 内存管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU"><span class="toc-number">9.1.</span> <span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">调用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">9.2.2.</span> <span class="toc-text">执行态切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">9.3.</span> <span class="toc-text">生产者消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.2.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.3.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.5.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">9.4.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">9.5.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.6.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86-priority-queue"><span class="toc-number">9.7.</span> <span class="toc-text">堆(priority_queue)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">9.8.</span> <span class="toc-text">链表与数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">9.9.</span> <span class="toc-text">链表中环的检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">10.</span> <span class="toc-text">项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#beyond-coding"><span class="toc-number">11.</span> <span class="toc-text">beyond coding</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">11.2.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/28/ShellScript/" title="ShellScript"><img src="/img/cover/IMG_2493.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ShellScript"/></a><div class="content"><a class="title" href="/2022/06/28/ShellScript/" title="ShellScript">ShellScript</a><time datetime="2022-06-28T11:22:05.000Z" title="Created 2022-06-28 19:22:05">2022-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/27/%E7%BD%97%E7%BF%94%E8%AF%B4%E5%88%91%E6%B3%95/" title="罗翔说刑法"><img src="/img/cover/IMG_0779.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="罗翔说刑法"/></a><div class="content"><a class="title" href="/2022/06/27/%E7%BD%97%E7%BF%94%E8%AF%B4%E5%88%91%E6%B3%95/" title="罗翔说刑法">罗翔说刑法</a><time datetime="2022-06-27T12:41:46.000Z" title="Created 2022-06-27 20:41:46">2022-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/04/OS3pieces%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="OS3pieces读书笔记"><img src="/img/cover/IMG_2484.PNG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS3pieces读书笔记"/></a><div class="content"><a class="title" href="/2022/06/04/OS3pieces%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="OS3pieces读书笔记">OS3pieces读书笔记</a><time datetime="2022-06-04T08:47:16.000Z" title="Created 2022-06-04 16:47:16">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src="/img/cover/52fe3e2c7n2c69c14b8de26b317f6438.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2022/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2022-05-09T11:32:45.000Z" title="Created 2022-05-09 19:32:45">2022-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%86%E5%8F%B2/" title="操作系统历史"><img src="/img/cover/IMG_2284.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统历史"/></a><div class="content"><a class="title" href="/2022/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%86%E5%8F%B2/" title="操作系统历史">操作系统历史</a><time datetime="2022-05-05T00:35:13.000Z" title="Created 2022-05-05 08:35:13">2022-05-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Sinos</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">NB</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Local search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>